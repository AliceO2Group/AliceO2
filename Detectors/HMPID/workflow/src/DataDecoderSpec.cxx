// draft
// Copyright CERN and copyright holders of ALICE O2. This software is
// distributed under the terms of the GNU General Public License v3 (GPL
// Version 3), copied verbatim in the file "COPYING".
//
// See http://alice-o2.web.cern.ch/license for full licensing information.
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

///
/// \file    DatDecoderSpec.cxx
/// \author  
///
/// \brief Implementation of a data processor to run the HMPID raw decoding
///

#include <random>
#include <iostream>
#include <fstream>
#include <stdexcept>
#include <array>
#include <functional>
#include <vector>

#include "Framework/CallbackService.h"
#include "Framework/ConfigParamRegistry.h"
#include "Framework/ControlService.h"
#include "Framework/DataProcessorSpec.h"
#include "Framework/Lifetime.h"
#include "Framework/Output.h"
#include "Framework/Task.h"
#include "Framework/WorkflowSpec.h"

#include "Headers/RAWDataHeader.h"
#include "DetectorsRaw/RDHUtils.h"
#include "DPLUtils/DPLRawParser.h"

#include "HMPIDBase/Digit.h"
#include "HMPIDBase/Geo.h"
#include "HMPIDReconstruction/HmpidDecodeRawMem.h"
#include "HMPIDWorkflow/DataDecoderSpec.h"

namespace o2
{
namespace hmpid
{

using namespace o2;
using namespace o2::framework;
using RDH = o2::header::RDHAny;

//=======================
// Data decoder
void DataDecoderTask::init(framework::InitContext& ic)
{
    mDeco = new o2::hmpid::HmpidDecodeRawDigit(Geo::MAXEQUIPMENTS);
    mDeco->init();


    return;
}

void DataDecoderTask::run(framework::ProcessingContext& pc)
{
  mDeco->mDigits.clear();

  decodeTF(pc);


//  for (auto&& input : pc.inputs()) {
//    std::cout << " ******* input " << input.spec->binding << std::endl;


  LOG(INFO) << "[HMPID Data Decoder - run] Writing " << mDeco->mDigits.size() << " Digits ...";
  pc.outputs().snapshot(o2::framework::Output{"HMP", "DIGITS", 0, o2::framework::Lifetime::Timeframe}, mDeco->mDigits);

}

/*    auto& digits = mDecoder->getOutputDigits();
  auto& orbits = mDecoder->getOrbits();

  if (mPrint) {
    for (auto d : digits) {
      std::cout << " DE# " << d.getDetID() << " PadId " << d.getPadID() << " ADC " << d.getADC() << " time " << d.getTime().sampaTime << std::endl;
    }
  }
  // send the output buffer via DPL
  size_t digitsSize, orbitsSize;
  char* digitsBuffer = createBuffer(digits, digitsSize);
  char* orbitsBuffer = createBuffer(orbits, orbitsSize);

  // create the output message
  auto freefct = [](void* data, void*) { free(data); };
//  pc.outputs().adoptChunk(Output{"MCH", "DIGITS", 0}, digitsBuffer, digitsSize, freefct, nullptr);
//  pc.outputs().adoptChunk(Output{"MCH", "ORBITS", 0}, orbitsBuffer, orbitsSize, freefct, nullptr);
*/


  //_________________________________________________________________________________________________
// the decodeTF() function processes the the messages generated by the (sub)TimeFrame builder
void DataDecoderTask::decodeTF(framework::ProcessingContext& pc)
{
  LOG(INFO) << "*********** In decodeTF **************");

  // get the input buffer
  auto& inputs = pc.inputs();
  DPLRawParser parser(inputs, o2::framework::select("TF:HMP/RAWDATA"));

  for (auto it = parser.begin(), end = parser.end(); it != end; ++it) {
    uint32_t *theBuffer = (uint32_t *)it.raw();
    mDeco->setUpStream(theBuffer, it.size()+it.offset());
    mDeco->decodePageFast(&theBuffer);
  }
  /*
    int equipmentIndex = -1;
    HmpidEquipment *eq;

    // get the input buffer
    auto& inputs = pc.inputs();
    DPLRawParser parser(inputs, o2::framework::select("TF:HMP/RAWDATA"));

    for (auto it = parser.begin(), end = parser.end(); it != end; ++it) {
      size_t payloadSize = it.size();
      if(payloadSize <= 0) {
        LOG(INFO) << "Payload empty";
        continue;
      }

      auto const* rdh = it.get_if<RDH>();
      auto const* raw = it.raw();
      uint32_t* data = (uint32_t*)it.data();

      try {
        mDeco->decodeHeader((uint32_t *)rdh, &equipmentIndex);
      }
      catch (int e) {
        LOG(ERROR) << "Failed to decode the Header !";
        throw TH_WRONGHEADER;
      }
      eq = mDeco->evaluateHeaderContents(equipmentIndex);

      uint32_t wpprev = 0;
      uint32_t wp = 0;
      int newOne = true;
      int p1, p2, p3, p4;
      int error;

      int payIndex = 0;
      while (payIndex < mDeco->mNumberWordToRead) {  //start the payload loop word by word
        wpprev = wp;
        wp = *data; data++;
        if (wp == wpprev) {
          LOG(DEBUG) << "Equip=" << mDeco->mEquipment << mDeco->sErrorDescription[ERR_DUPLICATEPAD] << " col=" << (eq->mSegment) * 8 + eq->mColumnCounter << \
              "[" << p1 << "]";
        } else {
          if( mDeco->isPadWord(wp, &error, &p1, &p2, &p3, &p4) == true) {
            if( error != false) {
              eq->setPad(p1 - 1, p2 - 1, p3, p4);
              mDigits.push_back(Digit(mDeco->mHeBCDI, mDeco->mHeORBIT,
				  o2::hmpid::Geo::GetPad(equipmentIndex, p1 - 1, p2 - 1, p3),
				  p4));
              eq->mSampleNumber++;
            }
          }
        }
        payIndex += 1;
      }

      LOG(DEBUG) << " ***** payloadSize = " << payloadSize;
      
    }
    // cycle in order to update info for the last event
    for (int i = 0; i < mDeco->mNumberOfEquipments; i++) {
      if (mDeco->mTheEquipments[i]->mNumberOfEvents > 0) {
	  mDeco->updateStatistics(mDeco->mTheEquipments[i]);
      }
    }
*/
}

  //_________________________________________________________________________________________________
  // the decodeReadout() function processes the messages generated by o2-mch-cru-page-reader-workflow
/*  void decodeReadout(const o2::framework::DataRef& input)
  {
    static int nFrame = 1;
    // get the input buffer
    if (input.spec->binding != "readout") {
      return;
    }

    const auto* header = o2::header::get<header::DataHeader*>(input.header);
    if (!header) {
      return;
    }

    auto const* raw = input.payload;
    // cout size of payload
     std::cout << " payloadSize " << header->payloadSize << std::endl;
    //size_t payloadSize = header->payloadSize;

    if (mPrint) {
      std::cout << nFrame << "  payloadSize=" << payloadSize << std::endl;
    }
    nFrame += 1;
    if (payloadSize == 0) {
      return;
    }

    gsl::span<const std::byte> buffer(reinterpret_cast<const std::byte*>(raw), payloadSize);
    mDecoder->decodeBuffer(buffer);
  }
*/
  //_________________________________________________________________________________________________

//_________________________________________________________________________________________________
o2::framework::DataProcessorSpec getDecodingSpec(std::string inputSpec)
//o2::framework::DataPrecessorSpec getDecodingSpec()
{
  
  std::vector<o2::framework::InputSpec> inputs;
  inputs.emplace_back("RAWDATA", o2::header::gDataOriginHMP, "RAWDATA", 0, Lifetime::Timeframe);

  std::vector<o2::framework::OutputSpec> outputs;
  outputs.emplace_back("HMP", "DIGITS", 0, o2::framework::Lifetime::Timeframe);
  outputs.emplace_back("HMP", "ORBITS", 0, o2::framework::Lifetime::Timeframe);
  outputs.emplace_back("HMP", "STATS", 0, o2::framework::Lifetime::Timeframe);

  
  return DataProcessorSpec{
    "HMP-DataDecoder",
    inputs,
    outputs,
    AlgorithmSpec{adaptFromTask<DataDecoderTask>()},
    Options{{"print", VariantType::Bool, false, {"print digits"}},
            {"cru-map", VariantType::String, "", {"custom CRU mapping"}},
            {"fec-map", VariantType::String, "", {"custom FEC mapping"}},
            {"ds2manu", VariantType::Bool, false, {"convert channel numbering from Run3 to Run1-2 order"}}}};
}

} // namespace hmpid
} // end namespace o2
