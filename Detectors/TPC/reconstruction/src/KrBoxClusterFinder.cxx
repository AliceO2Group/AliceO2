// Copyright CERN and copyright holders of ALICE O2. This software is
// distributed under the terms of the GNU General Public License v3 (GPL
// Version 3), copied verbatim in the file "COPYING".
//
// See http://alice-o2.web.cern.ch/license for full licensing information.
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file KrBoxClusterFinder3D.cpp
/// \brief Class source code for Krypton and X-ray events
/// \author Philip Hauer <hauer@hiskp.uni-bonn.de>

#include "TPCReconstruction/KrBoxClusterFinder.h"
#include "Framework/Logger.h"

using namespace o2::tpc;

// Constructor:
// This function creates a three dimensional vector (Pad,Row,Time) which is
// filled with the charges
KrBoxClusterFinder::KrBoxClusterFinder(std::vector<o2::tpc::Digit>& eventSector)
{
  if (eventSector.size() == 0) {
    // prevents a segementation fault if the envent contains no data
    // segementation fault would occure later when trying to dereference the
    // max/min pointer (which are nullptr if data is empty) empty events should
    // be catched in the main function, hence, this "if" is no longer necessary
    LOGP(warning, "Sector size (amount of data points) in current run is 0!");
    LOGP(warning, "mMapOfAllDigits with 0's is generated in order to prevent a segementation fault.");

    return;
  }

  // Fill digits map
  for (const auto& digit : eventSector) {
    mMapOfAllDigits[digit.getTimeStamp()][digit.getRow()][digit.getPad()] = digit.getChargeFloat();
  }
}

//#################################################

// Function to update the temporal cluster
void KrBoxClusterFinder::updateTempClusterFinal()
{
  const float oneOverQtot = 1. / mTempCluster.totCharge;
  mTempCluster.meanPad *= oneOverQtot;
  mTempCluster.sigmaPad *= oneOverQtot;
  mTempCluster.meanRow *= oneOverQtot;
  mTempCluster.sigmaRow *= oneOverQtot;
  mTempCluster.meanTime *= oneOverQtot;
  mTempCluster.sigmaTime *= oneOverQtot;
  mTempCluster.sigmaPad = std::sqrt(std::abs(mTempCluster.sigmaPad - mTempCluster.meanPad * mTempCluster.meanPad));
  mTempCluster.sigmaRow = std::sqrt(std::abs(mTempCluster.sigmaRow - mTempCluster.meanRow * mTempCluster.meanRow));
  mTempCluster.sigmaTime = std::sqrt(std::abs(mTempCluster.sigmaTime - mTempCluster.meanTime * mTempCluster.meanTime));
}

// Function to update the temporal cluster.
void KrBoxClusterFinder::updateTempCluster(float tempCharge, int tempPad, int tempRow, int tempTime)
{
  if (tempCharge < mQThreshold) {
    LOGP(warning, "Update cluster was called but current charge is below mQThreshold");
    return;
  }

  mTempCluster.size += 1;
  mTempCluster.totCharge += tempCharge;

  mTempCluster.meanPad += tempPad * tempCharge;
  mTempCluster.sigmaPad += tempPad * tempPad * tempCharge;

  mTempCluster.meanRow += tempRow * tempCharge;
  mTempCluster.sigmaRow += tempRow * tempRow * tempCharge;

  mTempCluster.meanTime += tempTime * tempCharge;
  mTempCluster.sigmaTime += tempTime * tempTime * tempCharge;

  if (tempCharge > mTempCluster.maxCharge) {
    mTempCluster.maxCharge = tempCharge;
  }
}

// This function finds and evaluates all clusters in a 3D mMapOfAllDigits generated by the
// mMapOfAllDigitsCreator function, this function also updates the cluster tree
// conditions are extrapolation of the 5x5 cluster case to arbitrary
// cluster sizes in 3 dimensions
KrCluster KrBoxClusterFinder::buildCluster(int clusterCenterPad, int clusterCenterRow, int clusterCenterTime)
{
  mTempCluster = KrCluster();

  for (int iTime = -mMaxClusterSizeTime; iTime <= mMaxClusterSizeTime; iTime++) {
    for (int iRow = -mMaxClusterSizeRow; iRow <= mMaxClusterSizeRow; iRow++) {
      for (int iPad = -mMaxClusterSizePad; iPad <= mMaxClusterSizePad; iPad++) {
        // First: Check if we might check outside of map:
        if (clusterCenterTime + iTime < 0 || clusterCenterTime + iTime >= MaxTimes || clusterCenterPad + iPad < 0 || clusterCenterPad + iPad >= MaxPads || clusterCenterRow + iRow < 0 || clusterCenterRow + iRow >= MaxRows || mMapOfAllDigits.at(clusterCenterTime + iTime).at(clusterCenterRow + iRow).at(clusterCenterPad + iPad) <= mQThreshold) {
          continue;
        }
        // If not, there are several cases which were explained (for 2D) in the header of the code.
        // The first one is for the diagonal. So, the digit we are investigating here is on the diagonal:
        else if (std::abs(iTime) == std::abs(iPad) && std::abs(iTime) == std::abs(iRow)) {
          // Now we check, if the next inner digit has a signal above threshold:
          if (mMapOfAllDigits[clusterCenterTime + iTime - signnum(iTime)][clusterCenterRow + iRow - signnum(iRow)][clusterCenterPad + iPad - signnum(iPad)] > mQThreshold) {
            // If yes, the cluster gets updated with the digit on the diagonal.
            updateTempCluster(mMapOfAllDigits[clusterCenterTime + iTime][clusterCenterRow + iRow][clusterCenterPad + iPad], clusterCenterPad + iPad, clusterCenterRow + iRow, clusterCenterTime + iTime);
          }
        }
        // Basically, we go through every possible case in the next few if-else conditions:
        else if (std::abs(iTime) == std::abs(iPad)) {
          if (mMapOfAllDigits[clusterCenterTime + iTime - signnum(iTime)][clusterCenterRow + iRow][clusterCenterPad + iPad - signnum(iPad)] > mQThreshold) {
            updateTempCluster(mMapOfAllDigits[clusterCenterTime + iTime][clusterCenterRow + iRow][clusterCenterPad + iPad], clusterCenterPad + iPad, clusterCenterRow + iRow, clusterCenterTime + iTime);
          }
        } else if (std::abs(iTime) == std::abs(iRow)) {
          if (mMapOfAllDigits[clusterCenterTime + iTime - signnum(iTime)][clusterCenterRow + iRow - signnum(iRow)][clusterCenterPad + iPad] > mQThreshold) {
            updateTempCluster(mMapOfAllDigits[clusterCenterTime + iTime][clusterCenterRow + iRow][clusterCenterPad + iPad], clusterCenterPad + iPad, clusterCenterRow + iRow, clusterCenterTime + iTime);
          }
        } else if (std::abs(iPad) == std::abs(iRow)) {
          if (mMapOfAllDigits[clusterCenterTime + iTime][clusterCenterRow + iRow - signnum(iRow)][clusterCenterPad + iPad - signnum(iPad)] > mQThreshold) {
            updateTempCluster(mMapOfAllDigits[clusterCenterTime + iTime][clusterCenterRow + iRow][clusterCenterPad + iPad], clusterCenterPad + iPad, clusterCenterRow + iRow, clusterCenterTime + iTime);
          }
        } else if (std::abs(iTime) > std::abs(iPad) && std::abs(iTime) > std::abs(iRow)) {
          if (mMapOfAllDigits[clusterCenterTime + iTime - signnum(iTime)][clusterCenterRow + iRow][clusterCenterPad + iPad] > mQThreshold) {
            updateTempCluster(mMapOfAllDigits[clusterCenterTime + iTime][clusterCenterRow + iRow][clusterCenterPad + iPad], clusterCenterPad + iPad, clusterCenterRow + iRow, clusterCenterTime + iTime);
          }
        } else if (std::abs(iTime) < std::abs(iPad) && std::abs(iPad) > std::abs(iRow)) {
          if (mMapOfAllDigits[clusterCenterTime + iTime][clusterCenterRow + iRow][clusterCenterPad + iPad - signnum(iPad)] > mQThreshold) {
            updateTempCluster(mMapOfAllDigits[clusterCenterTime + iTime][clusterCenterRow + iRow][clusterCenterPad + iPad], clusterCenterPad + iPad, clusterCenterRow + iRow, clusterCenterTime + iTime);
          }
        } else if (std::abs(iTime) < std::abs(iRow) && std::abs(iPad) < std::abs(iRow)) {
          if (mMapOfAllDigits[clusterCenterTime + iTime][clusterCenterRow + iRow - signnum(iRow)][clusterCenterPad + iPad] > mQThreshold) {
            updateTempCluster(mMapOfAllDigits[clusterCenterTime + iTime][clusterCenterRow + iRow][clusterCenterPad + iPad], clusterCenterPad + iPad, clusterCenterRow + iRow, clusterCenterTime + iTime);
          }
        }
      }
    }
  }
  // At the end, out mTempCluster should contain all digits that were assigned to the cluster.
  // So before returning it, we update it one last time to calculate the correct means and sigmas.
  updateTempClusterFinal();
  return mTempCluster;
}
