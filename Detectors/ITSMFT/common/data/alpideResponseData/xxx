   ------------------------------------------------------------------
  | Welcome to ROOT 6.26/04                        https://root.cern |
  | (c) 1995-2021, The ROOT Team; conception: R. Brun, F. Rademakers |
  | Built for linuxx8664gcc on Aug 04 2022, 07:47:00                 |
  | From tags/v6-26-04-patches-alice1@v6-26-02-71-g492a133770        |
  | With c++ (GCC) 10.2.0                                            |
  | Try '.help', '.demo', '.license', '.credits', '.quit'/'.q'       |
   ------------------------------------------------------------------


Processing alpideResponse.C...
G__O2ITSMFTSimulation dictionary payload:651:33: error: field has incomplete type 'o2::itsmft::AlpideSimResponse'
  o2::itsmft::AlpideSimResponse mAlpSimResp[2]; // simulated response
                                ^
G__O2ITSMFTSimulation dictionary forward declarations' payload:9:37: note: forward declaration of 'o2::itsmft::AlpideSimResponse'
namespace o2{namespace itsmft{class AlpideSimResponse;}}
                                    ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class o2::itsmft::AlpideRespSimMat with content:

#line 1 "G__O2ITSMFTSimulation dictionary payload"

#ifndef ZDC_FASTSIM_ONNX
  #define ZDC_FASTSIM_ONNX 1
#endif
#ifndef ENABLE_UPGRADES
  #define ENABLE_UPGRADES 1
#endif
#ifndef FMT_LOCALE
  #define FMT_LOCALE 1
#endif
#ifndef FMT_SHARED
  #define FMT_SHARED 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef FAIRMQ_HAS_STD_FILESYSTEM
  #define FAIRMQ_HAS_STD_FILESYSTEM 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_CONTAINER_DYN_LINK
  #define BOOST_CONTAINER_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_PROGRAM_OPTIONS_DYN_LINK
  #define BOOST_PROGRAM_OPTIONS_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_FILESYSTEM_DYN_LINK
  #define BOOST_FILESYSTEM_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_REGEX_DYN_LINK
  #define BOOST_REGEX_DYN_LINK 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_IOSTREAMS_DYN_LINK
  #define BOOST_IOSTREAMS_DYN_LINK 1
#endif
#ifndef DPL_ENABLE_BACKTRACE
  #define DPL_ENABLE_BACKTRACE 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_SERIALIZATION_DYN_LINK
  #define BOOST_SERIALIZATION_DYN_LINK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Hit.h
/// \brief Definition of the ITSMFT Hit class

#ifndef ALICEO2_ITSMFT_POINT_H_
#define ALICEO2_ITSMFT_POINT_H_

#include "SimulationDataFormat/BaseHits.h" // for BasicXYZEHit
#include "Rtypes.h"                        // for Bool_t, Double_t, Int_t, Double32_t, etc
#include "TVector3.h"                      // for TVector3
#include <iosfwd>
#include "CommonUtils/ShmAllocator.h"

namespace o2
{
namespace itsmft
{

class Hit : public o2::BasicXYZEHit<Float_t, Float_t>
{

 public:
  enum HitStatus_t {
    kTrackEntering = 0x1,
    kTrackInside = 0x1 << 1,
    kTrackExiting = 0x1 << 2,
    kTrackOut = 0x1 << 3,
    kTrackStopped = 0x1 << 4,
    kTrackAlive = 0x1 << 5
  };

  /// Default constructor
  Hit() = default;

  /// Class Constructor
  /// \param trackID Index of MCTrack
  /// \param detID Detector ID
  /// \param startPos Coordinates at entrance to active volume [cm]
  /// \param pos Coordinates to active volume [cm]
  /// \param mom Momentum of track at entrance [GeV]
  /// \param endTime Time at entrance [ns]
  /// \param time Time since event start [ns]
  /// \param eLoss Energy deposit [GeV]
  /// \param startStatus: status at entrance
  /// \param endStatus: status at exit
  inline Hit(int trackID, unsigned short detID, const TVector3& startPos, const TVector3& pos, const TVector3& mom, double startE,
             double endTime, double eLoss, unsigned char statusStart, unsigned char status);

  // Entrance position getters
  math_utils::Point3D<Float_t> GetPosStart() const { return mPosStart; }
  Float_t GetStartX() const { return mPosStart.X(); }
  Float_t GetStartY() const { return mPosStart.Y(); }
  Float_t GetStartZ() const { return mPosStart.Z(); }
  template <typename F>
  void GetStartPosition(F& x, F& y, F& z) const
  {
    x = GetStartX();
    y = GetStartY();
    z = GetStartZ();
  }
  // momentum getters
  math_utils::Vector3D<Float_t> GetMomentum() const { return mMomentum; }
  math_utils::Vector3D<Float_t>& GetMomentum() { return mMomentum; }
  Float_t GetPx() const { return mMomentum.X(); }
  Float_t GetPy() const { return mMomentum.Y(); }
  Float_t GetPz() const { return mMomentum.Z(); }
  Float_t GetE() const { return mE; }
  Float_t GetTotalEnergy() const { return GetE(); }

  UChar_t GetStatusEnd() const { return mTrackStatusEnd; }
  UChar_t GetStatusStart() const { return mTrackStatusStart; }

  Bool_t IsEntering() const { return mTrackStatusEnd & kTrackEntering; }
  Bool_t IsInside() const { return mTrackStatusEnd & kTrackInside; }
  Bool_t IsExiting() const { return mTrackStatusEnd & kTrackExiting; }
  Bool_t IsOut() const { return mTrackStatusEnd & kTrackOut; }
  Bool_t IsStopped() const { return mTrackStatusEnd & kTrackStopped; }
  Bool_t IsAlive() const { return mTrackStatusEnd & kTrackAlive; }

  Bool_t IsEnteringStart() const { return mTrackStatusStart & kTrackEntering; }
  Bool_t IsInsideStart() const { return mTrackStatusStart & kTrackInside; }
  Bool_t IsExitingStart() const { return mTrackStatusStart & kTrackExiting; }
  Bool_t IsOutStart() const { return mTrackStatusStart & kTrackOut; }
  Bool_t IsStoppedStart() const { return mTrackStatusStart & kTrackStopped; }
  Bool_t IsAliveStart() const { return mTrackStatusStart & kTrackAlive; }

  /// Output to screen
  void Print(const Option_t* opt) const;
  friend std::ostream& operator<<(std::ostream& of, const Hit& point)
  {
    of << "-I- Hit: O2its point for track " << point.GetTrackID() << " in detector " << point.GetDetectorID() << std::endl;
    /*
      of << "    Position (" << point.fX << ", " << point.fY << ", " << point.fZ << ") cm" << std::endl;
      of << "    Momentum (" << point.fPx << ", " << point.fPy << ", " << point.fPz << ") GeV" << std::endl;
      of << "    Time " << point.fTime << " ns,  Length " << point.fLength << " cm,  Energy loss "
      << point.fELoss * 1.0e06 << " keV" << std::endl;
      */
    return of;
  }

 private:
  math_utils::Vector3D<Float_t> mMomentum; ///< momentum at entrance
  math_utils::Point3D<Float_t> mPosStart;  ///< position at entrance (base mPos give position on exit)
  Float_t mE;                              ///< total energy at entrance
  UChar_t mTrackStatusEnd;                 ///< MC status flag at exit
  UChar_t mTrackStatusStart;               ///< MC status at starting point

  ClassDefNV(Hit, 3);
};

Hit::Hit(int trackID, unsigned short detID, const TVector3& startPos, const TVector3& endPos, const TVector3& startMom,
         double startE, double endTime, double eLoss, unsigned char startStatus, unsigned char endStatus)
  : BasicXYZEHit(endPos.X(), endPos.Y(), endPos.Z(), endTime, eLoss, trackID, detID),
    mMomentum(startMom.Px(), startMom.Py(), startMom.Pz()),
    mPosStart(startPos.X(), startPos.Y(), startPos.Z()),
    mE(startE),
    mTrackStatusEnd(endStatus),
    mTrackStatusStart(startStatus)
{
}

} // namespace itsmft
} // namespace o2

#ifdef USESHM
namespace std
{
template <>
class allocator<o2::itsmft::Hit> : public o2::utils::ShmAllocator<o2::itsmft::Hit>
{
};
} // namespace std

#endif

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file AlpideSimResponse.h
/// \brief Definition of the ITSMFT Alpide simulated response parametrization

#ifndef ALICEO2_ITSSMFT_ALPIDESIMRESPONSE_H
#define ALICEO2_ITSSMFT_ALPIDESIMRESPONSE_H

#include <array>
#include <string>
#include <vector>
#include <Rtypes.h>

#include "ITSMFTBase/SegmentationAlpide.h"

namespace o2
{
namespace itsmft
{
/*
 * AlpideRespSimMat : class to access the response: probability to collect electron 
 * in MNPix*MNPix cells. 
 */
class AlpideRespSimMat
{
 public:
  static int constexpr NPix = 5;              /// side of quadrant (pixels) with non-0 response
  static int constexpr MatSize = NPix * NPix; /// number of pixels in the quadrant
  static int constexpr getNPix() { return NPix; }

  AlpideRespSimMat() = default;
  ~AlpideRespSimMat() = default;

  void adopt(const AlpideRespSimMat& src, bool flipRow = false, bool flipCol = false)
  {
    // copy constructor with option of channels flipping
    for (int iRow = NPix; iRow--;) {
      int rw = flipRow ? NPix - 1 - iRow : iRow;
      for (int iCol = NPix; iCol--;) {
        int bDest = rw * NPix + (flipCol ? NPix - 1 - iCol : iCol);
        data[bDest] = src.data[iRow * NPix + iCol];
      }
    }
  }

  /// probability to find an electron in pixel ix,iy,iz
  float getValue(int iRow, int iCol) const { return data[iRow * NPix + iCol]; }
  float getValue(int iRow, int iCol, bool flipRow, bool flipCol) const
  {
    int bin = (flipRow ? NPix - 1 - iRow : iRow) * NPix + (flipCol ? NPix - 1 - iCol : iCol);
    return data[bin];
  }

  /// pointer on underlying array
  std::array<float, MatSize>* getArray() { return &data; }

  /// print values
  void print(bool flipRow = false, bool flipCol = false) const;

 private:
  std::array<float, MatSize> data;

  ClassDefNV(AlpideRespSimMat, 1);
};

/*
 * AlpideSimResponse: container for Alpide simulates parameterized response matrices
 * Based on the Miljenko Šuljić standalone code and needs as an input text matrices
 * from simulation. 
 * Provides for the electron injected to point X(columns direction),Y (rows direction) 
 * (with respect to pixel center) and Z (depth, with respect to epitaxial layer inner 
 * serface!!! i.e. touching the substrate) the probability to be collected in every 
 * of NPix*NPix pixels with reference pixel in the center. 
 */

class AlpideSimResponse
{

 private:
  int getColBin(float pos) const;
  int getRowBin(float pos) const;
  int getDepthBin(float pos) const;
  std::string composeDataName(int colBin, int rowBin);

  int mNBinCol = 0;                    /// number of bins in X(col direction)
  int mNBinRow = 0;                    /// number of bins in Y(row direction)
  int mNBinDpt = 0;                    /// number of bins in Z(sensor dept)
  int mMaxBinCol = 0;                  /// max allowed Xb (to avoid subtraction)
  int mMaxBinRow = 0;                  /// max allowed Yb (to avoid subtraction)
  float mColMax = SegmentationAlpide::PitchCol / 2.f; /// upper boundary of Col
  float mRowMax = SegmentationAlpide::PitchRow / 2.f; /// upper boundary of Row
  float mDptMin = 0.f;                 /// lower boundary of Dpt
  float mDptMax = 0.f;                 /// upper boundary of Dpt
  float mDptShift = 0.f;               /// shift of the depth center wrt 0
  float mStepInvCol = 0;               /// inverse step of the Col grid
  float mStepInvRow = 0;               /// inverse step of the Row grid
  float mStepInvDpt = 0;               /// inverse step of the Dpt grid
  std::vector<AlpideRespSimMat> mData; /// response data
  /// path to look for data file
  std::string mDataPath = "./"; //"$(O2_ROOT)/share/Detectors/ITSMFT/data/alpideResponseData/";
  std::string mGridColName = "grid_list_x.txt";             /// name of the file with grid in Col
  std::string mGridRowName = "grid_list_y.txt";             /// name of the file with grid in Row
  std::string mColRowDataFmt = "data_pixels_%.2f_%.2f.txt"; /// format to read the data for given Col,Row

 public:
  AlpideSimResponse() = default;
  ~AlpideSimResponse() = default;

  void initData(int tableNumber);

  bool getResponse(float vRow, float vCol, float cDepth, AlpideRespSimMat& dest) const;
  const AlpideRespSimMat* getResponse(float vRow, float vCol, float vDepth, bool& flipRow, bool& flipCol) const;
  const AlpideRespSimMat* getResponse(float vRow, float vCol, float vDepth, bool& flipRow, bool& flipCol, float rowMax, float colMax) const;
  static int constexpr getNPix() { return AlpideRespSimMat::getNPix(); }
  int getNBinCol() const { return mNBinCol; }
  int getNBinRow() const { return mNBinRow; }
  int getNBinDepth() const { return mNBinDpt; }
  float getColMax() const { return mColMax; }
  float getRowMax() const { return mRowMax; }
  float getDepthMin() const { return mDptMin; }
  float getDepthMax() const { return mDptMax; }
  float getDepthShift() const { return mDptShift; }
  float getStepCol() const { return mStepInvCol ? 1. / mStepInvCol : 0.f; }
  float getStepRow() const { return mStepInvRow ? 1. / mStepInvRow : 0.f; }
  float getStepDepth() const { return mStepInvDpt ? 1. / mStepInvDpt : 0.f; }
  void setDataPath(const std::string pth) { mDataPath = pth; }
  void setGridColName(const std::string nm) { mGridColName = nm; }
  void setGridRowName(const std::string nm) { mGridRowName = nm; }
  void setColRowDataFmt(const std::string nm) { mColRowDataFmt = nm; }
  const std::string& getDataPath() const { return mDataPath; }
  const std::string& getGridColName() const { return mGridColName; }
  const std::string& getGridRowName() const { return mGridRowName; }
  const std::string& getColRowDataFmt() const { return mColRowDataFmt; }
  void print() const;

  ClassDefNV(AlpideSimResponse, 1);
};

//-----------------------------------------------------
inline int AlpideSimResponse::getColBin(float pos) const
{
  /// get column bin w/o checking for over/under flow. pos MUST be >=0
  int i = pos * mStepInvCol + 0.5f;
  return i < mNBinCol ? i : mMaxBinCol;
}

//-----------------------------------------------------
inline int AlpideSimResponse::getRowBin(float pos) const
{
  /// get row bin w/o checking for over/under flow. pos MUST be >=0
  int i = pos * mStepInvRow + 0.5f;
  return i < mNBinRow ? i : mMaxBinRow;
}

//-----------------------------------------------------
inline int AlpideSimResponse::getDepthBin(float pos) const
{
  /// get depth bin w/o checking for over/under flow. pos is with respect of the beginning
  /// of epitaxial layer
  int i = (mDptMax - pos) * mStepInvDpt;
  return i < 0 ? 0 : i; // depth bin
}

} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file DigiParams.h
/// \brief Simulation parameters for the ALIPIDE chip

#ifndef ALICEO2_ITSMFT_DIGIPARAMS_H
#define ALICEO2_ITSMFT_DIGIPARAMS_H

#include <Rtypes.h>
#include <ITSMFTSimulation/AlpideSignalTrapezoid.h>
#include "ITSMFTBase/DPLAlpideParam.h"

////////////////////////////////////////////////////////////
//                                                        //
// Simulation params for Alpide chip                      //
//                                                        //
// This is a provisionary implementation, until proper    //
// microscopic simulation and its configuration will      //
// be implemented                                         //
//                                                        //
////////////////////////////////////////////////////////////

namespace o2
{
namespace itsmft
{

class AlpideSimResponse;

class DigiParams
{

  using SignalShape = o2::itsmft::AlpideSignalTrapezoid;

 public:
  DigiParams();
  ~DigiParams() = default;

  void setNoisePerPixel(float v) { mNoisePerPixel = v; }
  float getNoisePerPixel() const { return mNoisePerPixel; }

  void setContinuous(bool v) { mIsContinuous = v; }
  bool isContinuous() const { return mIsContinuous; }

  int getROFrameLengthInBC() const { return mROFrameLengthInBC; }
  void setROFrameLengthInBC(int n) { mROFrameLengthInBC = n; }

  void setROFrameLength(float ns);
  float getROFrameLength() const { return mROFrameLength; }
  float getROFrameLengthInv() const { return mROFrameLengthInv; }

  void setStrobeDelay(float ns) { mStrobeDelay = ns; }
  float getStrobeDelay() const { return mStrobeDelay; }

  void setStrobeLength(float ns) { mStrobeLength = ns; }
  float getStrobeLength() const { return mStrobeLength; }

  void setTimeOffset(double sec) { mTimeOffset = sec; }
  double getTimeOffset() const { return mTimeOffset; }

  void setChargeThreshold(int v, float frac2Account = 0.1);
  void setNSimSteps(int v);
  void setEnergyToNElectrons(float v) { mEnergyToNElectrons = v; }

  void setVbb(float v) { mVbb = v; }
  void setIBVbb(float v) { mIBVbb = v; }
  void setOBVbb(float v) { mOBVbb = v; }

  int getChargeThreshold() const { return mChargeThreshold; }
  int getMinChargeToAccount() const { return mMinChargeToAccount; }
  int getNSimSteps() const { return mNSimSteps; }
  float getNSimStepsInv() const { return mNSimStepsInv; }
  float getEnergyToNElectrons() const { return mEnergyToNElectrons; }

  float getVbb() const { return mVbb; }
  float getIBVbb() const { return mIBVbb; }
  float getOBVbb() const { return mOBVbb; }

  bool isTimeOffsetSet() const { return mTimeOffset > -infTime; }

  const o2::itsmft::AlpideSimResponse* getAlpSimResponse() const { return mAlpSimResponse; }
  void setAlpSimResponse(const o2::itsmft::AlpideSimResponse* par) { mAlpSimResponse = par; }

  const SignalShape& getSignalShape() const { return mSignalShape; }
  SignalShape& getSignalShape() { return (SignalShape&)mSignalShape; }

  void print() const;

 private:
  static constexpr double infTime = 1e99;
  bool mIsContinuous = false;        ///< flag for continuous simulation
  float mNoisePerPixel = 1.e-8;      ///< ALPIDE Noise per chip
  int mROFrameLengthInBC = 0;        ///< ROF length in BC for continuos mode
  float mROFrameLength = 0;          ///< length of RO frame in ns
  float mStrobeDelay = 0.;           ///< strobe start (in ns) wrt ROF start
  float mStrobeLength = 0;           ///< length of the strobe in ns (sig. over threshold checked in this window only)
  double mTimeOffset = -2 * infTime; ///< time offset (in seconds!) to calculate ROFrame from hit time

  int mChargeThreshold = 150;              ///< charge threshold in Nelectrons
  int mMinChargeToAccount = 15;            ///< minimum charge contribution to account
  int mNSimSteps = 7;                      ///< number of steps in response simulation
  float mEnergyToNElectrons = 1. / 3.6e-9; // conversion of eloss to Nelectrons

  float mVbb = 0.0;   ///< back bias absolute value for MFT (in Volt)
  float mIBVbb = 0.0; ///< back bias absolute value for ITS Inner Barrel (in Volt)
  float mOBVbb = 0.0; ///< back bias absolute value for ITS Outter Barrel (in Volt)

  o2::itsmft::AlpideSignalTrapezoid mSignalShape; ///< signal timeshape parameterization

  const o2::itsmft::AlpideSimResponse* mAlpSimResponse = nullptr; //!< pointer on external response

  // auxiliary precalculated parameters
  float mROFrameLengthInv = 0; ///< inverse length of RO frame in ns
  float mNSimStepsInv = 0;     ///< its inverse

  ClassDefNV(DigiParams, 2);
};
} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Digitizer.h
/// \brief Definition of the ITS digitizer
#ifndef ALICEO2_ITSMFT_DIGITIZER_H
#define ALICEO2_ITSMFT_DIGITIZER_H

#include <vector>
#include <deque>
#include <memory>

#include "Rtypes.h" // for Digitizer::Class
#include "TObject.h" // for TObject

#include "ITSMFTSimulation/ChipDigitsContainer.h"
#include "ITSMFTSimulation/AlpideSimResponse.h"
#include "ITSMFTSimulation/DigiParams.h"
#include "ITSMFTSimulation/Hit.h"
#include "ITSMFTBase/GeometryTGeo.h"
#include "DataFormatsITSMFT/Digit.h"
#include "DataFormatsITSMFT/NoiseMap.h"
#include "DataFormatsITSMFT/ROFRecord.h"
#include "CommonDataFormat/InteractionRecord.h"
#include "SimulationDataFormat/MCCompLabel.h"

namespace o2
{

namespace dataformats
{
template <typename T>
class MCTruthContainer;
}

namespace itsmft
{
class Digitizer : public TObject
{
  using ExtraDig = std::vector<PreDigitLabelRef>; ///< container for extra contributions to PreDigits

 public:
  Digitizer() = default;
  ~Digitizer() override = default;
  Digitizer(const Digitizer&) = delete;
  Digitizer& operator=(const Digitizer&) = delete;

  void setDigits(std::vector<o2::itsmft::Digit>* dig) { mDigits = dig; }
  void setMCLabels(o2::dataformats::MCTruthContainer<o2::MCCompLabel>* mclb) { mMCLabels = mclb; }
  void setROFRecords(std::vector<o2::itsmft::ROFRecord>* rec) { mROFRecords = rec; }
  o2::itsmft::DigiParams& getParams() { return (o2::itsmft::DigiParams&)mParams; }
  const o2::itsmft::DigiParams& getParams() const { return mParams; }
  void setNoiseMap(const o2::itsmft::NoiseMap* mp) { mNoiseMap = mp; }
  void setDeadChannelsMap(const o2::itsmft::NoiseMap* mp) { mDeadChanMap = mp; }

  void init();

  auto getChipResponse(int chipID);

  /// Steer conversion of hits to digits
  void process(const std::vector<Hit>* hits, int evID, int srcID);
  void setEventTime(const o2::InteractionTimeRecord& irt);
  double getEndTimeOfROFMax() const
  {
    ///< return the time corresponding to end of the last reserved ROFrame : mROFrameMax
    return mParams.getROFrameLength() * (mROFrameMax + 1) + mParams.getTimeOffset();
  }

  void setContinuous(bool v) { mParams.setContinuous(v); }
  bool isContinuous() const { return mParams.isContinuous(); }
  void fillOutputContainer(uint32_t maxFrame = 0xffffffff);

  void setDigiParams(const o2::itsmft::DigiParams& par) { mParams = par; }
  const o2::itsmft::DigiParams& getDigitParams() const { return mParams; }

  // provide the common itsmft::GeometryTGeo to access matrices and segmentation
  void setGeometry(const o2::itsmft::GeometryTGeo* gm) { mGeometry = gm; }

  uint32_t getEventROFrameMin() const { return mEventROFrameMin; }
  uint32_t getEventROFrameMax() const { return mEventROFrameMax; }
  void resetEventROFrames()
  {
    mEventROFrameMin = 0xffffffff;
    mEventROFrameMax = 0;
  }

 private:
  void processHit(const o2::itsmft::Hit& hit, uint32_t& maxFr, int evID, int srcID);
  void registerDigits(ChipDigitsContainer& chip, uint32_t roFrame, float tInROF, int nROF,
                      uint16_t row, uint16_t col, int nEle, o2::MCCompLabel& lbl);

  ExtraDig* getExtraDigBuffer(uint32_t roFrame)
  {
    if (mROFrameMin > roFrame) {
      return nullptr; // nothing to do
    }
    int ind = roFrame - mROFrameMin;
    while (ind >= int(mExtraBuff.size())) {
      mExtraBuff.emplace_back(std::make_unique<ExtraDig>());
    }
    return mExtraBuff[ind].get();
  }

  static constexpr float sec2ns = 1e9;

  o2::itsmft::DigiParams mParams; ///< digitization parameters
  o2::InteractionTimeRecord mEventTime; ///< global event time and interaction record
  o2::InteractionRecord mIRFirstSampledTF; ///< IR of the 1st sampled IR, noise-only ROFs will be inserted till this IR only
  double mCollisionTimeWrtROF;
  uint32_t mROFrameMin = 0; ///< lowest RO frame of current digits
  uint32_t mROFrameMax = 0; ///< highest RO frame of current digits
  uint32_t mNewROFrame = 0; ///< ROFrame corresponding to provided time

  uint32_t mEventROFrameMin = 0xffffffff; ///< lowest RO frame for processed events (w/o automatic noise ROFs)
  uint32_t mEventROFrameMax = 0;          ///< highest RO frame forfor processed events (w/o automatic noise ROFs)

  int mNumberOfChips = 0;
  o2::itsmft::AlpideSimResponse* mAlpSimRespMFT = nullptr;
  o2::itsmft::AlpideSimResponse* mAlpSimRespIB = nullptr;
  o2::itsmft::AlpideSimResponse* mAlpSimRespOB = nullptr;
  o2::itsmft::AlpideSimResponse mAlpSimResp[2]; // simulated response
  std::string mdataFile = "/home/abigot/alice/O2/Detectors/ITSMFT/data/alpideResponseData/";
  const o2::itsmft::GeometryTGeo* mGeometry = nullptr; ///< ITS OR MFT upgrade geometry

  std::vector<o2::itsmft::ChipDigitsContainer> mChips; ///< Array of chips digits containers
  std::deque<std::unique_ptr<ExtraDig>> mExtraBuff;    ///< burrer (per roFrame) for extra digits

  std::vector<o2::itsmft::Digit>* mDigits = nullptr;                       //! output digits
  std::vector<o2::itsmft::ROFRecord>* mROFRecords = nullptr;               //! output ROF records
  o2::dataformats::MCTruthContainer<o2::MCCompLabel>* mMCLabels = nullptr; //! output labels
  const o2::itsmft::NoiseMap* mNoiseMap = nullptr;
  const o2::itsmft::NoiseMap* mDeadChanMap = nullptr;

  ClassDefOverride(Digitizer, 2);
};
} // namespace itsmft
} // namespace o2

#endif /* ALICEO2_ITSMFT_DIGITIZER_H */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file PreDigit.h
/// \brief Definition of the digit contribution from single hit
#ifndef ALICEO2_ITSMFT_PREDIGIT_H
#define ALICEO2_ITSMFT_PREDIGIT_H

#include "SimulationDataFormat/MCCompLabel.h"

/// \file PreDigit.h
/// \brief Contribution of single hit to digit

namespace o2
{

namespace itsmft
{

// PreDigit is a contribution to the digit from a single hit which happen
// to be registered 1st in given chip row/column/roframe
// Eventual extra contributions will be registered as PreDigitExtra, pointed by
// the "next" index

// PreDigitExtra registers additional contributions to the same row/column/roframe
struct PreDigitLabelRef {
  o2::MCCompLabel label; ///< hit label
  int next = -1;         ///< eventual next contribution to the same pixel
  PreDigitLabelRef(o2::MCCompLabel lbl = 0, int nxt = -1) : label(lbl), next(nxt) {}

  ClassDefNV(PreDigitLabelRef, 1);
};

struct PreDigit {
  UShort_t row = 0;          ///< Pixel index in X
  UShort_t col = 0;          ///< Pixel index in Z
  UInt_t roFrame = 0;        ///< Readout frame
  int charge = 0.f;          ///< N electrons
  PreDigitLabelRef labelRef; ///< label and reference to the next one

  PreDigit(UInt_t rf = 0, UShort_t rw = 0, UShort_t cl = 0, int nele = 0, o2::MCCompLabel lbl = 0)
    : row(rw), col(cl), roFrame(rf), charge(nele), labelRef(lbl) {}

  ClassDefNV(PreDigit, 1);
};
} // namespace itsmft
} // namespace o2
#endif /* ALICEO2_ITSMFT_PREDIGIT_H */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

//
/// \file ChipDigitsContainer.h
/// \brief transient container for single chip digits accumulation
//

#ifndef ALICEO2_ITSMFT_CHIPDIGITSCONTAINER_
#define ALICEO2_ITSMFT_CHIPDIGITSCONTAINER_

#include "SimulationDataFormat/MCCompLabel.h"
#include "ITSMFTBase/SegmentationAlpide.h"
#include "ITSMFTSimulation/PreDigit.h"
#include "DataFormatsITSMFT/NoiseMap.h"
#include <map>
#include <vector>

namespace o2
{
namespace itsmft
{
class DigiParams;

/// @class ChipDigitsContainer
/// @brief Container for similated points connected to a given chip

class ChipDigitsContainer
{
 public:
  /// Default constructor
  ChipDigitsContainer(UShort_t idx = 0) : mChipIndex(idx){};

  /// Destructor
  ~ChipDigitsContainer() = default;

  std::map<ULong64_t, o2::itsmft::PreDigit>& getPreDigits() { return mDigits; }
  bool isEmpty() const { return mDigits.empty(); }
  void setNoiseMap(const o2::itsmft::NoiseMap* mp) { mNoiseMap = mp; }
  void setDeadChanMap(const o2::itsmft::NoiseMap* mp) { mDeadChanMap = mp; }
  void setChipIndex(UShort_t ind) { mChipIndex = ind; }
  UShort_t getChipIndex() const { return mChipIndex; }

  o2::itsmft::PreDigit* findDigit(ULong64_t key);
  void addDigit(ULong64_t key, UInt_t roframe, UShort_t row, UShort_t col, int charge, o2::MCCompLabel lbl);
  void addNoise(UInt_t rofMin, UInt_t rofMax, const o2::itsmft::DigiParams* params, int maxRows = o2::itsmft::SegmentationAlpide::NRows, int maxCols = o2::itsmft::SegmentationAlpide::NCols);

  /// Get global ordering key made of readout frame, column and row
  static ULong64_t getOrderingKey(UInt_t roframe, UShort_t row, UShort_t col)
  {
    return (static_cast<ULong64_t>(roframe) << (8 * sizeof(UInt_t))) + (col << (8 * sizeof(Short_t))) + row;
  }

  /// Get ROFrame from the ordering key
  static UInt_t key2ROFrame(ULong64_t key)
  {
    return static_cast<UInt_t>(key >> (8 * sizeof(UInt_t)));
  }

  bool isDisabled() const { return mDisabled; }
  void disable(bool v) { mDisabled = v; }

 protected:
  UShort_t mChipIndex = 0;                           ///< chip index
  bool mDisabled = false;
  const o2::itsmft::NoiseMap* mNoiseMap = nullptr;
  const o2::itsmft::NoiseMap* mDeadChanMap = nullptr;
  std::map<ULong64_t, o2::itsmft::PreDigit> mDigits; ///< Map of fired pixels, possibly in multiple frames

  ClassDefNV(ChipDigitsContainer, 1);
};

//_______________________________________________________________________
inline o2::itsmft::PreDigit* ChipDigitsContainer::findDigit(ULong64_t key)
{
  // finds the digit corresponding to global key
  auto digitentry = mDigits.find(key);
  return digitentry != mDigits.end() ? &(digitentry->second) : nullptr;
}

//_______________________________________________________________________
inline void ChipDigitsContainer::addDigit(ULong64_t key, UInt_t roframe, UShort_t row, UShort_t col,
                                          int charge, o2::MCCompLabel lbl)
{
  mDigits.emplace(std::make_pair(key, o2::itsmft::PreDigit(roframe, row, col, charge, lbl)));
}
} // namespace itsmft
} // namespace o2

#endif /* defined(ALICEO2_ITSMFT_CHIPCONTAINER_) */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file AlpideChip.h
/// \brief Creates an ALPIDE chip in simulation
/// \author Mario.Sitta@cern.ch - 24 oct 2017

#ifndef ALICEO2_ITSMFT_ALPIDECHIP_H_
#define ALICEO2_ITSMFT_ALPIDECHIP_H_

#include <TGeoManager.h> // for gGeoManager
#include "Rtypes.h"      // for Int_t, Double_t, Bool_t, UInt_t, etc

class TGeoVolume;
class TGeoManager;

namespace o2
{

namespace itsmft
{

/// AlpideChip class creates a TGeoVolume representing the Alpide Chip
/// Can be used by both ITS and MFT

class AlpideChip
{
 public:
  AlpideChip() = default;
  ~AlpideChip() = default;

  /// Creates the AlpideChip
  /// Returns the chip as a TGeoVolume
  /// \param yc Y chip half lengths
  /// \param ys sensor half thickness
  /// \param chipName sensName default volume names
  /// \param dummy if true creates a dummy air volume (for material budget studies)
  /// \param mgr The GeoManager (used only to get the proper material)
  static TGeoVolume* createChip(Double_t yc, Double_t ys,
                                char const* chipName = "AlpideChip", char const* sensName = "AlpideSensor",
                                Bool_t dummy = kFALSE, const TGeoManager* mgr = gGeoManager);

  static void createMaterials(Int_t id, Int_t fieldType, Float_t maxField);

  static constexpr Double_t sMetalLayerThick = 15.0 * 1.0E-4; ///< Metal layer thickness (um)

  ClassDefNV(AlpideChip, 0); // AlpideChip geometry
};

} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file AlpideSignalTrapezoid.h
/// \brief Simple class describing ALPIDE signal time shape

#ifndef ALICEO2_ITSMFT_ALPIDESIGNALTRAPEZOID_H
#define ALICEO2_ITSMFT_ALPIDESIGNALTRAPEZOID_H

#include <Rtypes.h>

namespace o2
{
namespace itsmft
{

class AlpideSignalTrapezoid
{
 public:
  AlpideSignalTrapezoid(float duration = 7500., float rise = 1100., float qrise0 = 450.);
  AlpideSignalTrapezoid(const AlpideSignalTrapezoid&) = default;
  AlpideSignalTrapezoid& operator=(const AlpideSignalTrapezoid&) = default;
  ~AlpideSignalTrapezoid() = default;

  float getCollectedCharge(float totalNEle, float tMin, float tMax) const;

  float getDuration() const { return mDuration; }
  float getMaxRiseTime() const { return mMaxRiseTime; }
  float getChargeRise0() const { return mChargeRise0; }
  float getExtraDuration(float riseTime) const { return riseTime * 0.5; }

  // This method queried by digitizer to decided in home many ROFrames the hit can contribute
  // In case we describe extra duration at small charges, it should be accounted here
  float getMaxDuration() const { return getDuration(); }

  void setParameters(float dur, float rise, float qrise0)
  {
    init(dur, rise, qrise0);
  }
  void setDuration(float d) { init(d, mMaxRiseTime, mChargeRise0); }
  void setMaxRiseTime(float r) { init(mDuration, r, mChargeRise0); }
  void setChargeRise0(float q) { init(mDuration, mMaxRiseTime, q); }

  void print() const;

 private:
  void init(float dur, float rise, float qrise0);

  float mDuration = 7500.f;           ///< total duration in ns for signal above mChargeRise0
  float mMaxRiseTime = 1100.f;        ///< rise time in ns for smallest charge
  float mChargeRise0 = 450.f;         ///< charge at which rise time is ~0
  float mChargeRise0Inv = 1. / 450.f; ///< its inverse

  ClassDefNV(AlpideSignalTrapezoid, 1);
};

inline float AlpideSignalTrapezoid::getCollectedCharge(float totalNEle, float tMin, float tMax) const
{
  // calculate max number of electrons seen by the strobe from tMin to tMax (in nanosec),
  // provided that the total injected charge was totalNEle electrons

  // estimate rise time for given charge
  float riseTime = totalNEle > mChargeRise0 ? 0. : mMaxRiseTime * (1.f - totalNEle * mChargeRise0Inv);

  if (tMax >= riseTime && tMin <= mDuration) { // strobe overlaps flat top
    return totalNEle;
  }
  if (tMax > 0. && tMin < riseTime) { // strobe overlaps with rise
    return totalNEle * tMax / riseTime;
  }
  return 0;
}
} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file ClusterShape.h
/// \brief Cluster shape class for the ALPIDE response simulation

#ifndef ALICEO2_ITSMFT_CLUSTERSHAPE_H_
#define ALICEO2_ITSMFT_CLUSTERSHAPE_H_

///////////////////////////////////////////////////////////////////
//                                                               //
// Class to describe the cluster shape in the ITSU simulation    //
// Author: Davide Pagano                                         //
///////////////////////////////////////////////////////////////////

#include <TObject.h>
#include <sstream>
#include <vector>
#include <algorithm>

namespace o2
{
namespace itsmft
{

class ClusterShape : public TObject
{

 public:
  ClusterShape();
  ClusterShape(UInt_t, UInt_t);
  ClusterShape(UInt_t, UInt_t, const std::vector<UInt_t>&);
  ~ClusterShape() override;

  // Set the number of rows
  inline void SetNRows(UInt_t Nrows) { mNrows = Nrows; }

  // Set the number of cols
  inline void SetNCols(UInt_t Ncols) { mNcols = Ncols; }

  // Add a pixel position to the shape [0, r*c[
  inline void AddShapeValue(UInt_t pos) { mShape.push_back(pos); }

  // Check whether the shape has the
  Bool_t IsValidShape();

  // Return an unique ID based on the cluster size and shape
  Long64_t GetShapeID() const;

  // Get the number of rows of the cluster
  inline UInt_t GetNRows() const { return mNrows; }

  inline void SetCenter(UInt_t r, UInt_t c)
  {
    mCenterR = r;
    mCenterC = c;
  }

  // Get the center of rows of the cluster
  inline UInt_t GetCenterR() const { return mCenterR; }

  // Get the center of cols of the cluster
  inline UInt_t GetCenterC() const { return mCenterC; }

  // Get the index of the center (0-based)
  inline UInt_t GetCenterIndex() const
  {
    return RowColToIndex(mCenterR, mCenterC);
  }

  // Get the number of cols of the cluster
  inline UInt_t GetNCols() const { return mNcols; }

  // Get the number of fired pixels of the cluster
  inline UInt_t GetNFiredPixels() const { return mShape.size(); }

  // Get the position of the pixel with the specified index
  inline UInt_t GetValue(UInt_t index) const { return mShape[index]; }

  // Get the shape of the cluster
  inline void GetShape(std::vector<UInt_t>& v) const { v = mShape; }

  // Check whether the cluster has the specified pixel on
  Bool_t HasElement(UInt_t) const;

  // Return a string with the positions of the fired pixels in the cluster
  inline std::string ShapeSting() const
  {
    return ShapeSting(mShape);
  }

  // r and c are 0-based. The returned index is 0-based as well
  inline UInt_t RowColToIndex(UInt_t r, UInt_t c) const
  {
    return r * mNcols + c;
  }

  // Static function to get a string with the positions of the fired pixels
  // in the passed shape vector
  static std::string ShapeSting(const std::vector<UInt_t>& shape)
  {
    std::stringstream out;
    for (UInt_t i = 0; i < shape.size(); ++i) {
      out << shape[i];
      if (i < shape.size() - 1) {
        out << " ";
      }
    }
    return out.str();
  }

  friend std::ostream& operator<<(std::ostream& out, const ClusterShape& v)
  {
    UInt_t index = 0;
    for (Int_t r = -1; r < (Int_t)v.mNrows; ++r) {
      for (UInt_t c = 0; c < v.mNcols; ++c) {
        if (r == -1) {
          if (c == 0) {
            out << "  ";
          }
          out << c;
          if (c < v.mNcols - 1) {
            out << " ";
          }
        } else {
          if (c == 0) {
            out << r << " ";
          }
          index = r * v.mNcols + c;
          if (std::find(begin(v.mShape), end(v.mShape), index) != end(v.mShape)) {
            out << "X";
          } else {
            out << " ";
          }
          if (c < v.mNcols - 1) {
            out << " ";
          }
        }
      }
      out << std::endl;
    }
    return out;
  }

 private:
  UInt_t ComputeCenter(UInt_t);

  UInt_t mNrows;
  UInt_t mNcols;
  UInt_t mCenterR;
  UInt_t mCenterC;
  std::vector<UInt_t> mShape;

  ClassDefOverride(ClusterShape, 1);
};
} // namespace itsmft
} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_ITSMFTDPLDIGITIZERPARAM_H_
#define ALICEO2_ITSMFTDPLDIGITIZERPARAM_H_

#include "DetectorsCommonDataFormats/DetID.h"
#include "CommonUtils/ConfigurableParam.h"
#include "CommonUtils/ConfigurableParamHelper.h"
#include <string_view>

namespace o2
{
namespace itsmft
{
template <int N>
struct DPLDigitizerParam : public o2::conf::ConfigurableParamHelper<DPLDigitizerParam<N>> {
  static_assert(N == o2::detectors::DetID::ITS || N == o2::detectors::DetID::MFT, "only DetID::ITS orDetID:: MFT are allowed");

  static constexpr std::string_view getParamName()
  {
    return N == o2::detectors::DetID::ITS ? ParamName[0] : ParamName[1];
  }

  bool continuous = true;          ///< flag for continuous simulation
  float noisePerPixel = 1.e-7;     ///< ALPIDE Noise per channel
  float strobeFlatTop = 7500.;     ///< strobe shape flat top
  float strobeMaxRiseTime = 1100.; ///< strobe max rise time
  float strobeQRiseTime0 = 450.;   ///< q @ which strobe rise time is 0

  double timeOffset = 0.;                 ///< time offset (in seconds!) to calculate ROFrame from hit time
  int chargeThreshold = 150;              ///< charge threshold in Nelectrons
  int minChargeToAccount = 15;            ///< minimum charge contribution to account
  int nSimSteps = 7;                      ///< number of steps in response simulation
  float energyToNElectrons = 1. / 3.6e-9; // conversion of eloss to Nelectrons

  float Vbb = 0.0;   ///< back bias absolute value for MFT (in Volt)
  float IBVbb = 0.0; ///< back bias absolute value for ITS Inner Barrel (in Volt)
  float OBVbb = 0.0; ///< back bias absolute value for ITS Outter Barrel (in Volt)

  std::string noiseFilePath{}; ///< optional noise masks file path. FIXME to be removed once switch to CCDBFetcher

  // boilerplate stuff + make principal key
  O2ParamDef(DPLDigitizerParam, getParamName().data());

 private:
  static constexpr std::string_view ParamName[2] = {"ITSDigitizerParam", "MFTDigitizerParam"};
};

template <int N>
DPLDigitizerParam<N> DPLDigitizerParam<N>::sInstance;

} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file MC2RawEncoder.h
/// \brief Definition of the ITS/MFT Alpide pixel MC->raw converter

#ifndef ALICEO2_ITSMFT_MC2RAWENCODER_H_
#define ALICEO2_ITSMFT_MC2RAWENCODER_H_

#include <gsl/gsl>                               // for guideline support library; array_view
#include "ITSMFTReconstruction/RawPixelReader.h" // TODO : must be modified
#include "ITSMFTReconstruction/AlpideCoder.h"
#include "ITSMFTReconstruction/ChipMappingITS.h"
#include "ITSMFTReconstruction/ChipMappingMFT.h"
#include "ITSMFTReconstruction/RUDecodeData.h"
#include "DetectorsRaw/RawFileWriter.h"
#include "DetectorsRaw/RDHUtils.h"
#include <unordered_map>

namespace o2
{

namespace itsmft
{

template <class Mapping>
class MC2RawEncoder
{
  using Coder = o2::itsmft::AlpideCoder;

 public:
  MC2RawEncoder()
  {
    mRUEntry.fill(-1);
  }

  ~MC2RawEncoder()
  {
    mWriter.close();
  }

  void digits2raw(gsl::span<const Digit> digits, const o2::InteractionRecord& bcData);
  void finalize();
  void init();

  RUDecodeData& getCreateRUDecode(int ruSW);

  RUDecodeData* getRUDecode(int ruSW) { return mRUEntry[ruSW] < 0 ? nullptr : &mRUDecodeVec[mRUEntry[ruSW]]; }

  void setVerbosity(int v)
  {
    mVerbosity = v;
    mWriter.setVerbosity(v);
  }
  int getVerbosity() const { return mVerbosity; }

  Mapping& getMapping() { return mMAP; }

  void setMinMaxRUSW(uint8_t ruMin, uint8_t ruMax)
  {
    mRUSWMax = (ruMax < uint8_t(mMAP.getNRUs())) ? ruMax : mMAP.getNRUs() - 1;
    mRUSWMin = ruMin < mRUSWMax ? ruMin : mRUSWMax;
  }

  int getRUSWMin() const { return mRUSWMin; }
  int getRUSWMax() const { return mRUSWMax; }

  void setContinuousReadout(bool v) { mWriter.setContinuousReadout(v); }
  bool isContinuousReadout() const { return mWriter.isContinuousReadout(); }

  o2::raw::RawFileWriter& getWriter() { return mWriter; }

  std::string getDefaultSinkName() const { return mDefaultSinkName; }
  void setDefaultSinkName(const std::string& nm)
  {
    if (!nm.empty()) {
      mDefaultSinkName = nm;
    }
  }

  int carryOverMethod(const o2::header::RDHAny* rdh, const gsl::span<char> data, const char* ptr, int maxSize, int splitID,
                      std::vector<char>& trailer, std::vector<char>& header) const;

  void newRDHMethod(const header::RDHAny* rdh, bool empty, std::vector<char>& toAdd) const;

  // create new gbt link
  int addGBTLink()
  {
    int sz = mGBTLinks.size();
    mGBTLinks.emplace_back();
    return sz;
  }

  // get the link pointer
  GBTLink* getGBTLink(int i) { return i < 0 ? nullptr : &mGBTLinks[i]; }
  const GBTLink* getGBTLink(int i) const { return i < 0 ? nullptr : &mGBTLinks[i]; }

 private:
  void convertEmptyChips(int fromChip, int uptoChip, RUDecodeData& ru);
  void convertChip(ChipPixelData& chipData, RUDecodeData& ru);
  void fillGBTLinks(RUDecodeData& ru);

  enum RoMode_t { NotSet,
                  Continuous,
                  Triggered };
  o2::InteractionRecord mCurrIR;               // currently processed int record
  o2::raw::RawFileWriter mWriter{Mapping::getOrigin()}; // set origin of data
  std::string mDefaultSinkName = "dataSink.raw";
  Mapping mMAP;
  Coder mCoder;
  int mVerbosity = 0;                                        //! verbosity level
  uint8_t mRUSWMin = 0;                                      ///< min RU (SW) to convert
  uint8_t mRUSWMax = 0xff;                                   ///< max RU (SW) to convert
  int mNRUs = 0;                                             /// total number of RUs seen
  int mNLinks = 0;                                           /// total number of GBT links seen
  std::array<RUDecodeData, Mapping::getNRUs()> mRUDecodeVec; /// decoding buffers for all active RUs
  std::array<int, Mapping::getNRUs()> mRUEntry;              /// entry of the RU with given SW ID in the mRUDecodeVec
  std::vector<GBTLink> mGBTLinks;
  std::unordered_map<uint16_t, const GBTLink*> mFEEId2Link;
  std::unordered_map<uint16_t, GBTDataHeader> mFEEId2GBTHeader;
  ClassDefNV(MC2RawEncoder, 1);
};

// template specifications
using MC2RawEncoderITS = MC2RawEncoder<ChipMappingITS>;
using MC2RawEncoderMFT = MC2RawEncoder<ChipMappingMFT>;

} // namespace itsmft
} // namespace o2

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from input_line_8:1:
In file included from /home/abigot/alice/O2/Detectors/ITSMFT/common/data/alpideResponseData/alpideResponse.C:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTSimulation/AlpideSimResponse.h:72:3: warning: ambiguous expansion of macro 'ClassDefNV' [-Wambiguous-macro]
  ClassDefNV(AlpideRespSimMat, 1);
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/Rtypes.h:333:9: note: expanding this definition of 'ClassDefNV'
#define ClassDefNV(name,id)                          \
        ^
G__O2ITSMFTBase dictionary payload:389:9: note: other definition of 'ClassDefNV'
#define ClassDefNV(name, id) \
        ^
In file included from input_line_8:1:
In file included from /home/abigot/alice/O2/Detectors/ITSMFT/common/data/alpideResponseData/alpideResponse.C:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTSimulation/AlpideSimResponse.h:145:3: warning: ambiguous expansion of macro 'ClassDefNV' [-Wambiguous-macro]
  ClassDefNV(AlpideSimResponse, 1);
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/Rtypes.h:333:9: note: expanding this definition of 'ClassDefNV'
#define ClassDefNV(name,id)                          \
        ^
G__O2ITSMFTBase dictionary payload:389:9: note: other definition of 'ClassDefNV'
#define ClassDefNV(name, id) \
        ^
In file included from G__O2SimulationDataFormat dictionary payload:92:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/SimulationDataFormat/TrackReference.h:223:22: error: use of overloaded operator '<<' is ambiguous (with operand types 'basic_ostream<char, std::char_traits<char> >' and 'const Int_t' (aka 'const int'))
  os << "TrackRef (" << a.mTrackNumber << "): X[" << a.mX << " , " << a.mY << " , " << a.mZ << "]"
  ~~~~~~~~~~~~~~~~~~ ^  ~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:517:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:511:5: note: candidate function [with _CharT = char, _Traits = std::char_traits<char>]
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:523:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:528:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class o2::MCTrackT with content:

#line 1 "G__O2SimulationDataFormat dictionary payload"

#ifndef ZDC_FASTSIM_ONNX
  #define ZDC_FASTSIM_ONNX 1
#endif
#ifndef ENABLE_UPGRADES
  #define ENABLE_UPGRADES 1
#endif
#ifndef FMT_LOCALE
  #define FMT_LOCALE 1
#endif
#ifndef FMT_SHARED
  #define FMT_SHARED 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef FAIRMQ_HAS_STD_FILESYSTEM
  #define FAIRMQ_HAS_STD_FILESYSTEM 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_CONTAINER_DYN_LINK
  #define BOOST_CONTAINER_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_PROGRAM_OPTIONS_DYN_LINK
  #define BOOST_PROGRAM_OPTIONS_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_FILESYSTEM_DYN_LINK
  #define BOOST_FILESYSTEM_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_REGEX_DYN_LINK
  #define BOOST_REGEX_DYN_LINK 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_IOSTREAMS_DYN_LINK
  #define BOOST_IOSTREAMS_DYN_LINK 1
#endif
#ifndef DPL_ENABLE_BACKTRACE
  #define DPL_ENABLE_BACKTRACE 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_SERIALIZATION_DYN_LINK
  #define BOOST_SERIALIZATION_DYN_LINK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Stack.h
/// \brief Definition of the Stack class
/// \author M. Al-Turany - June 2014

#ifndef ALICEO2_DATA_STACK_H_
#define ALICEO2_DATA_STACK_H_

#include "DetectorsCommonDataFormats/DetID.h"
#include "FairGenericStack.h"
#include "SimulationDataFormat/MCTrack.h"
#include "SimulationDataFormat/TrackReference.h"
#include "SimulationDataFormat/MCEventStats.h"
#include "SimulationDataFormat/ParticleStatus.h"
#include "Rtypes.h"
#include "TParticle.h"

#include <map>
#include <memory>
#include <stack>
#include <utility>
#include <functional>

class TClonesArray;
class TRefArray;

namespace o2
{
namespace base
{
class Detector;
}

namespace data
{
/// This class handles the particle stack for the transport simulation.
/// For the stack FILO functunality, it uses the STL stack. To store
/// the tracks during transport, a TParticle array is used.
/// At the end of the event, tracks satisfying the filter criteria
/// are copied to a MCTrack array, which is stored in the output.
///
/// The filtering criteria for the output tracks are:
/// - primary tracks are stored in any case.
/// - secondary tracks are stored if they have a minimal number of
///   hits (sum of all detectors) and a minimal energy, or are the
///
/// The storage of secondaries can be switched off.
/// The storage of all mothers can be switched off.
/// By default, the minimal number of hits is 1 and the energy cut is 0.
class Stack : public FairGenericStack
{
 public:
  /// Default constructor
  /// \param size Estimated track number
  Stack(Int_t size = 100);

  /// Default destructor
  ~Stack() override;

  /// Add a TParticle to the stack.
  /// Declared in TVirtualMCStack
  /// \param toBeDone Flag for tracking
  /// \param parentID Index of mother particle
  /// \param pdgCode Particle type (PDG encoding)
  /// \param px,py,pz Momentum components at start vertex [GeV]
  /// \param e Total energy at start vertex [GeV]
  /// \param vx,vy,vz Coordinates of start vertex [cm]
  /// \param time Start time of track [s]
  /// \param polx,poly,polz Polarisation vector
  /// \param proc Production mechanism (VMC encoding)
  /// \param ntr Track number (filled by the stack)
  /// \param weight Particle weight
  /// \param is Generation status code (whatever that means)
  void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode, Double_t px, Double_t py, Double_t pz, Double_t e,
                 Double_t vx, Double_t vy, Double_t vz, Double_t time, Double_t polx, Double_t poly, Double_t polz,
                 TMCProcess proc, Int_t& ntr, Double_t weight, Int_t is) override;

  void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode, Double_t px, Double_t py, Double_t pz, Double_t e,
                 Double_t vx, Double_t vy, Double_t vz, Double_t time, Double_t polx, Double_t poly, Double_t polz,
                 TMCProcess proc, Int_t& ntr, Double_t weight, Int_t is, Int_t secondParentId) override;

  void PushTrack(Int_t toBeDone, Int_t parentID, Int_t pdgCode, Double_t px, Double_t py, Double_t pz, Double_t e,
                 Double_t vx, Double_t vy, Double_t vz, Double_t time, Double_t polx, Double_t poly, Double_t polz,
                 TMCProcess proc, Int_t& ntr, Double_t weight, Int_t is, Int_t secondParentId, Int_t daughter1Id, Int_t daughter2Id,
                 TMCProcess proc2);

  // similar function taking a particle
  void PushTrack(Int_t toBeDone, TParticle&);

  /// Get next particle for tracking from the stack.
  /// Declared in TVirtualMCStack
  /// Returns a pointer to the TParticle of the track
  /// \param iTrack index of popped track (return)
  TParticle* PopNextTrack(Int_t& iTrack) override;

  /// Get primary particle by index for tracking from stack
  /// Declared in TVirtualMCStack
  /// Returns a pointer to the TParticle of the track
  /// \param iPrim index of primary particle
  TParticle* PopPrimaryForTracking(Int_t iPrim) override;

  /// Set the current track number
  /// Declared in TVirtualMCStack
  /// \param iTrack track number
  void SetCurrentTrack(Int_t iTrack) override;

  /// Get total number of tracks
  /// Declared in TVirtualMCStack
  Int_t GetNtrack() const override { return mNumberOfEntriesInParticles; }
  /// Get number of primary tracks
  /// Declared in TVirtualMCStack
  Int_t GetNprimary() const override { return mNumberOfPrimaryParticles; }
  /// Get the current track's particle
  /// Declared in TVirtualMCStack
  TParticle* GetCurrentTrack() const override
  {
    // the const cast is necessary ... the interface should have been `const TParticle* GetCurrentParticle() const`
    return const_cast<TParticle*>(&mCurrentParticle);
  }
  /// Get the number of the current track
  /// Declared in TVirtualMCStack
  Int_t GetCurrentTrackNumber() const override { return mIndexOfCurrentTrack; }
  /// Get the track number of the parent of the current track
  /// Declared in TVirtualMCStack
  Int_t GetCurrentParentTrackNumber() const override;

  /// Returns the production process of the current track
  TMCProcess GetProdProcessOfCurrentTrack() const;

  /// Fill the MCTrack output array, applying filter criteria
  void FillTrackArray() override;

  /// Update the track index in the MCTracks and data produced by detectors
  void UpdateTrackIndex(TRefArray* detArray = nullptr) override;

  /// Finish primary
  void FinishPrimary() override;

  /// Resets arrays and stack and deletes particles and tracks
  void Reset() override;

  /// Register the MCTrack array to the Root Manager
  void Register() override;

  /// Output to screen
  /// \param iVerbose: 0=events summary, 1=track info

  virtual void Print(Int_t iVerbose = 0) const;

  /// Output to screen (derived from base class)
  /// \param option: 0=events summary, non0=track info
  void Print(Option_t* option = nullptr) const override;

  void ReorderKine(std::vector<MCTrack>& particles, std::vector<int>& reOrderedIndices);
  /// Modifiers
  void StoreSecondaries(Bool_t choice = kTRUE) { mStoreSecondaries = choice; }
  void pruneKinematics(bool choice = true) { mPruneKinematics = choice; }
  void setMinHits(Int_t min) { mMinHits = min; }
  void SetEnergyCut(Double_t eMin) { mEnergyCut = eMin; }
  void StoreMothers(Bool_t choice = kTRUE) { mStoreMothers = choice; }
  /// Increment number of hits for the current track in a given detector
  /// \param iDet  Detector unique identifier
  void addHit(int iDet);

  TClonesArray* GetListOfParticles() override;

  std::vector<MCTrack> const* const getMCTracks() const { return mTracks; }

  /// Clone for worker (used in MT mode only)
  FairGenericStack* CloneStack() const override;

  // methods concerning track references
  void addTrackReference(const o2::TrackReference& p);

  // get primaries
  const std::vector<TParticle>& getPrimaries() const { return mPrimaryParticles; }

  // initialize Stack from external vector containing primaries

  void initFromPrimaries(std::vector<TParticle>& primaries)
  {
    Reset();
    for (auto p : primaries) {
      Int_t doTrack = 0;
      if (p.TestBit(ParticleStatus::kToBeDone)) {
        doTrack = 1;
      }
      PushTrack(doTrack, p);
    }
    mNumberOfPrimaryParticles = primaries.size();
    mNumberOfEntriesInParticles = mNumberOfPrimaryParticles;
  }

  void setExternalMode(bool m) { mIsExternalMode = m; }

  /// Allow to query the **direct** mother track ID of an arbitrary trackID managed by stack
  int getMotherTrackId(int /*trackid*/) const;

  /// query if a track is a direct **or** indirect daughter of a parentID
  /// if trackid is same as parentid it returns true
  bool isTrackDaughterOf(int /*trackid*/, int /*parentid*/) const;

  bool isCurrentTrackDaughterOf(int parentid) const;

  // returns the index of the currently transported primary
  int getCurrentPrimaryIndex() const;

  // Fill container with all parent ids for current track
  // The resulting ids will be in strictly monotonously decreasing order
  void fillParentIDs(std::vector<int>& ids) const;

  /// set MCEventStats (for current event)
  /// used by MCApplication to inject here so that
  /// stack can set some information
  void setMCEventStats(o2::dataformats::MCEventStats* header);

  /// update values in the current event header
  void updateEventStats();

  typedef std::function<bool(const TParticle& p, const std::vector<TParticle>& particles)> TransportFcn;

 private:
  /// STL stack (FILO) used to handle the TParticles for tracking
  /// stack entries refer to
  std::stack<TParticle> mStack; //!

  /// Array of TParticles (contains all TParticles put into or created
  /// by the transport)
  std::vector<o2::MCTrack> mParticles;       //!
  std::vector<int> mTransportedIDs;          //! prim + sec trackIDs transported for "current" primary
  std::vector<int> mIndexOfPrimaries;        //! index of primaries in mParticles
  std::vector<int> mTrackIDtoParticlesEntry; //! an O(1) mapping of trackID to the entry of mParticles
  // the current TParticle object
  TParticle mCurrentParticle;
  TParticle mCurrentParticle0;

  // keep primary particles in its original form
  // (mainly for the PopPrimaryParticleInterface
  std::vector<TParticle> mPrimaryParticles;

  /// vector of reducded tracks written to the output
  std::vector<o2::MCTrack>* mTracks;

  /// STL map from particle index to persistent track index
  std::map<Int_t, Int_t> mIndexMap; //!

  /// cache active O2 detectors
  std::vector<o2::base::Detector*> mActiveDetectors; //!

  /// Some indices and counters
  Int_t mIndexOfCurrentTrack;          //! Global index of current track
  Int_t mIndexOfCurrentPrimary;        //! Global index of current primry
  Int_t mNumberOfPrimaryParticles;     //! Number of primary particles
  Int_t mNumberOfEntriesInParticles;   //! Number of entries in mParticles
  Int_t mNumberOfEntriesInTracks;      //! Number of entries in mTracks
  Int_t mNumberOfPrimariesforTracking; //! Number of primaries for tracking (ie without shirtlived particles and partons)
  Int_t mNumberOfPrimariesPopped;      //! Number of primaries popped from stack
  Int_t mIndex;                        //! Used for merging

  /// Variables defining the criteria for output selection
  Bool_t mStoreMothers;
  Bool_t mStoreSecondaries;
  bool mPruneKinematics = false; // whether or not we filter the output kinematics
  Int_t mMinHits;
  Int_t mHitCounter = 0; //! counts hits communicated via addHit
  Double32_t mEnergyCut;

  // variables for the cleanup / filtering procedure
  Int_t mCleanupCounter = 0;   //!
  Int_t mCleanupThreshold = 1; //! a cleanup is initiated every mCleanupThreshold primaries
  Int_t mPrimariesDone = 0;    //!
  Int_t mTracksDone = 0;       //! number of tracks already done

  bool mIsG4Like = false; //! flag indicating if the stack is used in a manner done by Geant4

  bool mIsExternalMode = false; // is stack an external factory or directly used inside simulation?

  TransportFcn mTransportPrimary = [](const TParticle& p, const std::vector<TParticle>& particles) { return false; }; //! a function to inhibit the tracking of a particle

  // storage for track references
  std::vector<o2::TrackReference>* mTrackRefs = nullptr; //!

  /// a pointer to the current MCEventStats object
  o2::dataformats::MCEventStats* mMCEventStats = nullptr; //!

  /// Mark tracks for output using selection criteria
  /// returns true if all available tracks are selected
  /// returns false if some tracks are discarded
  bool selectTracks();

  bool isPrimary(const MCTrack& part);
  bool isFromPrimaryDecayChain(const MCTrack& part);
  bool isFromPrimaryPairProduction(const MCTrack& part);

  bool keepPhysics(const MCTrack& part);

  Stack(const Stack&);

  Stack& operator=(const Stack&);

  /// Increment number of hits for an arbitrary track in a given detector
  /// \param iDet    Detector unique identifier
  /// \param iTrack  Track number
  void addHit(int iDet, Int_t iTrack);

  void handleTransportPrimary(TParticle& p);

  ClassDefOverride(Stack, 1);
};

inline void Stack::addTrackReference(const o2::TrackReference& ref)
{
  if (mIndexOfCurrentTrack >= mNumberOfPrimaryParticles) {
    Int_t iTrack = mTrackIDtoParticlesEntry[mIndexOfCurrentTrack];
    auto& part = mParticles[iTrack];
    part.setStore(true);
  }
  mTrackRefs->push_back(ref);
}

inline int Stack::getCurrentPrimaryIndex() const { return mPrimaryParticles.size() - 1 - mPrimariesDone; }

inline int Stack::getMotherTrackId(int trackid) const
{
  const auto entryinParticles = mTrackIDtoParticlesEntry[trackid];
  return mParticles[entryinParticles].getMotherTrackId();
}

inline bool Stack::isCurrentTrackDaughterOf(int parentid) const
{
  // if parentid is current primary the answer is certainly yes
  if (parentid == getCurrentPrimaryIndex()) {
    return true;
  }

  // otherwise ...
  return isTrackDaughterOf(mIndexOfCurrentTrack, parentid);
}

inline void Stack::setMCEventStats(o2::dataformats::MCEventStats* header)
{
  mMCEventStats = header;
}

inline TMCProcess Stack::GetProdProcessOfCurrentTrack() const
{
  return (TMCProcess)o2::data::Stack::GetCurrentTrack()->GetUniqueID();
}

} // namespace data
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_SIMDATAFORMAT_STACKPARAM_H_
#define ALICEO2_SIMDATAFORMAT_STACKPARAM_H_

#include "CommonUtils/ConfigurableParam.h"
#include "CommonUtils/ConfigurableParamHelper.h"

namespace o2
{
namespace sim
{

// configuration parameters for simulation Stack
struct StackParam : public o2::conf::ConfigurableParamHelper<StackParam> {
  bool storeSecondaries = true;
  bool pruneKine = true;
  std::string transportPrimary = "all";
  std::string transportPrimaryFileName = "";
  std::string transportPrimaryFuncName = "";
  bool transportPrimaryInvert = false;

  // boilerplate stuff + make principal key "Stack"
  O2ParamDef(StackParam, "Stack");
};

} // namespace sim
} // namespace o2

#endif // ALICEO2_SIMDATAFORMAT_STACKPARAM_H_
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file MCTrack.h
/// \brief Definition of the MCTrack class
/// \author M. Al-Turany - June 2014; S. Wenzel - October 2017

#ifndef ALICEO2_DATA_MCTRACK_H_
#define ALICEO2_DATA_MCTRACK_H_

#include "SimulationDataFormat/ParticleStatus.h"
#include "DetectorsCommonDataFormats/DetID.h"
#include "Rtypes.h"
#include "TDatabasePDG.h"
#include "TLorentzVector.h"
#include "TMCProcess.h"
#include "TMath.h"
#include "TParticle.h"
#include "TParticlePDG.h"
#include "TVector3.h"

namespace o2
{
/// Data class for storing Monte Carlo tracks processed by the Stack.
/// An MCTrack can be a primary track put into the simulation or a
/// secondary one produced by the transport through decay or interaction.
/// This is a light weight particle class that is saved to disk
/// instead of saving the TParticle class. It is also used for filtering the stack
template <class _T>
class MCTrackT
{
 public:
  ///  Default constructor
  MCTrackT();

  ///  Standard constructor
  MCTrackT(Int_t pdgCode, Int_t motherID, Int_t secondMotherID, Int_t firstDaughterID, Int_t lastDaughterID,
           Double_t px, Double_t py, Double_t pz, Double_t x, Double_t y, Double_t z, Double_t t,
           Int_t nPoints);

  ///  Copy constructor
  MCTrackT(const MCTrackT& track) = default;

  ///  Constructor from TParticle
  MCTrackT(const TParticle& particle);

  ///  Destructor
  ~MCTrackT() = default;

  ///  Output to screen
  void Print(Int_t iTrack = 0) const;

  ///  Accessors
  Int_t GetPdgCode() const { return mPdgCode; }
  Int_t getMotherTrackId() const { return mMotherTrackId; }
  Int_t getSecondMotherTrackId() const { return mSecondMotherTrackId; }
  bool isPrimary() const { return getProcess() == TMCProcess::kPPrimary; }
  bool isSecondary() const { return !isPrimary(); }
  Int_t getFirstDaughterTrackId() const { return mFirstDaughterTrackId; }
  Int_t getLastDaughterTrackId() const { return mLastDaughterTrackId; }
  Double_t GetStartVertexMomentumX() const { return mStartVertexMomentumX; }
  Double_t GetStartVertexMomentumY() const { return mStartVertexMomentumY; }
  Double_t GetStartVertexMomentumZ() const { return mStartVertexMomentumZ; }
  Double_t GetStartVertexCoordinatesX() const { return mStartVertexCoordinatesX; }
  Double_t GetStartVertexCoordinatesY() const { return mStartVertexCoordinatesY; }
  Double_t GetStartVertexCoordinatesZ() const { return mStartVertexCoordinatesZ; }
  Double_t GetStartVertexCoordinatesT() const { return mStartVertexCoordinatesT; }
  Double_t GetMass() const;

  Double_t GetEnergy() const;

  // Alternative accessors with TParticle like shorter names
  Double_t Px() const { return mStartVertexMomentumX; }
  Double_t Py() const { return mStartVertexMomentumY; }
  Double_t Pz() const { return mStartVertexMomentumZ; }
  Double_t Vx() const { return mStartVertexCoordinatesX; }
  Double_t Vy() const { return mStartVertexCoordinatesY; }
  Double_t Vz() const { return mStartVertexCoordinatesZ; }
  Double_t T() const { return mStartVertexCoordinatesT; }

  Double_t GetPt() const
  {
    double mx(mStartVertexMomentumX);
    double my(mStartVertexMomentumY);
    return std::sqrt(mx * mx + my * my);
  }

  Double_t GetP() const
  {
    double mx(mStartVertexMomentumX);
    double my(mStartVertexMomentumY);
    double mz(mStartVertexMomentumZ);
    return std::sqrt(mx * mx + my * my + mz * mz);
  }

  Double_t GetPhi() const
  {
    double mx(mStartVertexMomentumX);
    double my(mStartVertexMomentumY);
    return (TMath::Pi() + TMath::ATan2(-mx, -my));
  }

  Double_t GetEta() const
  {
    double_t pmom = GetP();
    double mz(mStartVertexMomentumZ);
    if (pmom != TMath::Abs(mz)) {
      return 0.5 * std::log((pmom + mz) / (pmom - mz));
    } else {
      return 1.e30;
    }
  }

  Double_t GetTheta() const
  {
    double mz(mStartVertexMomentumZ);
    return (mz == 0) ? TMath::PiOver2() : TMath::ACos(mz / GetP());
  }

  Double_t GetRapidity() const;

  void GetMomentum(TVector3& momentum);

  void Get4Momentum(TLorentzVector& momentum);

  void GetStartVertex(TVector3& vertex);

  /// Accessors to the hit mask
  Int_t getHitMask() const { return ((PropEncoding)mProp).hitmask; }
  void setHitMask(Int_t m) { ((PropEncoding)mProp).hitmask = m; }
  ///  Modifiers
  void SetMotherTrackId(Int_t id) { mMotherTrackId = id; }
  void SetSecondMotherTrackId(Int_t id) { mSecondMotherTrackId = id; }
  void SetFirstDaughterTrackId(Int_t id) { mFirstDaughterTrackId = id; }
  void SetLastDaughterTrackId(Int_t id) { mLastDaughterTrackId = id; }
  // set bit indicating that this track
  // left a hit in detector with id iDet
  void setHit(Int_t iDet)
  {
    assert(0 <= iDet && iDet < o2::detectors::DetID::nDetectors);
    auto prop = ((PropEncoding)mProp);
    prop.hitmask |= 1 << iDet;
    mProp = prop.i;
  }

  // did detector iDet see this track?
  bool leftTrace(Int_t iDet) const { return (((PropEncoding)mProp).hitmask & (1 << iDet)) > 0; }
  // determine how many detectors "saw" this track
  int getNumDet() const
  {
    int count = 0;
    for (auto i = o2::detectors::DetID::First; i < o2::detectors::DetID::nDetectors; ++i) {
      if (leftTrace(i)) {
        count++;
      }
    }
    return count;
  }

  // keep track if this track will be persistet
  // using last bit in mHitMask to do so
  void setStore(bool f)
  {
    auto prop = ((PropEncoding)mProp);
    prop.storage = f;
    mProp = prop.i;
  }
  bool getStore() const { return ((PropEncoding)mProp).storage; }
  /// determine if this track has hits
  bool hasHits() const { return ((PropEncoding)mProp).hitmask != 0; }
  /// set process property
  void setProcess(int proc)
  {
    auto prop = ((PropEncoding)mProp);
    prop.process = proc;
    mProp = prop.i;
  }

  /// get the production process (id) of this track
  int getProcess() const { return ((PropEncoding)mProp).process; }

  /// get generator status code
  int getStatusCode() const { return mStatusCode; }

  void setToBeDone(bool f)
  {
    auto prop = ((PropEncoding)mProp);
    prop.toBeDone = f;
    mProp = prop.i;
  }
  bool getToBeDone() const { return ((PropEncoding)mProp).toBeDone; }

  void setInhibited(bool f)
  {
    auto prop = ((PropEncoding)mProp);
    prop.inhibited = f;
    mProp = prop.i;
  }
  bool getInhibited() const { return ((PropEncoding)mProp).inhibited; }

  bool isTransported() const { return getToBeDone() && !getInhibited(); };

  /// get the string representation of the production process
  const char* getProdProcessAsString() const;

 private:
  /// Momentum components at start vertex [GeV]
  _T mStartVertexMomentumX, mStartVertexMomentumY, mStartVertexMomentumZ;

  /// Coordinates of start vertex [cm, ns]
  _T mStartVertexCoordinatesX, mStartVertexCoordinatesY, mStartVertexCoordinatesZ, mStartVertexCoordinatesT;

  ///  PDG particle code
  Int_t mPdgCode;

  ///  Index of mother tracks
  Int_t mMotherTrackId = -1;
  Int_t mSecondMotherTrackId = -1;

  Int_t mFirstDaughterTrackId = -1;
  Int_t mLastDaughterTrackId = -1;
  // hitmask stored as an int
  // if bit i is set it means that this track left a trace in detector i
  // we should have sizeof(int) < o2::base::DetId::nDetectors
  Int_t mProp = 0;

  // internal structure to allow convenient manipulation
  // of properties as bits on an int
  union PropEncoding {
    PropEncoding(int a) : i(a) {}
    int i;
    struct {
      int storage : 1;  // encoding whether to store this track to the output
      unsigned int process : 6; // encoding process that created this track (enough to store TMCProcess from ROOT)
      int hitmask : 21; // encoding hits per detector
      int reserved1 : 1; // bit reserved for possible future purposes
      int reserved2 : 1; // bit reserved for possible future purposes
      int inhibited : 1; // whether tracking of this was inhibited
      int toBeDone : 1; // whether this (still) needs tracking --> we might more complete information to cover full ParticleStatus space
    };
  };

  // Additional status codes for MC generator information.
  // NOTE: This additional memory cost might be reduced by using bits elsewhere
  // such as part of mProp (process) or mPDG
  Int_t mStatusCode = 0;

  ClassDefNV(MCTrackT, 5);
};

template <typename T>
inline Double_t MCTrackT<T>::GetEnergy() const
{
  const auto mass = GetMass();
  return std::sqrt(mass * mass + mStartVertexMomentumX * mStartVertexMomentumX +
                   mStartVertexMomentumY * mStartVertexMomentumY + mStartVertexMomentumZ * mStartVertexMomentumZ);
}

template <typename T>
inline void MCTrackT<T>::GetMomentum(TVector3& momentum)
{
  momentum.SetXYZ(mStartVertexMomentumX, mStartVertexMomentumY, mStartVertexMomentumZ);
}

template <typename T>
inline void MCTrackT<T>::Get4Momentum(TLorentzVector& momentum)
{
  momentum.SetXYZT(mStartVertexMomentumX, mStartVertexMomentumY, mStartVertexMomentumZ, GetEnergy());
}

template <typename T>
inline void MCTrackT<T>::GetStartVertex(TVector3& vertex)
{
  vertex.SetXYZ(mStartVertexCoordinatesX, mStartVertexCoordinatesY, mStartVertexCoordinatesZ);
}

template <typename T>
inline MCTrackT<T>::MCTrackT()
  : mPdgCode(0),
    mMotherTrackId(-1),
    mSecondMotherTrackId(-1),
    mFirstDaughterTrackId(-1),
    mLastDaughterTrackId(-1),
    mStartVertexMomentumX(0.),
    mStartVertexMomentumY(0.),
    mStartVertexMomentumZ(0.),
    mStartVertexCoordinatesX(0.),
    mStartVertexCoordinatesY(0.),
    mStartVertexCoordinatesZ(0.),
    mStartVertexCoordinatesT(0.),
    mProp(0)
{
}

template <typename T>
inline MCTrackT<T>::MCTrackT(Int_t pdgCode, Int_t motherId, Int_t secondMotherId, Int_t firstDaughterId, Int_t lastDaughterId,
                             Double_t px, Double_t py, Double_t pz, Double_t x,
                             Double_t y, Double_t z, Double_t t, Int_t mask)
  : mPdgCode(pdgCode),
    mMotherTrackId(motherId),
    mSecondMotherTrackId(secondMotherId),
    mFirstDaughterTrackId(firstDaughterId),
    mLastDaughterTrackId(lastDaughterId),
    mStartVertexMomentumX(px),
    mStartVertexMomentumY(py),
    mStartVertexMomentumZ(pz),
    mStartVertexCoordinatesX(x),
    mStartVertexCoordinatesY(y),
    mStartVertexCoordinatesZ(z),
    mStartVertexCoordinatesT(t),
    mProp(mask)
{
}

template <typename T>
inline MCTrackT<T>::MCTrackT(const TParticle& part)
  : mPdgCode(part.GetPdgCode()),
    mMotherTrackId(part.GetMother(0)),
    mSecondMotherTrackId(part.GetMother(1)),
    mFirstDaughterTrackId(part.GetFirstDaughter()),
    mLastDaughterTrackId(part.GetLastDaughter()),
    mStartVertexMomentumX(part.Px()),
    mStartVertexMomentumY(part.Py()),
    mStartVertexMomentumZ(part.Pz()),
    mStartVertexCoordinatesX(part.Vx()),
    mStartVertexCoordinatesY(part.Vy()),
    mStartVertexCoordinatesZ(part.Vz()),
    mStartVertexCoordinatesT(part.T() * 1e09),
    mProp(0),
    mStatusCode(0)
{
  // our convention is to communicate the process as (part) of the unique ID
  setProcess(part.GetUniqueID());
  // extract storage flag
  setStore(part.TestBit(ParticleStatus::kKeep));
  // extract toBeDone flag
  setToBeDone(part.TestBit(ParticleStatus::kToBeDone));
  // extract inhibited flag
  if (part.TestBit(ParticleStatus::kInhibited)) {
    setToBeDone(true); // if inhibited, it had to be done: restore flag
    setInhibited(true);
  }
  // set MC generator status code only for primaries
  mStatusCode = part.TestBit(ParticleStatus::kPrimary) ? part.GetStatusCode() : -1;
}

template <typename T>
inline void MCTrackT<T>::Print(Int_t trackId) const
{
  // LOG(debug) << "Track " << trackId << ", mother : " << mMotherTrackId << ", Type " << mPdgCode << ", momentum ("
  //           << mStartVertexMomentumX << ", " << mStartVertexMomentumY << ", " << mStartVertexMomentumZ << ") GeV"
  //          ;
}

template <typename T>
inline Double_t MCTrackT<T>::GetMass() const
{
  if (TDatabasePDG::Instance()) {
    TParticlePDG* particle = TDatabasePDG::Instance()->GetParticle(mPdgCode);
    if (particle) {
      return particle->Mass();
    } else {
      return 0.;
    }
  }
  return 0.;
}

template <typename T>
inline Double_t MCTrackT<T>::GetRapidity() const
{
  const auto e = GetEnergy();
  Double_t y =
    0.5 * std::log((e + static_cast<double>(mStartVertexMomentumZ)) / (e - static_cast<double>(mStartVertexMomentumZ)));
  return y;
}

template <typename T>
inline const char* MCTrackT<T>::getProdProcessAsString() const
{
  auto procID = getProcess();
  if (procID >= 0) {
    return TMCProcessName[procID];
  } else {
    return TMCProcessName[TMCProcess::kPNoProcess];
  }
}

using MCTrack = MCTrackT<float>;
} // end namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_BASE_HIT_H
#define ALICEO2_BASE_HIT_H
#include "MathUtils/Cartesian.h"

namespace o2
{

// Mother class of all hit classes for AliceO2
// just defines what is absolutely necessary to have
// as common interface
// at the moment ony GetTrackID() used by Stack.h
// eventually we could add some interfaces to retrieve
// the coordinates as floats or something
class BaseHit
{
 public:
  BaseHit() = default;
  BaseHit(int id) : mTrackID{id} {}
  int GetTrackID() const { return mTrackID; }
  void SetTrackID(int id) { mTrackID = id; }

 private:
  int mTrackID = 0; // track_id
  ClassDefNV(BaseHit, 1);
};

// a set of configurable classes to define basic hit types
// these are meant to be an alternative to FairMCPoint
// which always includes the momentum and is purely based on double values

// Generic class to keep position, time and hit value
// T is basic type for position,
// E is basic type for time,
// V is basic type for hit value.
template <typename T, typename E, typename V = float>
class BasicXYZVHit : public BaseHit
{
  math_utils::Point3D<T> mPos; // cartesian position of Hit
  E mTime;                     // time of flight
  V mHitValue;                 // hit value
  short mDetectorID;           // the detector/sensor id

 public:
  BasicXYZVHit() = default; // for ROOT IO

  // constructor
  BasicXYZVHit(T x, T y, T z, E time, V val, int trackid, short did)
    : mPos(x, y, z), mTime(time), mHitValue(val), BaseHit(trackid), mDetectorID(did)
  {
  }

  // getting the cartesian coordinates
  T GetX() const { return mPos.X(); }
  T GetY() const { return mPos.Y(); }
  T GetZ() const { return mPos.Z(); }
  math_utils::Point3D<T> GetPos() const { return mPos; }
  // getting hit value
  V GetHitValue() const { return mHitValue; }
  // getting the time
  E GetTime() const { return mTime; }
  // get detector + track information
  short GetDetectorID() const { return mDetectorID; }

  // modifiers
  void SetTime(E time) { mTime = time; }
  void SetHitValue(V val) { mHitValue = val; }
  void SetDetectorID(short detID) { mDetectorID = detID; }
  void SetX(T x) { mPos.SetX(x); }
  void SetY(T y) { mPos.SetY(y); }
  void SetZ(T z) { mPos.SetZ(z); }
  void SetXYZ(T x, T y, T z)
  {
    SetX(x);
    SetY(y);
    SetZ(z);
  }
  void SetPos(math_utils::Point3D<T> const& p) { mPos = p; }

  ClassDefNV(BasicXYZVHit, 1);
};

// Class for a hit containing energy loss as hit value
// T is basic type for position,
// E is basic type for time (float as default),
// V is basic type for hit value (float as default).
template <typename T, typename E = float, typename V = float>
class BasicXYZEHit : public BasicXYZVHit<T, E, V>
{
 public:
  using BasicXYZVHit<T, E, V>::BasicXYZVHit;

  V GetEnergyLoss() const { return BasicXYZVHit<T, E, V>::GetHitValue(); }
  void SetEnergyLoss(V val) { BasicXYZVHit<T, E, V>::SetHitValue(val); }

  ClassDefNV(BasicXYZEHit, 1);
};

// Class for a hit containing charge as hit value
// T is basic type for position,
// E is basic type for time (float as default),
// V is basic type for hit value (int as default).
template <typename T, typename E = float, typename V = int>
class BasicXYZQHit : public BasicXYZVHit<T, E, V>
{
 public:
  using BasicXYZVHit<T, E, V>::BasicXYZVHit;

  V GetCharge() const { return BasicXYZVHit<T, E, V>::GetHitValue(); }
  void SetCharge(V val) { BasicXYZVHit<T, E, V>::SetHitValue(val); }

  ClassDefNV(BasicXYZQHit, 1);
};

} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file MCTruthContainer.h
/// \brief Definition of a container to keep Monte Carlo truth external to simulation objects
/// \author Sandro Wenzel - June 2017

#ifndef ALICEO2_DATAFORMATS_MCTRUTH_H_
#define ALICEO2_DATAFORMATS_MCTRUTH_H_

#include "GPUCommonRtypes.h" // to have the ClassDef macros
#include <cstdint>           // uint8_t etc
#include <cassert>
#include <stdexcept>
#include <gsl/span> // for guideline support library span
#include <type_traits>
#include <cstring> // memmove, memcpy
#include <memory>
#include <vector>

// type traits are needed for the compile time consistency check
// maybe to be moved out of Framework first
//#include "Framework/TypeTraits.h"

namespace o2
{
class MCCompLabel;
namespace dataformats
{

/// @struct MCTruthHeaderElement
/// @brief Simple struct having information about truth elements for particular indices:
/// how many associations we have and where they start in the storage
struct MCTruthHeaderElement {
  MCTruthHeaderElement() = default; // for ROOT IO

  MCTruthHeaderElement(uint32_t i) : index(i) {}
  uint32_t index = (uint32_t)-1; // the index into the actual MC track storage (-1 if invalid)
  ClassDefNV(MCTruthHeaderElement, 1);
};

/// @class MCTruthContainer
/// @brief A container to hold and manage MC truth information/labels.
///
/// The actual MCtruth type is a generic template type and can be supplied by the user
/// It is meant to manage associations from one "dataobject" identified by an index into an array
/// to multiple TruthElements. Each "dataobject" is identified by a sequential index. Truth elements
/// belonging to one object are always in contingous sequence in the truth element storage. Since
/// multiple truth elements can be associated with one object, the header array stores the start
/// of the associated truth element sequence.
///
/// Since the class contains two subsequent vectors, it is not POD even if the TruthElement is
/// POD. ROOT serialization is rather inefficient and in addition has a large memory footprint
/// if the container has lots of (>1000000) elements. between 3 and 4x more than the actual
/// size is allocated. If the two vectors are flattend to a raw vector before streaming, the
/// serialization works without memory overhead. The deflate/inflate methods are called from
/// a custom streamer, storing the vectors in the raw buffer and vice versa, each of the methods
/// emptying the source data.
///
/// TODO:
/// - add move assignment from a source vector, by that passing an object which has access to
///   different underlying memory resources, until that, the pmr::MemoryResource has been
///   removed again
/// - add interface to access header and truth elements directly from the raw buffer, by that
///   inflation can be postponed until new elements are added, with the effect that inflation
///   can be avoided in most cases
///
/// Note:
/// The two original vector members could be transient, however reading serialized version 1
/// objects does not work correctly. In a different approach, the two vectors have been removed
/// completely with an efficient interface to the binary buffer, but the read pragma was not able
/// to access the member offset from the StreamerInfo.
template <typename TruthElement>
class MCTruthContainer
{
 private:
  // for the moment we require the truth element to be messageable in order to simply flatten the object
  // if it turnes out that other types are required this needs to be extended and method flatten nees to
  // be conditionally added
  // TODO: activate this check
  //static_assert(o2::framework::is_messageable<TruthElement>::value, "truth element type must be messageable");

  std::vector<MCTruthHeaderElement> mHeaderArray; // the header structure array serves as an index into the actual storage
  std::vector<TruthElement> mTruthArray;          // the buffer containing the actual truth information
  /// buffer used only for streaming the to above vectors in a flat structure
  /// TODO: use polymorphic allocator so that it can work on an underlying custom memory resource,
  /// e.g. directly on the memory of the incoming message.
  std::vector<char> mStreamerData; // buffer used for streaming a flat raw buffer

  size_t getSize(uint32_t dataindex) const
  {
    // calculate size / number of labels from a difference in pointed indices
    const auto size = (dataindex < getIndexedSize() - 1)
                        ? getMCTruthHeader(dataindex + 1).index - getMCTruthHeader(dataindex).index
                        : getNElements() - getMCTruthHeader(dataindex).index;
    return size;
  }

 public:
  // constructor
  MCTruthContainer() = default;
  // destructor
  ~MCTruthContainer() = default;
  // copy constructor
  MCTruthContainer(const MCTruthContainer& other) = default;
  // move constructor
  MCTruthContainer(MCTruthContainer&& other) = default;
  // construct from raw data
  MCTruthContainer(std::vector<MCTruthHeaderElement>& header, std::vector<TruthElement>& truthArray)
  {
    setFrom(header, truthArray);
  }
  // assignment operator
  MCTruthContainer& operator=(const MCTruthContainer& other) = default;
  // move assignment operator
  MCTruthContainer& operator=(MCTruthContainer&& other) = default;

  using self_type = MCTruthContainer<TruthElement>;
  struct FlatHeader {
    uint8_t version = 1;
    uint8_t sizeofHeaderElement = sizeof(MCTruthHeaderElement);
    uint8_t sizeofTruthElement = sizeof(TruthElement);
    uint8_t reserved = 0;
    uint32_t nofHeaderElements;
    uint32_t nofTruthElements;
  };

  // access
  MCTruthHeaderElement const& getMCTruthHeader(uint32_t dataindex) const { return mHeaderArray[dataindex]; }
  // access the element directly (can be encapsulated better away)... needs proper element index
  // which can be obtained from the MCTruthHeader startposition and size
  TruthElement const& getElement(uint32_t elementindex) const { return mTruthArray[elementindex]; }
  // return the number of original data indexed here
  size_t getIndexedSize() const { return mHeaderArray.size(); }
  // return the number of elements managed in this container
  size_t getNElements() const { return mTruthArray.size(); }
  // return unterlaying vector of elements
  const std::vector<TruthElement>& getTruthArray() const
  {
    return mTruthArray;
  }

  // get individual "view" container for a given data index
  // the caller can do modifications on this view (such as sorting)
  gsl::span<TruthElement> getLabels(uint32_t dataindex)
  {
    if (dataindex >= getIndexedSize()) {
      return gsl::span<TruthElement>();
    }
    return gsl::span<TruthElement>(&mTruthArray[getMCTruthHeader(dataindex).index], getSize(dataindex));
  }

  // get individual const "view" container for a given data index
  // the caller can't do modifications on this view
  gsl::span<const TruthElement> getLabels(uint32_t dataindex) const
  {
    if (dataindex >= getIndexedSize()) {
      return gsl::span<const TruthElement>();
    }
    return gsl::span<const TruthElement>(&mTruthArray[getMCTruthHeader(dataindex).index], getSize(dataindex));
  }

  void clear()
  {
    mHeaderArray.clear();
    mTruthArray.clear();
  }

  // clear and force freeing the memory
  void clear_andfreememory()
  {
    clear();
    // this forces the desctructor being called on existing buffers
    mHeaderArray = std::vector<MCTruthHeaderElement>();
    mTruthArray = std::vector<TruthElement>();
    mStreamerData = std::vector<char>();
  }

  // add element for a particular dataindex
  // at the moment only strictly consecutive modes are supported
  void addElement(uint32_t dataindex, TruthElement const& element)
  {
    if (dataindex < mHeaderArray.size()) {
      // look if we have something for this dataindex already
      // must currently be the last one
      if (dataindex != (mHeaderArray.size() - 1)) {
        throw std::runtime_error("MCTruthContainer: unsupported code path");
      }
    } else {
      // assert(dataindex == mHeaderArray.size());

      // add empty holes
      int holes = dataindex - mHeaderArray.size();
      assert(holes >= 0);
      for (int i = 0; i < holes; ++i) {
        mHeaderArray.emplace_back(mTruthArray.size());
      }
      // add a new one
      mHeaderArray.emplace_back(mTruthArray.size());
    }
    mTruthArray.emplace_back(element);
  }

  // convenience interface to add multiple labels at once
  // can use elements of any assignable type or sub-type
  template <typename CompatibleLabel>
  void addElements(uint32_t dataindex, gsl::span<CompatibleLabel> elements)
  {
    static_assert(std::is_same<TruthElement, CompatibleLabel>::value ||
                    std::is_assignable<TruthElement, CompatibleLabel>::value ||
                    std::is_base_of<TruthElement, CompatibleLabel>::value,
                  "Need to add compatible labels");
    for (auto& e : elements) {
      addElement(dataindex, e);
    }
  }

  template <typename CompatibleLabel>
  void addElements(uint32_t dataindex, const std::vector<CompatibleLabel>& v)
  {
    using B = typename std::remove_const<CompatibleLabel>::type;
    auto s = gsl::span<CompatibleLabel>(const_cast<B*>(&v[0]), v.size());
    addElements(dataindex, s);
  }

  // Add element at last position or for a previous index
  // (at random access position).
  // This might be a slow process since data has to be moved internally
  // so this function should be used with care.
  void addElementRandomAccess(uint32_t dataindex, TruthElement const& element)
  {
    if (dataindex >= mHeaderArray.size()) {
      // a new dataindex -> push element at back

      // we still forbid to leave holes
      assert(dataindex == mHeaderArray.size());

      mHeaderArray.resize(dataindex + 1);
      mHeaderArray[dataindex] = mTruthArray.size();
      mTruthArray.emplace_back(element);
    } else {
      // if appending at end use fast function
      if (dataindex == mHeaderArray.size() - 1) {
        addElement(dataindex, element);
        return;
      }

      // existing dataindex
      // have to:
      // a) move data;
      // b) insert new element;
      // c) adjust indices of all headers right to this
      auto currentindex = mHeaderArray[dataindex].index;
      auto lastindex = currentindex + getSize(dataindex);
      assert(currentindex >= 0);

      // resize truth array
      mTruthArray.resize(mTruthArray.size() + 1);
      // move data (have to do from right to left)
      for (int i = mTruthArray.size() - 1; i > lastindex; --i) {
        mTruthArray[i] = mTruthArray[i - 1];
      }
      // insert new element
      mTruthArray[lastindex] = element;

      // fix headers
      for (uint32_t i = dataindex + 1; i < mHeaderArray.size(); ++i) {
        auto oldindex = mHeaderArray[i].index;
        mHeaderArray[i].index = (oldindex != (uint32_t)-1) ? oldindex + 1 : oldindex;
      }
    }
  }

  // Set container directly from header + truthArray.
  void setFrom(std::vector<MCTruthHeaderElement>& header, std::vector<TruthElement>& truthArray)
  {
    mHeaderArray = std::move(header);
    mTruthArray = std::move(truthArray);
  }

  // merge another container to the back of this one
  void mergeAtBack(MCTruthContainer<TruthElement> const& other)
  {
    const auto oldtruthsize = mTruthArray.size();
    const auto oldheadersize = mHeaderArray.size();

    // copy from other
    std::copy(other.mHeaderArray.begin(), other.mHeaderArray.end(), std::back_inserter(mHeaderArray));
    std::copy(other.mTruthArray.begin(), other.mTruthArray.end(), std::back_inserter(mTruthArray));

    // adjust information of newly attached part
    for (uint32_t i = oldheadersize; i < mHeaderArray.size(); ++i) {
      mHeaderArray[i].index += oldtruthsize;
    }
  }

  // merge part of another container ("n" entries starting from "from") to the back of this one
  void mergeAtBack(MCTruthContainer<TruthElement> const& other, size_t from, size_t n)
  {
    const auto oldtruthsize = mTruthArray.size();
    const auto oldheadersize = mHeaderArray.size();
    auto endIdx = from + n;
    assert(endIdx <= other.mHeaderArray.size());
    const auto* headBeg = &other.mHeaderArray[from];
    const auto* headEnd = headBeg + n;
    const auto* trtArrBeg = &other.mTruthArray[other.getMCTruthHeader(from).index];
    const auto* trtArrEnd = (endIdx == other.mHeaderArray.size()) ? (&other.mTruthArray.back()) + 1 : &other.mTruthArray[other.getMCTruthHeader(endIdx).index];

    // copy from other
    std::copy(headBeg, headEnd, std::back_inserter(mHeaderArray));
    std::copy(trtArrBeg, trtArrEnd, std::back_inserter(mTruthArray));
    long offset = long(oldtruthsize) - other.getMCTruthHeader(from).index;
    // adjust information of newly attached part
    for (uint32_t i = oldheadersize; i < mHeaderArray.size(); ++i) {
      mHeaderArray[i].index += offset;
    }
  }

  /// Flatten the internal arrays to the provided container
  /// Copies the content of the two vectors of PODs to a contiguous container.
  /// The flattened data starts with a specific header @ref FlatHeader describing
  /// size and content of the two vectors within the raw buffer.
  template <typename ContainerType>
  size_t flatten_to(ContainerType& container) const
  {
    size_t bufferSize = sizeof(FlatHeader) + sizeof(MCTruthHeaderElement) * mHeaderArray.size() + sizeof(TruthElement) * mTruthArray.size();
    container.resize((bufferSize / sizeof(typename ContainerType::value_type)) + ((bufferSize % sizeof(typename ContainerType::value_type)) > 0 ? 1 : 0));
    char* target = reinterpret_cast<char*>(container.data());
    auto& flatheader = *reinterpret_cast<FlatHeader*>(target);
    target += sizeof(FlatHeader);
    flatheader.version = 1;
    flatheader.sizeofHeaderElement = sizeof(MCTruthHeaderElement);
    flatheader.sizeofTruthElement = sizeof(TruthElement);
    flatheader.reserved = 0;
    flatheader.nofHeaderElements = mHeaderArray.size();
    flatheader.nofTruthElements = mTruthArray.size();
    size_t copySize = flatheader.sizeofHeaderElement * flatheader.nofHeaderElements;
    memcpy(target, mHeaderArray.data(), copySize);
    target += copySize;
    copySize = flatheader.sizeofTruthElement * flatheader.nofTruthElements;
    memcpy(target, mTruthArray.data(), copySize);
    return bufferSize;
  }

  /// Resore internal vectors from a raw buffer
  /// The two vectors are resized according to the information in the \a FlatHeader
  /// struct at the beginning of the buffer. Data is copied to the vectors.
  void restore_from(const char* buffer, size_t bufferSize)
  {
    if (buffer == nullptr || bufferSize < sizeof(FlatHeader)) {
      return;
    }
    auto* source = buffer;
    auto& flatheader = *reinterpret_cast<FlatHeader const*>(source);
    source += sizeof(FlatHeader);
    if (bufferSize < sizeof(FlatHeader) + flatheader.sizeofHeaderElement * flatheader.nofHeaderElements + flatheader.sizeofTruthElement * flatheader.nofTruthElements) {
      throw std::runtime_error("inconsistent buffer size: too small");
      return;
    }
    if (flatheader.sizeofHeaderElement != sizeof(MCTruthHeaderElement) || flatheader.sizeofTruthElement != sizeof(TruthElement)) {
      // not yet handled
      throw std::runtime_error("member element sizes don't match");
    }
    // TODO: with a spectator memory ressource the vectors can be built directly
    // over the original buffer, there is the implementation for a memory ressource
    // working on a FairMQ message, here we would need two memory resources over
    // the two ranges of the input buffer
    // for now doing a copy
    mHeaderArray.resize(flatheader.nofHeaderElements);
    mTruthArray.resize(flatheader.nofTruthElements);
    size_t copySize = flatheader.sizeofHeaderElement * flatheader.nofHeaderElements;
    memcpy(mHeaderArray.data(), source, copySize);
    source += copySize;
    copySize = flatheader.sizeofTruthElement * flatheader.nofTruthElements;
    memcpy(mTruthArray.data(), source, copySize);
  }

  /// Print some info
  template <typename Stream>
  void print(Stream& stream)
  {
    stream << "MCTruthContainer index = " << getIndexedSize() << " for " << getNElements() << " elements(s), flat buffer size " << mStreamerData.size() << "\n";
  }

  /// Inflate the object from the internal buffer
  /// The class has a specific member to store flattened data. Due to some limitations in ROOT
  /// it is more efficient to first flatten the objects to a raw buffer and empty the two vectors
  /// before serialization. This function restores the vectors from the internal raw buffer.
  /// Called from the custom streamer.
  void inflate()
  {
    if (mHeaderArray.size() > 0) {
      mStreamerData.clear();
      return;
    }
    restore_from(mStreamerData.data(), mStreamerData.size());
    mStreamerData.clear();
  }

  /// Deflate the object to the internal buffer
  /// The class has a specific member to store flattened data. Due to some limitations in ROOT
  /// it is more efficient to first flatten the objects to a raw buffer and empty the two vectors
  /// before serialization. This function stores the vectors to the internal raw buffer.
  /// Called from the custom streamer.
  void deflate()
  {
    if (mStreamerData.size() > 0) {
      clear();
      return;
    }
    mStreamerData.clear();
    flatten_to(mStreamerData);
    clear();
  }

  ClassDefNV(MCTruthContainer, 2);
}; // end class

using MCLabelContainer = o2::dataformats::MCTruthContainer<o2::MCCompLabel>;

} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file ConstMCTruthContainer.h
/// \brief A const (ready only) version of MCTruthContainer
/// \author Sandro Wenzel - August 2020

#ifndef O2_CONSTMCTRUTHCONTAINER_H
#define O2_CONSTMCTRUTHCONTAINER_H

#include <SimulationDataFormat/MCTruthContainer.h>
#ifndef GPUCA_STANDALONE
#include <Framework/Traits.h>
#endif

namespace o2
{
namespace dataformats
{

/// @class ConstMCTruthContainer
/// @brief A read-only version of MCTruthContainer allowing for storage optimisation
///
/// This provides access functionality to MCTruthContainer with optimized linear storage
/// so that the data can easily be shared in memory or sent over network.
/// This container needs to be initialized by calling "flatten_to" from an existing
/// MCTruthContainer
template <typename TruthElement>
class ConstMCTruthContainer : public std::vector<char>
{
 public:
  // (unfortunately we need these constructors for DPL)
  using std::vector<char>::vector;
  ConstMCTruthContainer() = default;

  // const data access
  // get individual const "view" container for a given data index
  // the caller can't do modifications on this view
  MCTruthHeaderElement const& getMCTruthHeader(uint32_t dataindex) const
  {
    return getHeaderStart()[dataindex];
  }

  gsl::span<const TruthElement> getLabels(uint32_t dataindex) const
  {
    if (dataindex >= getIndexedSize()) {
      return gsl::span<const TruthElement>();
    }
    const auto start = getMCTruthHeader(dataindex).index;
    const auto labelsptr = getLabelStart();
    return gsl::span<const TruthElement>(&labelsptr[start], getSize(dataindex));
  }

  // return the number of original data indexed here
  size_t getIndexedSize() const { return size() >= sizeof(FlatHeader) ? getHeader().nofHeaderElements : 0; }

  // return the number of labels managed in this container
  size_t getNElements() const { return size() >= sizeof(FlatHeader) ? getHeader().nofTruthElements : 0; }

 private:
  using FlatHeader = typename MCTruthContainer<TruthElement>::FlatHeader;

  size_t getSize(uint32_t dataindex) const
  {
    // calculate size / number of labels from a difference in pointed indices
    const auto size = (dataindex < getIndexedSize() - 1)
                        ? getMCTruthHeader(dataindex + 1).index - getMCTruthHeader(dataindex).index
                        : getNElements() - getMCTruthHeader(dataindex).index;
    return size;
  }

  /// Restore internal vectors from a raw buffer
  /// The two vectors are resized according to the information in the \a FlatHeader
  /// struct at the beginning of the buffer. Data is copied to the vectors.
  TruthElement const* getLabelStart() const
  {
    auto* source = &(*this)[0];
    auto flatheader = getHeader();
    source += sizeof(FlatHeader);
    const size_t headerSize = flatheader.sizeofHeaderElement * flatheader.nofHeaderElements;
    source += headerSize;
    return (TruthElement const*)source;
  }

  FlatHeader const& getHeader() const
  {
    const auto* source = &(*this)[0];
    const auto& flatheader = *reinterpret_cast<FlatHeader const*>(source);
    return flatheader;
  }

  MCTruthHeaderElement const* getHeaderStart() const
  {
    auto* source = &(*this)[0];
    source += sizeof(FlatHeader);
    return (MCTruthHeaderElement const*)source;
  }
};
} // namespace dataformats
} // namespace o2

// This is done so that DPL treats this container as a vector.
// In particular in enables
// a) --> snapshot without ROOT dictionary (as a flat buffer)
// b) --> requesting the resource in shared mem using make<T>
#ifndef GPUCA_STANDALONE
namespace o2::framework
{
template <typename T>
struct is_specialization<o2::dataformats::ConstMCTruthContainer<T>, std::vector> : std::true_type {
};
} // namespace o2::framework
#endif

namespace o2
{
namespace dataformats
{

// A "view" label container without owning the storage (similar to gsl::span)
template <typename TruthElement>
class ConstMCTruthContainerView
{
 public:
  ConstMCTruthContainerView(gsl::span<const char> const bufferview) : mStorage(bufferview){};
  ConstMCTruthContainerView(ConstMCTruthContainer<TruthElement> const& cont) : mStorage(gsl::span<const char>(cont)){};
  // be explicit that we want nullptr / 0 for an uninitialized container (needs (void)0 to avoid false codechecker warning)
  ConstMCTruthContainerView() : mStorage{nullptr, static_cast<gsl::span<const char>::size_type>(0)}
  {
    (void)0;
  }
  ConstMCTruthContainerView(const ConstMCTruthContainerView&) = default;

  // const data access
  // get individual const "view" container for a given data index
  // the caller can't do modifications on this view
  MCTruthHeaderElement const& getMCTruthHeader(uint32_t dataindex) const
  {
    return getHeaderStart()[dataindex];
  }

  gsl::span<const TruthElement> getLabels(uint32_t dataindex) const
  {
    if (dataindex >= getIndexedSize()) {
      return gsl::span<const TruthElement>();
    }
    const auto start = getMCTruthHeader(dataindex).index;
    const auto labelsptr = getLabelStart();
    return gsl::span<const TruthElement>(&labelsptr[start], getSize(dataindex));
  }

  // return the number of original data indexed here
  size_t getIndexedSize() const { return (size_t)mStorage.size() >= sizeof(FlatHeader) ? getHeader().nofHeaderElements : 0; }

  // return the number of labels managed in this container
  size_t getNElements() const { return (size_t)mStorage.size() >= sizeof(FlatHeader) ? getHeader().nofTruthElements : 0; }

  // return underlying buffer
  const gsl::span<const char>& getBuffer() const { return mStorage; }

 private:
  gsl::span<const char> mStorage;

  using FlatHeader = typename MCTruthContainer<TruthElement>::FlatHeader;

  size_t getSize(uint32_t dataindex) const
  {
    // calculate size / number of labels from a difference in pointed indices
    const auto size = (dataindex < getIndexedSize() - 1)
                        ? getMCTruthHeader(dataindex + 1).index - getMCTruthHeader(dataindex).index
                        : getNElements() - getMCTruthHeader(dataindex).index;
    return size;
  }

  /// Restore internal vectors from a raw buffer
  /// The two vectors are resized according to the information in the \a FlatHeader
  /// struct at the beginning of the buffer. Data is copied to the vectors.
  TruthElement const* getLabelStart() const
  {
    auto* source = &(mStorage)[0];
    auto flatheader = getHeader();
    source += sizeof(FlatHeader);
    const size_t headerSize = flatheader.sizeofHeaderElement * flatheader.nofHeaderElements;
    source += headerSize;
    return (TruthElement const*)source;
  }

  FlatHeader const& getHeader() const
  {
    const auto* source = &(mStorage)[0];
    const auto& flatheader = *reinterpret_cast<FlatHeader const*>(source);
    return flatheader;
  }

  MCTruthHeaderElement const* getHeaderStart() const
  {
    auto* source = &(mStorage)[0];
    source += sizeof(FlatHeader);
    return (MCTruthHeaderElement const*)source;
  }
};

using ConstMCLabelContainer = o2::dataformats::ConstMCTruthContainer<o2::MCCompLabel>;
using ConstMCLabelContainerView = o2::dataformats::ConstMCTruthContainerView<o2::MCCompLabel>;

} // namespace dataformats
} // namespace o2

#endif //O2_CONSTMCTRUTHCONTAINER_H
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_MCCOMPLABEL_H
#define ALICEO2_MCCOMPLABEL_H

#include "GPUCommonRtypes.h"

namespace o2
{
// Composed Label to encode MC track id, event it comes from and the source (file)

class MCCompLabel
{
 private:
  static constexpr uint64_t ul0x1 = 0x1;
  static constexpr uint64_t NotSet = 0xffffffffffffffff;
  static constexpr uint64_t Noise = 0xfffffffffffffffe;
  static constexpr uint64_t Fake = ul0x1 << 63;
  static constexpr int NReservedBits = 1;

  uint64_t mLabel = NotSet; ///< MC label encoding MCtrack ID and MCevent origin

 public:
  // number of bits reserved for MC track ID, DON'T modify this, since the
  // track ID might be negative
  static constexpr int nbitsTrackID = 31; // number of bits reserved for MC track ID
  static constexpr int nbitsEvID = 19;    // number of bits reserved for MC event ID
  static constexpr int nbitsSrcID = 8;    // number of bits reserved for MC source ID
  // the rest of the bits is reserved at the moment

  // check if the fields are defined consistently
  static_assert(nbitsTrackID + nbitsEvID + nbitsSrcID <= sizeof(uint64_t) * 8 - NReservedBits,
                "Fields cannot be stored in 64 bits");

  // mask to extract MC track ID
  static constexpr uint64_t maskTrackID = (ul0x1 << nbitsTrackID) - 1;
  // mask to extract MC track ID
  static constexpr uint64_t maskEvID = (ul0x1 << nbitsEvID) - 1;
  // mask to extract MC track ID
  static constexpr uint64_t maskSrcID = (ul0x1 << nbitsSrcID) - 1;
  // mask for all used fields
  static constexpr uint64_t maskFull = (ul0x1 << (nbitsTrackID + nbitsEvID + nbitsSrcID)) - 1;

  MCCompLabel(int trackID, int evID, int srcID, bool fake = false) { set(trackID, evID, srcID, fake); }
  MCCompLabel(bool noise = false)
  {
    if (noise) {
      mLabel = Noise;
    } else {
      mLabel = NotSet;
    }
  }
  ~MCCompLabel() = default;

  // check if label was assigned
  bool isSet() const { return mLabel != NotSet; }
  // check if label was not assigned
  bool isEmpty() const { return mLabel == NotSet; }
  // check if label corresponds to real particle
  bool isNoise() const { return mLabel == Noise; }
  // check if label was assigned as for correctly identified particle
  bool isValid() const { return isSet() && !isNoise(); }

  // check if label was assigned as for incorrectly identified particle or not set or noise
  bool isFake() const { return mLabel & Fake; }
  // check if label was assigned as for correctly identified particle
  bool isCorrect() const { return !isFake(); }

  // return 1 if the tracks are the same and correctly identified
  // 0 if the tracks are the same but at least one of them is fake
  // -1 otherwhise
  int compare(const MCCompLabel& other) const
  {
    if (getEventID() != other.getEventID() || getSourceID() != other.getSourceID()) {
      return -1;
    }
    int tr1 = getTrackID(), tr2 = other.getTrackID();
    return (tr1 == tr2) ? ((isCorrect() && other.isCorrect()) ? 1 : 0) : -1;
  }

  // allow to retrieve bare label
  uint64_t getRawValue() const { return mLabel; }

  // comparison operator, compares only label, not eventual weight or correctness info
  bool operator==(const MCCompLabel& other) const { return (mLabel & maskFull) == (other.mLabel & maskFull); }
  bool operator!=(const MCCompLabel& other) const { return (mLabel & maskFull) != (other.mLabel & maskFull); }
  // relation operators needed for some sorting methods
  bool operator<(const MCCompLabel& other) const { return (mLabel & maskFull) < (other.mLabel & maskFull); }
  bool operator>(const MCCompLabel& other) const { return (mLabel & maskFull) > (other.mLabel & maskFull); }

  // invalidate
  void unset() { mLabel = NotSet; }
  void setNoise() { mLabel = Noise; }
  void setFakeFlag(bool v = true)
  {
    if (v) {
      mLabel |= Fake;
    } else {
      mLabel &= ~Fake;
    }
  }

  void set(unsigned int trackID, int evID, int srcID, bool fake)
  {
    /// compose label: the track 1st cast to UInt32_t to preserve the sign!
    mLabel = (maskTrackID & static_cast<uint64_t>(trackID)) |
             (maskEvID & static_cast<uint64_t>(evID)) << nbitsTrackID |
             (maskSrcID & static_cast<uint64_t>(srcID)) << (nbitsTrackID + nbitsEvID);
    if (fake) {
      setFakeFlag();
    }
  }

  int getTrackID() const { return static_cast<int>(mLabel & maskTrackID); }
  int getTrackIDSigned() const { return isFake() ? -getTrackID() : getTrackID(); }
  int getEventID() const { return (mLabel >> nbitsTrackID) & maskEvID; }
  int getSourceID() const { return (mLabel >> (nbitsTrackID + nbitsEvID)) & maskSrcID; }
  uint64_t getTrackEventSourceID() const { return static_cast<uint64_t>(mLabel & maskFull); }
  void get(int& trackID, int& evID, int& srcID, bool& fake)
  {
    /// parse label
    trackID = getTrackID();
    evID = getEventID();
    srcID = getSourceID();
    fake = isFake();
  }

  void print() const;

  static constexpr int maxSourceID() { return maskSrcID; }
  static constexpr int maxEventID() { return maskEvID; }
  static constexpr int maxTrackID() { return maskTrackID; }
  ClassDefNV(MCCompLabel, 1);
};

std::ostream& operator<<(std::ostream& os, MCCompLabel const& c);

} // namespace o2

namespace std
{
// defining std::hash for MCCompLabel in order to be used with unordered_maps
template <>
struct hash<o2::MCCompLabel> {
 public:
  size_t operator()(o2::MCCompLabel const& label) const
  {
    return label.getRawValue();
  }
};
} // namespace std

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_MCVEVENTLABEL_H
#define ALICEO2_MCVEVENTLABEL_H

#include "GPUCommonRtypes.h"
#include <cmath>
#include <cassert>

namespace o2
{
// Composed Label to encode MC event and the source (file) + weight

class MCEventLabel
{
 private:
  static constexpr uint32_t Dummy = 0xffffffff;
  uint32_t mLabel = Dummy; ///< MC label encoding MCevent origin and fraction of correct contributors

 public:
  static constexpr int nbitsEvID = 16; // number of bits reserved for MC event ID
  static constexpr int nbitsSrcID = 7; // number of bits reserved for MC source ID
  static constexpr int nbitsCorrW = sizeof(mLabel) * 8 - nbitsEvID - nbitsSrcID - 1;
  static constexpr uint32_t NotSet = (0x1 << (nbitsEvID + nbitsSrcID)) - 1;

  // Mask to extract MC event ID
  static constexpr uint32_t MaskEvID = (0x1 << nbitsEvID) - 1;
  // Mask to extract MC source ID
  static constexpr uint32_t MaskSrcID = (0x1 << nbitsSrcID) - 1;
  // Mask to extract MC source and event ID only
  static constexpr uint32_t MaskSrcEvID = (MaskSrcID << nbitsEvID) | MaskEvID;
  // Mask to extract MC correct contribution weight
  static constexpr uint32_t MaskCorrW = (0x1 << nbitsCorrW) - 1;
  static constexpr float WeightNorm = 1. / float(MaskCorrW);

  MCEventLabel(int evID, int srcID, float corrw = 1.0) { set(evID, srcID, corrw); }
  MCEventLabel() = default;
  ~MCEventLabel() = default;

  // check if label was assigned
  bool isSet() const { return (mLabel & NotSet) != NotSet; }
  // check if label was not assigned
  bool isEmpty() const { return (mLabel & NotSet) == NotSet; }

  // conversion operator
  operator uint32_t() const { return mLabel; }
  // allow to retrieve bare label
  uint32_t getRawValue() const { return mLabel; }

  // get only combined identifier, discarding weight info
  uint32_t getIDOnly() const { return mLabel & MaskSrcEvID; }

  // compare
  bool compare(const MCEventLabel& other, bool strict = false) const
  {
    return strict ? (getRawValue() == other.getRawValue()) : (getIDOnly() == other.getIDOnly());
  }

  // comparison operator, compares only label, not eventual weight or correctness info
  bool operator==(const MCEventLabel& other) const { return compare(other); }

  // invalidate
  void unset() { mLabel = NotSet; }

  /// compose label
  void set(int evID, int srcID, float corrW)
  {
    uint32_t iw = static_cast<uint32_t>(std::round(corrW * MaskCorrW));
    assert(iw <= MaskCorrW);
    mLabel = (iw << (nbitsEvID + nbitsSrcID)) | ((MaskSrcID & static_cast<uint32_t>(srcID)) << nbitsEvID) | (MaskEvID & static_cast<uint32_t>(evID));
  }
  void setCorrWeight(float corrW)
  {
    uint32_t iw = static_cast<uint32_t>(std::round(corrW * MaskCorrW));
    assert(iw <= MaskCorrW);
    mLabel = (mLabel & ((MaskSrcID << nbitsEvID) | MaskEvID)) | (iw << (nbitsEvID + nbitsSrcID));
  }

  int getEventID() const
  {
    auto res = mLabel & MaskEvID;
    return res <= MaxEventID() ? res : -1;
  }

  int getSourceID() const
  {
    auto res = (mLabel >> nbitsEvID) & MaskSrcID;
    return res <= MaxSourceID() ? res : -1;
  }

  float getCorrWeight() const { return ((mLabel >> (nbitsEvID + nbitsSrcID)) & MaskCorrW) * WeightNorm; }

  void get(int& evID, int& srcID, float& corrW)
  {
    /// parse label
    evID = getEventID();
    srcID = getSourceID();
    corrW = getCorrWeight();
  }

  void print() const;

  static constexpr uint32_t MaxSourceID() { return MaskSrcID - 1; }
  static constexpr uint32_t MaxEventID() { return MaskEvID - 1; }
  static constexpr float WeightPrecision() { return WeightNorm; }
  ClassDefNV(MCEventLabel, 1);
};
} // namespace o2

std::ostream& operator<<(std::ostream& os, const o2::MCEventLabel& c);

namespace std
{
// defining std::hash for MCEventLabel in order to be used with unordered_maps
template <>
struct hash<o2::MCEventLabel> {
 public:
  size_t operator()(o2::MCEventLabel const& label) const
  {
    return static_cast<uint32_t>(label);
  }
};
} // namespace std

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_BASE_TRACKREFERENCE_H_
#define ALICEO2_BASE_TRACKREFERENCE_H_

#include <TVirtualMC.h>
#include <ostream>
#include "Rtypes.h" // for TrackReference::Class, ClassDef, etc
#include "TMath.h"  // for Pi, Sqrt, ATan2, Cos, Sin, ACos

namespace o2
{

// class encoding sim track status
struct SimTrackStatus {
 public:
  enum SimTrackStatus_Enum {
    kTrackEntering = 0x1,
    kTrackInside = 0x1 << 1,
    kTrackExiting = 0x1 << 2,
    kTrackOut = 0x1 << 3,
    kTrackStopped = 0x1 << 4,
    kTrackAlive = 0x1 << 5,
    kTrackNew = 0x1 << 6
  };
  SimTrackStatus() = default;
  SimTrackStatus(const TVirtualMC& vmc)
  {
    // This is quite annoying since every single call
    // is virtual
    if (vmc.IsTrackEntering()) {
      mStatus |= kTrackEntering;
    }
    if (vmc.IsTrackExiting()) {
      mStatus |= kTrackExiting;
    }
    if (vmc.IsTrackInside()) {
      mStatus |= kTrackInside;
    }
    if (vmc.IsTrackOut()) {
      mStatus |= kTrackOut;
    }
    if (vmc.IsTrackStop()) {
      mStatus |= kTrackStopped;
    }
    if (vmc.IsNewTrack()) {
      mStatus |= kTrackNew;
    }
    if (vmc.IsTrackAlive()) {
      mStatus |= kTrackAlive;
    }
  }
  bool isEntering() const { return mStatus & kTrackEntering; }
  bool isInside() const { return mStatus & kTrackInside; }
  bool isExiting() const { return mStatus & kTrackExiting; }
  bool isOut() const { return mStatus & kTrackOut; }
  bool isStopped() const { return mStatus & kTrackStopped; }
  bool isAlive() const { return mStatus & kTrackAlive; }
  bool isNew() const { return mStatus & kTrackNew; }
  unsigned char getStatusWord() const { return mStatus; }

  friend std::ostream& operator<<(std::ostream&, const SimTrackStatus&);

 private:
  unsigned char mStatus = 0;
  ClassDefNV(SimTrackStatus, 1);
};

/// Track Reference object is created every time particle is
/// crossing detector bounds.
/// It is a snapshot of the track during propagation.

/// The class stores the following informations:
/// track label,
/// track position: X,Y,X
/// track momentum px, py, pz
/// track length and time of fligth: both in cm
/// status bits from Monte Carlo

// NOTE: This track shares a lot of functionality with MC track and other tracks
// which should be factored into a common base class
class TrackReference
{
 public:
  /// Default Constructor
  TrackReference() = default;

  TrackReference(float x, float y, float z, float px, float py, float pz, float length, float tof, int trackID,
                 int detlabel);
  TrackReference(const TVirtualMC& vmc, int detlabel);

  /// Default Destructor
  ~TrackReference() = default;

  Int_t getTrackID() const { return mTrackNumber; }
  void setTrackID(Int_t track) { mTrackNumber = track; }
  void setLength(float length) { mTrackLength = length; }
  void setTime(float time) { mTof = time; }
  float getLength() const { return mTrackLength; }
  float getTime() const { return mTof; }
  float R() const { return TMath::Sqrt(mX * mX + mY * mY); }

  float Pt() const { return TMath::Sqrt(mPX * mPX + mPY * mPY); }
  float PhiPos() const { return TMath::ATan2(mY, mX); }
  float Phi() const { return TMath::ATan2(mPY, mPX); }
  float Theta() const { return TMath::ACos(mPZ / P()); }
  float X() const { return mX; }
  float Y() const { return mY; }
  float Z() const { return mZ; }
  float Px() const { return mPX; }
  float Py() const { return mPY; }
  float Pz() const { return mPZ; }
  float P() const { return TMath::Sqrt(mPX * mPX + mPY * mPY + mPZ * mPZ); }
  Int_t getUserId() const { return mUserId; }
  Int_t getDetectorId() const { return mDetectorId; }
  void setDetectorId(Int_t id) { mDetectorId = id; }

  void setPosition(float x, float y, float z)
  {
    mX = x;
    mY = y;
    mZ = z;
  }

  void setMomentum(float px, float py, float pz)
  {
    mPX = px;
    mPY = py;
    mPZ = pz;
  }

  void setUserId(Int_t userId) { mUserId = userId; }

  // Methods to get position of the track reference in
  // in the TPC/TRD/TOF Tracking coordinate system
  float phiPosition() const { return TMath::Pi() + TMath::ATan2(-mY, -mX); }

  float Alpha() const { return TMath::Pi() * (20 * ((((Int_t)(phiPosition() * 180 / TMath::Pi())) / 20)) + 10) / 180.; }

  float LocalX() const
  {
    auto alpha = Alpha();
    return mX * TMath::Cos(-alpha) - mY * TMath::Sin(-alpha);
  }

  float LocalY() const
  {
    auto alpha = Alpha();
    return mX * TMath::Sin(-alpha) + mY * TMath::Cos(-alpha);
  }

  const SimTrackStatus& getTrackStatus() const { return mStatus; }

 private:
  Int_t mTrackNumber = 0; ///< Track number
  float mX = 0;           ///< X reference position of the track
  float mY = 0;           ///< Y reference position of the track
  float mZ = 0;           ///< Z reference position of the track
  float mPX = 0;          ///< momentum
  float mPY = 0;          ///< momentum
  float mPZ = 0;          ///< momentum
  float mTrackLength = 0; ///< track length from its origin in cm
  float mTof = 0;         ///< time of flight in cm
  Int_t mUserId = 0;      ///< optional Id defined by user
  Int_t mDetectorId = 0;  ///< Detector Id
  SimTrackStatus mStatus; ///< encoding the track status

  friend std::ostream& operator<<(std::ostream&, const TrackReference&);

  ClassDefNV(TrackReference, 1); // Base class for all Alice track references
};

// this is the preferred constructor as it might reuse variables
// already fetched from VMC
inline TrackReference::TrackReference(float x, float y, float z, float px, float py, float pz, float l, float tof,
                                      int trackID, int detlabel)
  : mTrackNumber(trackID),
    mX(x),
    mY(y),
    mZ(z),
    mPX(px),
    mPY(py),
    mPZ(pz),
    mTrackLength(l),
    mTof(tof),
    mDetectorId(detlabel)
{
}

// constructor fetching everything from vmc instance
// less performant than other constructor since
// potentially duplicated virtual function calls (already used in the
// stepping functions)
inline TrackReference::TrackReference(TVirtualMC const& vmc, int detlabel) : mStatus(vmc)
{
  float x, y, z;
  float px, py, pz, e;
  vmc.TrackPosition(x, y, z);
  vmc.TrackMomentum(px, py, pz, e);
  mX = x;
  mY = y;
  mZ = z;
  mPX = px;
  mPY = py;
  mPZ = pz;
  mTrackLength = vmc.TrackLength();
  mTof = vmc.TrackTime();
  mDetectorId = detlabel;
  mTrackNumber = vmc.GetStack()->GetCurrentTrackNumber();
}

inline std::ostream& operator<<(std::ostream& os, const TrackReference& a)
{
  os << "TrackRef (" << a.mTrackNumber << "): X[" << a.mX << " , " << a.mY << " , " << a.mZ << "]"
     << "; P[ " << a.mPX << " , " << a.mPY << " , " << a.mPZ << " ] "
     << "; Length = " << a.mTrackLength << " ; TOF = " << a.mTof << " ; DetID = " << a.mDetectorId
     << "; Status = " << a.mStatus;
  return os;
}

inline std::ostream& operator<<(std::ostream& os, const SimTrackStatus& status)
{
  os << status.mStatus;
  return os;
}
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_DATA_PRIMARYCHUNK_H_
#define ALICEO2_DATA_PRIMARYCHUNK_H_

#include <cstring>
#include <SimulationDataFormat/MCEventHeader.h>

namespace o2
{
namespace data
{

// structure describing an entity of work
// processed by a simulation worker
struct SubEventInfo {
  float eventtime = 0.;
  uint32_t eventID = 0;   // which event ID
  int32_t maxEvents = -1; // the number of events in this run (if known otherwise set to -1)
  int32_t runID = 0;      // the runID of this run
  uint16_t part = 0;      // which part of the eventID
  uint16_t nparts = 0;    // out of how many parts
  uint32_t seed = 0;      // seed for RNG
  uint32_t index = 0;
  int32_t npersistenttracks = -1; // the number of persistent tracks for this SubEvent (might be set to cache it)
  int32_t nprimarytracks = -1;    // the number of primary tracks for this SubEvent
  // might add more fields (such as which process treated this chunk etc)

  o2::dataformats::MCEventHeader mMCEventHeader; // associated FairMC header for vertex information

  ClassDefNV(SubEventInfo, 1);
};

inline bool operator<(SubEventInfo const& a, SubEventInfo const& b)
{
  return a.eventID <= b.eventID && (a.part < b.part);
}

// Encapsulating primaries/tracks as well as the event info
// to be processed by the simulation processors.
struct PrimaryChunk {
  SubEventInfo mSubEventInfo;
  std::vector<TParticle> mParticles; // the particles for this chunk
  ClassDefNV(PrimaryChunk, 1);
};
} // namespace data
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_SIMULATIONDATAFORMAT_RUNCONTEXT_H
#define ALICEO2_SIMULATIONDATAFORMAT_RUNCONTEXT_H

#include <vector>
#include <TChain.h>
#include <TBranch.h>
#include "CommonDataFormat/InteractionRecord.h"
#include "CommonDataFormat/BunchFilling.h"
#include "DetectorsCommonDataFormats/DetID.h"
#include "DataFormatsParameters/GRPObject.h"
#include <GPUCommonLogger.h>

namespace o2
{
namespace steer
{
// a structure describing EventPart
// (an elementary constituent of a collision)

constexpr static int QEDSOURCEID = 99;

struct EventPart {
  EventPart() = default;
  EventPart(int s, int e) : sourceID(s), entryID(e) {}
  int sourceID = 0; // the ID of the source (0->backGround; > 1 signal source)
  // the sourceID should correspond to the chain ID
  int entryID = 0; // the event/entry ID inside the chain corresponding to sourceID

  static bool isSignal(EventPart e) { return e.sourceID > 1 && e.sourceID != QEDSOURCEID; }
  static bool isBackGround(EventPart e) { return !isSignal(e); }
  static bool isQED(EventPart e) { return e.sourceID == QEDSOURCEID; }
  ClassDefNV(EventPart, 1);
};

// class fully describing the Collision contexts
class DigitizationContext
{
 public:
  DigitizationContext() : mNofEntries{0}, mMaxPartNumber{0}, mEventRecords(), mEventParts() {}

  uint32_t getFirstOrbitForSampling() const { return mFirstOrbitForSampling; }
  void setFirstOrbitForSampling(uint32_t o) { mFirstOrbitForSampling = o; }

  int getNCollisions() const { return mNofEntries; }
  void setNCollisions(int n) { mNofEntries = n; }

  void setMaxNumberParts(int maxp) { mMaxPartNumber = maxp; }
  int getMaxNumberParts() const { return mMaxPartNumber; }

  std::vector<o2::InteractionTimeRecord>& getEventRecords(bool withQED = false) { return withQED ? mEventRecordsWithQED : mEventRecords; }
  std::vector<std::vector<o2::steer::EventPart>>& getEventParts(bool withQED = false) { return withQED ? mEventPartsWithQED : mEventParts; }

  const std::vector<o2::InteractionTimeRecord>& getEventRecords(bool withQED = false) const { return withQED ? mEventRecordsWithQED : mEventRecords; }
  const std::vector<std::vector<o2::steer::EventPart>>& getEventParts(bool withQED = false) const { return withQED ? mEventPartsWithQED : mEventParts; }

  bool isQEDProvided() const { return !mEventRecordsWithQED.empty(); }

  void setBunchFilling(o2::BunchFilling const& bf) { mBCFilling = bf; }
  const o2::BunchFilling& getBunchFilling() const { return (const o2::BunchFilling&)mBCFilling; }

  void setMuPerBC(float m) { mMuBC = m; }
  float getMuPerBC() const { return mMuBC; }

  void printCollisionSummary(bool withQED = false, int truncateOutputTo = -1) const;

  // we need a method to fill the file names
  void setSimPrefixes(std::vector<std::string> const& p);
  std::vector<std::string> const& getSimPrefixes() const { return mSimPrefixes; }

  /// add QED contributions to context; QEDprefix is prefix of QED production
  /// irecord is vector of QED interaction times (sampled externally)
  void fillQED(std::string_view QEDprefix, std::vector<o2::InteractionTimeRecord> const& irecord);

  /// Common functions the setup input TChains for reading, given the state (prefixes) encapsulated
  /// by this context. The input vector needs to be empty otherwise nothing will be done.
  /// return boolean saying if input simchains was modified or not
  bool initSimChains(o2::detectors::DetID detid, std::vector<TChain*>& simchains) const;

  /// Common functions the setup input TChains for reading kinematics information, given the state (prefixes) encapsulated
  /// by this context. The input vector needs to be empty otherwise nothing will be done.
  /// return boolean saying if input simchains was modified or not
  bool initSimKinematicsChains(std::vector<TChain*>& simkinematicschains) const;

  /// Check collision parts for vertex consistency.
  bool checkVertexCompatibility(bool verbose = false) const;

  /// function reading the hits from a chain (previously initialized with initSimChains
  /// The hits pointer will be initialized (what to we do about ownership??)
  template <typename T>
  void retrieveHits(std::vector<TChain*> const& chains,
                    const char* brname,
                    int sourceID,
                    int entryID,
                    std::vector<T>* hits) const;

  /// returns the GRP object associated to this context
  o2::parameters::GRPObject const& getGRP() const;

  // helper functions to save and load a context
  void saveToFile(std::string_view filename) const;

  static DigitizationContext const* loadFromFile(std::string_view filename = "");

 private:
  int mNofEntries = 0;
  int mMaxPartNumber = 0; // max number of parts in any given collision
  uint32_t mFirstOrbitForSampling = 0; // 1st orbit to start sampling

  float mMuBC;            // probability of hadronic interaction per bunch

  std::vector<o2::InteractionTimeRecord> mEventRecords;
  // for each collision we record the constituents (which shall not exceed mMaxPartNumber)
  std::vector<std::vector<o2::steer::EventPart>> mEventParts;

  // the collision records _with_ QED interleaved;
  std::vector<o2::InteractionTimeRecord> mEventRecordsWithQED;
  std::vector<std::vector<o2::steer::EventPart>> mEventPartsWithQED;

  o2::BunchFilling mBCFilling; // pattern of active BCs

  std::vector<std::string> mSimPrefixes;             // identifiers to the hit sim products; the key corresponds to the source ID of event record
  std::string mQEDSimPrefix;                         // prefix for QED production/contribution
  mutable o2::parameters::GRPObject* mGRP = nullptr; //!

  ClassDefNV(DigitizationContext, 4);
};

/// function reading the hits from a chain (previously initialized with initSimChains
template <typename T>
inline void DigitizationContext::retrieveHits(std::vector<TChain*> const& chains,
                                              const char* brname,
                                              int sourceID,
                                              int entryID,
                                              std::vector<T>* hits) const
{
  auto br = chains[sourceID]->GetBranch(brname);
  if (!br) {
    LOG(error) << "No branch found with name " << brname;
    return;
  }
  br->SetAddress(&hits);
  br->GetEntry(entryID);
}

} // namespace steer
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \brief Definition of a container to keep/associate and arbitrary
/// number of labels associated to an index with contiguous or non-contiguous label storage
// \author Sandro Wenzel - June 2017

#ifndef ALICEO2_DATAFORMATS_LABELCONTAINER_H_
#define ALICEO2_DATAFORMATS_LABELCONTAINER_H_

#include <TNamed.h>
#include <cassert>
#include <stdexcept>
#include <type_traits>
#include <iterator>
#include <gsl/gsl> // for guideline support library; array_view

namespace o2::dataformats
{

// a label container with both contiguous and non-contiguous modes
// for label storage
// NOTE: the current specialization for contiguous storage is not
// yet on par with MCTruthContainer ... but eventually we might unify
// everything and keep only the more generic and configurable version
template <typename LabelType, bool isContiguousStorage = true>
class LabelContainer
{
 public:
  struct HeaderElementContinuous {
    HeaderElementContinuous() = default; // for ROOT IO
    HeaderElementContinuous(unsigned short s, unsigned int i) : size(s), index(i) {}
    unsigned int index = 0;  // index of first label in the actual label storage
    unsigned short size = 0; // total number of labels
    ClassDefNV(HeaderElementContinuous, 1);
  };

  struct HeaderElementLinked {
    HeaderElementLinked() = default; // for ROOT IO
    HeaderElementLinked(unsigned int i, int l, unsigned short s) : index(i), lastindex(l), size(s) {}
    unsigned int index = 0;     // index of first label in the actual label storage
    unsigned int lastindex = 0; // index of last label in the actual label storage
    unsigned short size = 0;    // total number of labels
    ClassDefNV(HeaderElementLinked, 1);
  };

  using HeaderElement = typename std::conditional<isContiguousStorage, HeaderElementContinuous, HeaderElementLinked>::type;
  using StoredLabelType = typename std::conditional<isContiguousStorage, LabelType, std::pair<LabelType, int>>::type;

  // internal functions allowing the iterator implementation to be completely generic
  static unsigned int getNextIndex(unsigned int index, std::vector<LabelType> const& /*labels*/)
  {
    return index + 1;
  }
  static unsigned int getNextIndex(unsigned int index, std::vector<std::pair<LabelType, int>> const& labels)
  {
    return labels[index].second;
  }
  static LabelType& dereference(std::vector<LabelType>& v, int index)
  {
    return v[index];
  }
  static LabelType& dereference(std::vector<std::pair<LabelType, int>>& v, int index)
  {
    return v[index].first;
  }
  static int lastIndex(HeaderElementContinuous const& h)
  {
    return h.index + h.size;
  }
  static int lastIndex(HeaderElementLinked const& h)
  {
    // -1 since this is indication of end of linked list
    return -1;
  }

  // an iterator class to iterate over truthelements
  class Iterator
  {
   private:
    using iterator_category = std::input_iterator_tag;
    using value_type = LabelType;
    using difference_type = std::ptrdiff_t;
    using pointer = LabelType*;
    using reference = LabelType&;
    std::vector<StoredLabelType>& mLabelsRef; // reference to labels vector
    int index;                                // startindex
   public:
    Iterator(std::vector<StoredLabelType>& v, int i) : mLabelsRef(v), index(i) {}
    Iterator(const Iterator& it) : mLabelsRef(it.mLabelsRef), index(it.index) {}
    Iterator& operator=(const Iterator& it)
    {
      mLabelsRef = it.mLabelsRef;
      index = it.index;
      return *this;
    }

    // go to the next element as indicated by second entry of StoredLabelType
    Iterator& operator++()
    {
      index = getNextIndex(index, mLabelsRef);
      return *this;
    }

    bool operator==(const Iterator& rhs) const { return index == rhs.index; }
    bool operator!=(const Iterator& rhs) const { return index != rhs.index; }
    LabelType& operator*() { return dereference(mLabelsRef, index); }
  };

  // a proxy class offering a (non-owning) container view on labels of a given data index
  // container offers basic forward iterator functionality
  class LabelView
  {
   private:
    int dataindex;
    std::vector<HeaderElement>& mHeaderArrayRef;
    std::vector<StoredLabelType>& mLabelArrayRef;

   public:
    constexpr LabelView(int i, std::vector<HeaderElement>& v1, std::vector<StoredLabelType>& v2) : dataindex(i), mHeaderArrayRef(v1), mLabelArrayRef(v2) {}

    // begin + end iterators to loop over the labels
    Iterator begin()
    {
      return dataindex < mHeaderArrayRef.size() ? Iterator(mLabelArrayRef, mHeaderArrayRef[dataindex].index) : Iterator(mLabelArrayRef, 0);
    }

    Iterator end()
    {
      return dataindex < mHeaderArrayRef.size() ? Iterator(mLabelArrayRef, lastIndex(mHeaderArrayRef[dataindex])) : Iterator(mLabelArrayRef, 0);
    }

    // get number of labels
    size_t size() const { return dataindex < mHeaderArrayRef.size() ? mHeaderArrayRef[dataindex].size : 0; }
  };

  static void addLabelImpl(int dataindex, std::vector<HeaderElementContinuous>& headerv, std::vector<LabelType>& labelv, LabelType const& label)
  {
    if (dataindex < headerv.size()) {
      // look if we have something for this dataindex already
      // must currently be the last one
      if (dataindex != (headerv.size() - 1)) {
        throw std::runtime_error("LabelContainer: unsupported code path");
      }
    } else {
      assert(dataindex == headerv.size());
      // add a new one
      headerv.emplace_back(0, labelv.size());
    }
    auto& header = headerv[dataindex];
    header.size++;
    labelv.emplace_back(label);
  }

  static void addLabelImpl(int dataindex, std::vector<HeaderElementLinked>& headerv, std::vector<std::pair<LabelType, int>>& labelv, LabelType const& label)
  {
    labelv.emplace_back(std::make_pair(label, -1));
    // something exists for this dataindex already
    if (dataindex < headerv.size()) {
      auto& header = headerv[dataindex];
      // increase size
      header.size++;
      const auto lastindex = labelv.size() - 1;
      // fix link at previous last index
      labelv[header.lastindex].second = lastindex;
      // new last index
      header.lastindex = lastindex;
    } else {
      // we support only appending in order?
      assert(dataindex == headerv.size());
      // add a new header element; pointing to last slot in mTruthArray
      const auto lastpos = labelv.size() - 1;
      headerv.emplace_back(lastpos, lastpos, 1);
    }
  }

  // declaring the data members
  std::vector<HeaderElement> mHeaderArray;  // the header structure array serves as an index into the actual storage
  std::vector<StoredLabelType> mLabelArray; // the buffer containing the actual truth information

 public:
  // constructor
  LabelContainer() = default;
  ~LabelContainer() = default;

  // reserve some initial space in the actual storage
  // (to hold at least n labels)
  void reserve(int n)
  {
    mHeaderArray.reserve(n);
    mLabelArray.reserve(n);
  }

  void clear()
  {
    mHeaderArray.clear();
    mLabelArray.clear();
  }

  /// add a label for a dataindex
  void addLabel(unsigned int dataindex, LabelType const& label)
  {
    // refer to concrete specialized implementation
    addLabelImpl(dataindex, mHeaderArray, mLabelArray, label);
  }

  /// get a container view on labels allowing use standard forward iteration in user code
  LabelView getLabels(int dataindex) { return LabelView(dataindex, mHeaderArray, mLabelArray); }

  /// fill an external vector container with labels
  /// might be useful to perform additional operations such as sorting on the labels;
  /// the external vector can be reused to avoid allocations/deallocs)
  void fillVectorOfLabels(int dataindex, std::vector<LabelType>& v)
  {
    /// fixme: provide a template specialized fast version for contiguous storage
    v.clear();
    for (auto& e : getLabels(dataindex)) {
      v.push_back(e);
    }
  }
}; // end class

} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \author R+Preghenella - August 2017

#ifndef ALICEO2_DATAFORMATS_MCEVENTHEADER_H_
#define ALICEO2_DATAFORMATS_MCEVENTHEADER_H_

#include "FairMCEventHeader.h"
#include "SimulationDataFormat/MCEventStats.h"
#include "CommonUtils/RootSerializableKeyValueStore.h"
#include <string>
#include <Framework/Logger.h>

namespace o2
{
namespace dataformats
{

class GeneratorHeader;

/*****************************************************************/
/*****************************************************************/

// AliceO2 specialization of EventHeader class
class MCEventHeader : public FairMCEventHeader
{

 public:
  MCEventHeader() = default;
  MCEventHeader(const MCEventHeader& rhs) = default;
  MCEventHeader& operator=(const MCEventHeader& rhs) = default;
  ~MCEventHeader() override = default;

  /** setters **/
  void setEmbeddingFileName(std::string const& value) { mEmbeddingFileName = value; };
  void setEmbeddingEventIndex(Int_t value) { mEmbeddingEventIndex = value; };
  int getEmbeddedIndex() const { return mEmbeddingEventIndex; }

  /** methods to handle stored information **/

  void clearInfo()
  {
    mEventInfo.clear();
  };

  template <typename T>
  void putInfo(std::string const& key, T const& value)
  {
    mEventInfo.put<T>(key, value);
  };

  bool hasInfo(std::string const& key) const
  {
    return mEventInfo.has(key);
  }

  template <typename T>
  const T& getInfo(std::string const& key, bool& isvalid) const
  {
    o2::utils::RootSerializableKeyValueStore::GetState state;
    auto& ref = mEventInfo.getRef<T>(key, state);
    isvalid = (state == o2::utils::RootSerializableKeyValueStore::GetState::kOK);
    if (!isvalid) {
      LOG(warning) << "problem retrieving info '" << key << "': " << o2::utils::RootSerializableKeyValueStore::getStateString(state);
    }
    return ref;
  };

  /// prints a summary of info keys/types attached to this header
  void printInfo() const
  {
    mEventInfo.print();
  }

  /** methods **/
  virtual void Reset();

  MCEventStats& getMCEventStats() { return mEventStats; }

  /// create a standalone ROOT file/tree with only the MCHeader branch
  static void extractFileFromKinematics(std::string_view kinefilename, std::string_view targetfilename);

 protected:
  std::string mEmbeddingFileName;
  Int_t mEmbeddingEventIndex = 0;

  // store a view global properties that this event
  // had in the current simulation (which can be used quick filtering/searching)
  MCEventStats mEventStats{};
  o2::utils::RootSerializableKeyValueStore mEventInfo;

  ClassDefOverride(MCEventHeader, 3);

}; /** class MCEventHeader **/

/*****************************************************************/
/*****************************************************************/

} /* namespace dataformats */
} /* namespace o2 */

#endif /* ALICEO2_DATAFORMATS_MCEVENTHEADER_H_ */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \author S Wenzel - April 2019

#ifndef ALICEO2_DATAFORMATS_MCEVENTSTATS_H_
#define ALICEO2_DATAFORMATS_MCEVENTSTATS_H_

#include "Rtypes.h" // to get ClassDef?

namespace o2
{
namespace dataformats
{

/// A simple class collecting summary counters about
/// the MC transport of a single event/chunk
class MCEventStats
{
 public:
  void setNHits(int n) { mNOfHits = n; }
  int getNHits() const { return mNOfHits; }
  void setNTransportedTracks(int n) { mNOfTransportedTracks = n; }
  int getNTransportedTracks() const { return mNOfTransportedTracks; }
  void setNKeptTracks(int n) { mNOfKeptTracks = n; }
  int getNKeptTracks() const { return mNOfKeptTracks; }
  void setNSteps(int n) { mNOfSteps = n; }
  int getNSteps() const { return mNOfSteps; }

  /// merge from another object
  void add(MCEventStats const& other)
  {
    mNOfHits += other.mNOfHits;
    mNOfTransportedTracks += other.mNOfTransportedTracks;
    mNOfKeptTracks += other.mNOfKeptTracks;
    mNOfSteps += other.mNOfSteps;
  }

 private:
  // store a view global properties that this event
  // had in the current simulation (which can be used quick filtering/searching)

  int mNOfHits = 0;              // number of hits produced
  int mNOfTransportedTracks = 0; // number of tracks transported
  int mNOfKeptTracks = 0;        // number of tracks stored/kept in output
  int mNOfSteps = 0;             // number of MC steps done

  ClassDefNV(MCEventStats, 1);

}; /** class MCEventStats **/

/*****************************************************************/
/*****************************************************************/

} /* namespace dataformats */
} /* namespace o2 */

#endif /* ALICEO2_DATAFORMATS_MCEVENTSTATS_H_ */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file IOMCTruthContainerView.h
/// \brief A special IO container - splitting a given vector to enable ROOT IO
/// \author Sandro Wenzel - August 2020

#ifndef ALICEO2_DATAFORMATS_IOMCTRUTHVIEW_H_
#define ALICEO2_DATAFORMATS_IOMCTRUTHVIEW_H_

#include "GPUCommonRtypes.h" // to have the ClassDef macros
#include <vector>
#include <gsl/span>

namespace o2
{
namespace dataformats
{

///
/// A specially constructed class allowing to stream a very large
/// vector buffer to a ROOT file. This is needed since ROOT currently has a size
/// limitation of ~1GB for data that it can stream per entry in a branch.
/// The solution is based on the ability of ROOT to split entries per data member, so
/// some input buffer gets divided into multiple parts.
///
/// TODO: We could template this class to encode original type information (for the input buffer).
class IOMCTruthContainerView
{
 public:
  IOMCTruthContainerView() = default;

  /// Constructor taking an existing flat vector as input; No copy is done - the
  /// container is just a split view on the original buffer.
  IOMCTruthContainerView(std::vector<char> const& input)
  {
    adopt(gsl::span<const char>(&(input[0]), input.size()));
  }

  IOMCTruthContainerView(gsl::span<const char> const input)
  {
    adopt(input);
  }

  ~IOMCTruthContainerView()
  {
    if (!mIsView) {
      delete[] part1;
      delete[] part2;
      delete[] part3;
      delete[] part4;
      delete[] part5;
      delete[] part6;
      delete[] part7;
      delete[] part8;
      delete[] part9;
      delete[] part10;
    }
  }

  /// "adopt" (without taking ownership) from an existing buffer
  void adopt(gsl::span<const char> const input)
  {
    mIsView = true;
    const auto delta = input.size() / N;
    N2 = input.size() - (N - 1) * delta;
    N1 = delta;
    // TODO: this could benefit from a loop expansion
    part1 = &input[0];
    part2 = &input[delta];
    part3 = &input[2 * delta];
    part4 = &input[3 * delta];
    part5 = &input[4 * delta];
    part6 = &input[5 * delta];
    part7 = &input[6 * delta];
    part8 = &input[7 * delta];
    part9 = &input[8 * delta];
    part10 = &input[9 * delta];
  }

  /// A function to recreate a flat output vector from this buffer. This
  /// function is copying the data.
  template <typename Alloc>
  void copyandflatten(std::vector<char, Alloc>& output) const
  {
    // TODO: this could benefit from a loop expansion
    copyhelper(part1, N1, output);
    copyhelper(part2, N1, output);
    copyhelper(part3, N1, output);
    copyhelper(part4, N1, output);
    copyhelper(part5, N1, output);
    copyhelper(part6, N1, output);
    copyhelper(part7, N1, output);
    copyhelper(part8, N1, output);
    copyhelper(part9, N1, output);
    copyhelper(part10, N2, output);
  }

  /// return total size in bytes
  size_t getSize() const { return N1 * (N - 1) + N2; }

 private:
  static constexpr int N = 10;
  int N1 = 0;
  int N2 = 0;
  const char* part1 = nullptr;  //[N1]
  const char* part2 = nullptr;  //[N1]
  const char* part3 = nullptr;  //[N1]
  const char* part4 = nullptr;  //[N1]
  const char* part5 = nullptr;  //[N1]
  const char* part6 = nullptr;  //[N1]
  const char* part7 = nullptr;  //[N1]
  const char* part8 = nullptr;  //[N1]
  const char* part9 = nullptr;  //[N1]
  const char* part10 = nullptr; //[N2]

  bool mIsView = false; //! if this was merely adopted from an existing container or actually owns the memory
                        //  we need to know this for the destructor

  template <typename Alloc>
  void copyhelper(const char* input, int size, std::vector<char, Alloc>& output) const
  {
    gsl::span<const char> tmp(input, size);
    std::copy(tmp.begin(), tmp.end(), std::back_inserter(output));
  }

  ClassDefNV(IOMCTruthContainerView, 1);
};
} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file MCUtils.h
/// \brief Utility functions for MC particles
/// \author S. Wenzel - November 2021

#ifndef O2_MCUTILS_H
#define O2_MCUTILS_H

#include <SimulationDataFormat/MCTrack.h>
#include "TPDGCode.h"

namespace o2
{
namespace mcutils
{
/// A couple of functions to query on MC tracks ( that needs navigation within the global container
/// of available tracks. It is a class so as to make it available for interactive ROOT more easily.
class MCTrackNavigator
{
 public:
  /// Function to determine if a MC track/particle p is a primary according to physics criteria.
  /// Needs the particle as input, as well as the whole navigable container of particles
  /// (of which p needs to be a part itself). The container can be fetched via MCKinematicsReader.
  static bool isPhysicalPrimary(o2::MCTrack const& p, std::vector<o2::MCTrack> const& pcontainer);

  /// return true of particle is to be kept for physics analysis in any case
  /// (follows logic used in particle stack class
  static bool isKeepPhysics(o2::MCTrack const& p, std::vector<o2::MCTrack> const& pcontainer);
  static bool isFromPrimaryDecayChain(o2::MCTrack const& p, std::vector<o2::MCTrack> const& pcontainer);

  // some convenience functions for navigation

  /// Given an MCTrack p; Return the first primary mother particle in the upward parent chain (follow
  /// only first mothers). The first primary mother may have further parent (put by the generator).
  /// Return p itself if p is a primary.
  static o2::MCTrack const& getFirstPrimary(o2::MCTrack const& p, std::vector<o2::MCTrack> const& pcontainer);

  /// Given an MCTrack p; Return it's direct mother or nullptr. (we follow only first mother)
  static o2::MCTrack const* getMother(o2::MCTrack const& p, std::vector<o2::MCTrack> const& pcontainer);

  /// Given an MCTrack p; Return it's direct daughter or nullptr. (we follow only first daughter)
  static o2::MCTrack const* getDaughter(o2::MCTrack const& p, std::vector<o2::MCTrack> const& pcontainer);

  /// Given an MCTrack p; Return it's first direct daughter or nullptr.
  static o2::MCTrack const* getDaughter0(o2::MCTrack const& p, std::vector<o2::MCTrack> const& pcontainer);
  /// Given an MCTrack p; Return it's second direct daughter or nullptr.
  static o2::MCTrack const* getDaughter1(o2::MCTrack const& p, std::vector<o2::MCTrack> const& pcontainer);

  /// Given an MCTrack p; Fill the complete parent chain (ancestorchain) up to the most fundamental particle (follow only
  /// first mothers).
  // static void getParentChain(o2::MCTrack const& p, std::vector<o2::MCTrack> const& pcontainer, std::vector<o2::MCTrack> &ancestorchain);

  /// query if a track is a direct **or** indirect daughter of a parentID
  /// if trackid is same as parentid it returns true
  /// bool isTrackDaughterOf(int /*trackid*/, int /*parentid*/) const;
  /// we can think about offering some visitor like patterns executing a
  /// user hook on nodes

  ClassDefNV(MCTrackNavigator, 1);
};

/// Determine if a particle (identified by pdg) is stable
inline bool isStable(int pdg)
{
  //
  // Decide whether particle (pdg) is stable
  //

  // All ions/nucleons are considered as stable
  // Nuclear code is 10LZZZAAAI
  if (pdg > 1000000000) {
    return true;
  }

  const int kNstable = 18;
  int pdgStable[kNstable] = {
    kGamma,      // Photon
    kElectron,   // Electron
    kMuonPlus,   // Muon
    kPiPlus,     // Pion
    kKPlus,      // Kaon
    kK0Short,    // K0s
    kK0Long,     // K0l
    kProton,     // Proton
    kNeutron,    // Neutron
    kLambda0,    // Lambda_0
    kSigmaMinus, // Sigma Minus
    kSigmaPlus,  // Sigma Plus
    3312,        // Xsi Minus
    3322,        // Xsi
    3334,        // Omega
    kNuE,        // Electron Neutrino
    kNuMu,       // Muon Neutrino
    kNuTau       // Tau Neutrino
  };

  // this is linear search ---> a hash map or binary search should be more appropriate??
  for (int i = 0; i < kNstable; ++i) {
    if (pdg == std::abs(pdgStable[i])) {
      return true;
    }
  }
  return false;
}

} // namespace mcutils
} // namespace o2

#endif //O2_MCUTILS_H

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from G__O2DetectorsBase dictionary payload:94:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/FairRoot/v18.4.8-10/include/FairDetector.h:11:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/FairRoot/v18.4.8-10/include/FairModule.h:13:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/FairRoot/v18.4.8-10/include/FairGeoNode.h:13:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/FairRoot/v18.4.8-10/include/FairGeoTransform.h:11:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/FairRoot/v18.4.8-10/include/FairGeoRotation.h:11:
/home/abigot/alice/sw/ubuntu2004_x86-64/FairRoot/v18.4.8-10/include/FairGeoVector.h:51:67: error: reference to overloaded function could not be resolved; did you mean to call it?
            std::cout << " -E- Vector index  is 0 1 2 only ! " << std::endl;
                                                                  ^~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:681:5: note: possible target for call
    endl(basic_ostream<_CharT, _Traits>& __os)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/system_error:262:5: note: candidate function template not viable: no overload of 'endl' matching 'const std::error_code' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:506:5: note: candidate function [with _CharT = char, _Traits = std::char_traits<char>] not viable: no overload of 'endl' matching 'char' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:511:5: note: candidate function template not viable: no overload of 'endl' matching 'char' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:517:5: note: candidate function template not viable: no overload of 'endl' matching 'char' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:523:5: note: candidate function template not viable: no overload of 'endl' matching 'signed char' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:528:5: note: candidate function template not viable: no overload of 'endl' matching 'unsigned char' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:589:5: note: candidate function [with _CharT = char, _Traits = std::char_traits<char>] not viable: no overload of 'endl' matching 'const char *' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:606:5: note: candidate function template not viable: no overload of 'endl' matching 'const char *' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:619:5: note: candidate function template not viable: no overload of 'endl' matching 'const signed char *' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:624:5: note: candidate function template not viable: no overload of 'endl' matching 'const unsigned char *' for 2nd argument
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/ostream.tcc:321:5: note: candidate function template not viable: no overload of 'endl' matching 'const char *' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/thread:348:5: note: candidate function template not viable: no overload of 'endl' matching 'thread::id' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/iomanip:79:5: note: candidate function template not viable: no overload of 'endl' matching 'std::_Resetiosflags' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/iomanip:109:5: note: candidate function template not viable: no overload of 'endl' matching 'std::_Setiosflags' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/iomanip:143:5: note: candidate function template not viable: no overload of 'endl' matching 'std::_Setbase' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/iomanip:178:5: note: candidate function [with _CharT = char, _Traits = std::char_traits<char>] not viable: no overload of 'endl' matching '_Setfill<char>' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/iomanip:208:5: note: candidate function template not viable: no overload of 'endl' matching 'std::_Setprecision' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/iomanip:238:5: note: candidate function template not viable: no overload of 'endl' matching 'std::_Setw' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/iomanip:363:5: note: candidate function [with _CharT = char, _Traits = std::char_traits<char>] not viable: no overload of 'endl' matching '_Put_time<char>' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_time<_CharT> __f)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:986:5: note: candidate function template not viable: no overload of 'endl' matching 'const std::bernoulli_distribution' for 2nd argument
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/string_view:622:5: note: candidate function [with _CharT = char, _Traits = std::char_traits<char>] not viable: no overload of 'endl' matching 'basic_string_view<char, std::char_traits<char> >' for 2nd argument
    operator<<(basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TString.h:470:16: note: candidate function not viable: no overload of 'endl' matching 'const TString' for 2nd argument
std::ostream  &operator<<(std::ostream &str, const TString &s);
               ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TTimeStamp.h:59:15: note: candidate function not viable: no overload of 'endl' matching 'const TTimeStamp' for 2nd argument
std::ostream &operator<<(std::ostream &os,  const TTimeStamp &ts);
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBits.h:184:22: note: candidate function not viable: no overload of 'endl' matching 'const TBits' for 2nd argument
inline std::ostream &operator<<(std::ostream& os, const TBits& rhs)
                     ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TGeoVector3.h:194:15: note: candidate function not viable: no overload of 'endl' matching 'const ROOT::Geom::Vertex_t' for 2nd argument
std::ostream &operator<<(std::ostream &os, ROOT::Geom::Vertex_t const &vec);
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TGeoTessellated.h:103:15: note: candidate function not viable: no overload of 'endl' matching 'const TGeoFacet' for 2nd argument
std::ostream &operator<<(std::ostream &os, TGeoFacet const &facet);
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TEveTrans.h:184:15: note: candidate function not viable: no overload of 'endl' matching 'const TEveTrans' for 2nd argument
std::ostream& operator<<(std::ostream& s, const TEveTrans& t);
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/RooPrintable.h:65:15: note: candidate function not viable: no overload of 'endl' matching 'const RooPrintable' for 2nd argument
std::ostream& operator<<(std::ostream& os, const RooPrintable& rp) ; 
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/RooAbsArg.h:765:15: note: candidate function not viable: no overload of 'endl' matching 'const RooAbsArg' for 2nd argument
std::ostream& operator<<(std::ostream& os, const RooAbsArg &arg);
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/RooFitHS3/JSONInterface.h:135:15: note: candidate function not viable: no overload of 'endl' matching 'const RooFit::Experimental::JSONNode' for 2nd argument
std::ostream &operator<<(std::ostream &os, RooFit::Experimental::JSONNode const &s);
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/MathUtils/Cartesian.h:254:15: note: candidate function not viable: no overload of 'endl' matching 'const o2::math_utils::Rotation2Df_t' (aka 'const Rotation2D<float>') for 2nd argument
std::ostream& operator<<(std::ostream& os, const o2::math_utils::Rotation2Df_t& t);
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/MathUtils/Cartesian.h:255:15: note: candidate function not viable: no overload of 'endl' matching 'const o2::math_utils::Rotation2Dd_t' (aka 'const Rotation2D<double>') for 2nd argument
std::ostream& operator<<(std::ostream& os, const o2::math_utils::Rotation2Dd_t& t);
              ^
note: candidate function not viable: no overload of 'endl' matching 'const o2::MCEventLabel' for 2nd argument
fatal error: cannot open file 'input_line_35': No such file or directory
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TString.h:475:11: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
TBuffer  &operator<<(TBuffer &buf, const TString * sp);
          ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:361:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, Bool_t b)   { buf.WriteBool(b);   return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:362:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, Char_t c)   { buf.WriteChar(c);   return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:363:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, UChar_t c)  { buf.WriteUChar(c);  return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:364:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, Short_t s)  { buf.WriteShort(s);  return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:365:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, UShort_t s) { buf.WriteUShort(s); return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:366:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, Int_t i)    { buf.WriteInt(i);    return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:367:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, UInt_t i)   { buf.WriteUInt(i);   return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:368:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, Long_t l)   { buf.WriteLong(l);   return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:369:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, ULong_t l)  { buf.WriteULong(l);  return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:370:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, Long64_t l) { buf.WriteLong64(l); return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:371:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, ULong64_t l){ buf.WriteULong64(l);return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:372:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, Float_t f)  { buf.WriteFloat(f);  return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:373:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, Double_t d) { buf.WriteDouble(d); return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:374:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, const Char_t *c)  { buf.WriteCharP(c);  return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:375:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, const TString &s) { buf.WriteTString(s);return buf; }
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TUUID.h:95:10: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
TBuffer &operator<<(TBuffer &buf, const TUUID &uuid);
         ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TMD5.h:89:10: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
TBuffer &operator<<(TBuffer &buf, const TMD5 &md5);
         ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TArray.h:75:10: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
TBuffer &operator<<(TBuffer &b, const TArray *obj);
         ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TArrayI.h:73:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, const TArrayI *obj)
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TTimeStamp.h:60:10: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
TBuffer &operator<<(TBuffer &buf, const TTimeStamp &ts);
         ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TArrayC.h:72:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, const TArrayC *obj)
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TArrayD.h:73:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, const TArrayD *obj)
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TArrayF.h:72:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, const TArrayF *obj)
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TArrayL64.h:74:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, const TArrayL64 *obj)
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TArrayL.h:74:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, const TArrayL *obj)
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TArrayS.h:72:17: note: candidate function not viable: no known conversion from 'basic_ostream<char, std::char_traits<char> >' to 'TBuffer &' for 1st argument
inline TBuffer &operator<<(TBuffer &buf, const TArrayS *obj)
                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/basic_string.h:6458:5: note: candidate template ignored: couldn't infer template argument '_Alloc'
    operator<<(basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bitset:1540:5: note: candidate template ignored: couldn't infer template argument '_Nb'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:773:5: note: candidate template ignored: couldn't infer template argument '_Tp'
    operator<<(_Ostream&& __os, const _Tp& __x)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/complex:554:5: note: candidate template ignored: couldn't infer template argument '_Tp'
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/cstddef:125:5: note: candidate template ignored: couldn't infer template argument '_IntegerType'
    operator<<(byte __b, _IntegerType __shift) noexcept
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/shared_ptr.h:69:5: note: candidate template ignored: couldn't infer template argument '_Tp'
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/iomanip:311:5: note: candidate template ignored: couldn't infer template argument '_MoneyT'
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_money<_MoneyT> __f)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.h:1300:5: note: candidate template ignored: couldn't infer template argument '_RandomNumberEngine'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:154:5: note: candidate template ignored: couldn't infer template argument '_UIntType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:474:5: note: candidate template ignored: couldn't infer template argument '_UIntType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:628:5: note: candidate template ignored: couldn't infer template argument '_UIntType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:696:5: note: candidate template ignored: couldn't infer template argument '_RandomNumberEngine'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:823:5: note: candidate template ignored: couldn't infer template argument '_RandomNumberEngine'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:867:5: note: candidate template ignored: couldn't infer template argument '_IntType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:925:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:1067:5: note: candidate template ignored: couldn't infer template argument '_IntType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:1181:5: note: candidate template ignored: couldn't infer template argument '_IntType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:1391:5: note: candidate template ignored: couldn't infer template argument '_IntType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:1657:5: note: candidate template ignored: couldn't infer template argument '_IntType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:1719:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:1885:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:1952:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:2024:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:2110:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:2185:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:2259:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:2428:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:2504:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:2578:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:2713:5: note: candidate template ignored: couldn't infer template argument '_IntType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:2934:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/random.tcc:3139:5: note: candidate template ignored: couldn't infer template argument '_RealType'
    operator<<(std::basic_ostream<_CharT, _Traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/regex.h:1647:5: note: candidate template ignored: couldn't infer template argument '_Bi_iter'
    operator<<(basic_ostream<_Ch_type, _Ch_traits>& __os,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:413:5: note: candidate template ignored: couldn't infer template argument '_Dom'
    _DEFINE_EXPR_BINARY_OPERATOR(<<, __shift_left)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:370:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const typename _Dom::value_type& __t,                  \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:413:5: note: candidate template ignored: couldn't infer template argument '_Dom'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:396:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const valarray<typename _Dom::value_type>& __v,        \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1193:1: note: candidate template ignored: couldn't infer template argument '_Tp'
_DEFINE_BINARY_OPERATOR(<<, __shift_left)
^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1177:5: note: expanded from macro '_DEFINE_BINARY_OPERATOR'
    operator _Op(const typename valarray<_Tp>::value_type& __t,         \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBuffer.h:399:32: note: candidate template ignored: couldn't infer template argument 'Tmpl'
template <class Tmpl> TBuffer &operator<<(TBuffer &buf, const Tmpl *obj)
                               ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:413:5: note: candidate template ignored: could not match '_Expr' against 'basic_ostream'
    _DEFINE_EXPR_BINARY_OPERATOR(<<, __shift_left)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:344:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const _Expr<_Dom1, typename _Dom1::value_type>& __v,   \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:413:5: note: candidate template ignored: could not match '_Expr' against 'basic_ostream'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:357:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const _Expr<_Dom, typename _Dom::value_type>& __v,     \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:413:5: note: candidate template ignored: could not match '_Expr' against 'basic_ostream'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:383:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const _Expr<_Dom,typename _Dom::value_type>& __e,      \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1193:1: note: candidate template ignored: could not match 'valarray' against 'basic_ostream'
_DEFINE_BINARY_OPERATOR(<<, __shift_left)
^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1155:5: note: expanded from macro '_DEFINE_BINARY_OPERATOR'
    operator _Op(const valarray<_Tp>& __v, const valarray<_Tp>& __w)    \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1193:1: note: candidate template ignored: could not match 'valarray' against 'basic_ostream'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1166:5: note: expanded from macro '_DEFINE_BINARY_OPERATOR'
    operator _Op(const valarray<_Tp>& __v,                              \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/RooFitHS3/JSONInterface.h:137:17: note: candidate template ignored: could not match 'vector' against 'basic_ostream'
std::vector<T> &operator<<(std::vector<T> &v, RooFit::Experimental::JSONNode const &n)
                ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class o2::base::PropagatorImpl with content:

#line 1 "G__O2DetectorsBase dictionary payload"

#ifndef ZDC_FASTSIM_ONNX
  #define ZDC_FASTSIM_ONNX 1
#endif
#ifndef ENABLE_UPGRADES
  #define ENABLE_UPGRADES 1
#endif
#ifndef FMT_LOCALE
  #define FMT_LOCALE 1
#endif
#ifndef FMT_SHARED
  #define FMT_SHARED 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_IOSTREAMS_DYN_LINK
  #define BOOST_IOSTREAMS_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef FAIRMQ_HAS_STD_FILESYSTEM
  #define FAIRMQ_HAS_STD_FILESYSTEM 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_CONTAINER_DYN_LINK
  #define BOOST_CONTAINER_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_PROGRAM_OPTIONS_DYN_LINK
  #define BOOST_PROGRAM_OPTIONS_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_FILESYSTEM_DYN_LINK
  #define BOOST_FILESYSTEM_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_REGEX_DYN_LINK
  #define BOOST_REGEX_DYN_LINK 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef DPL_ENABLE_BACKTRACE
  #define DPL_ENABLE_BACKTRACE 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_SERIALIZATION_DYN_LINK
  #define BOOST_SERIALIZATION_DYN_LINK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Detector.h
/// \brief Definition of the Detector class

#ifndef ALICEO2_BASE_DETECTOR_H_
#define ALICEO2_BASE_DETECTOR_H_

#include <map>
#include <tbb/concurrent_unordered_map.h>
#include <vector>
#include <initializer_list>
#include <memory>

#include "FairDetector.h" // for FairDetector
#include "FairRootManager.h"
#include "DetectorsBase/MaterialManager.h"
#include "Rtypes.h" // for Float_t, Int_t, Double_t, Detector::Class, etc
#include <cxxabi.h>
#include <typeinfo>
#include <type_traits>
#include <string>
#include <TMessage.h>
#include "CommonUtils/ShmManager.h"
#include "CommonUtils/ShmAllocator.h"
#include <sys/shm.h>
#include <type_traits>
#include <unistd.h>
#include <cassert>
#include <list>
#include <mutex>
#include <thread>

#include <fairmq/FwdDecls.h>

namespace o2
{
namespace base
{

/// This is the basic class for any AliceO2 detector module, whether it is
/// sensitive or not. Detector classes depend on this.
class Detector : public FairDetector
{

 public:
  Detector(const char* name, Bool_t Active);

  /// Default Constructor
  Detector();

  /// Default Destructor
  ~Detector() override;

  // Module composition
  void Material(Int_t imat, const char* name, Float_t a, Float_t z, Float_t dens, Float_t radl, Float_t absl,
                Float_t* buf = nullptr, Int_t nwbuf = 0);

  void Mixture(Int_t imat, const char* name, Float_t* a, Float_t* z, Float_t dens, Int_t nlmat,
               Float_t* wmat);

  void Medium(Int_t numed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Float_t fieldm,
              Float_t tmaxfd, Float_t stemax, Float_t deemax, Float_t epsil, Float_t stmin, Float_t* ubuf = nullptr,
              Int_t nbuf = 0);

  /// Custom processes and transport cuts
  void SpecialCuts(Int_t numed, const std::initializer_list<std::pair<ECut, Float_t>>& parIDValMap);
  /// Set cut by name and value
  void SpecialCut(Int_t numed, ECut parID, Float_t val);

  void SpecialProcesses(Int_t numed, const std::initializer_list<std::pair<EProc, int>>& parIDValMap);
  /// Set process by name and value
  void SpecialProcess(Int_t numed, EProc parID, int val);

  /// Define a rotation matrix. angles are in degrees.
  /// \param nmat on output contains the number assigned to the rotation matrix
  /// \param theta1 polar angle for axis I
  /// \param theta2 polar angle for axis II
  /// \param theta3 polar angle for axis III
  /// \param phi1 azimuthal angle for axis I
  /// \param phi2 azimuthal angle for axis II
  /// \param phi3 azimuthal angle for axis III
  void Matrix(Int_t& nmat, Float_t theta1, Float_t phi1, Float_t theta2, Float_t phi2, Float_t theta3,
              Float_t phi3) const;

  static void setDensityFactor(Float_t density)
  {
    mDensityFactor = density;
  }

  static Float_t getDensityFactor()
  {
    return mDensityFactor;
  }

  /// implements interface of FairModule;
  /// generic implementation for O2 detectors
  void SetSpecialPhysicsCuts() override;

  /// declare alignable volumes of detector
  virtual void addAlignableVolumes() const;

  /// Sets per wrapper volume parameters
  virtual void defineWrapperVolume(Int_t id, Double_t rmin, Double_t rmax, Double_t zspan);

  /// Books arrays for wrapper volumes
  virtual void setNumberOfWrapperVolumes(Int_t n);

  virtual void defineLayer(Int_t nlay, Double_t phi0, Double_t r, Int_t nladd, Int_t nmod,
                           Double_t lthick = 0., Double_t dthick = 0., UInt_t detType = 0, Int_t buildFlag = 0);

  virtual void defineLayerTurbo(Int_t nlay, Double_t phi0, Double_t r, Int_t nladd, Int_t nmod,
                                Double_t width, Double_t tilt, Double_t lthick = 0., Double_t dthick = 0.,
                                UInt_t detType = 0, Int_t buildFlag = 0);

  // returns global material ID given a "local" material ID for this detector
  // returns -1 in case local ID not found
  int getMaterialID(int imat) const
  {
    auto& mgr = o2::base::MaterialManager::Instance();
    return mgr.getMaterialID(GetName(), imat);
  }

  // returns global medium ID given a "local" medium ID for this detector
  // returns -1 in case local ID not found
  int getMediumID(int imed) const
  {
    auto& mgr = o2::base::MaterialManager::Instance();
    return mgr.getMediumID(GetName(), imed);
  }

  // fill the medium index mapping into a standard vector
  // the vector gets sized properly and will be overridden
  void getMediumIDMappingAsVector(std::vector<int>& mapping)
  {
    auto& mgr = o2::base::MaterialManager::Instance();
    mgr.getMediumIDMappingAsVector(GetName(), mapping);
  }

  // return the name augmented by extension
  std::string addNameTo(const char* ext) const
  {
    std::string s(GetName());
    return s + ext;
  }

  // returning the name of the branch (corresponding to probe)
  // returns zero length string when probe not defined
  virtual std::string getHitBranchNames(int probe) const = 0;

  // interface to update track indices of data objects
  // usually called by the Stack, at the end of an event, which might have changed
  // the track indices due to filtering
  // FIXME: make private friend of stack?
  virtual void updateHitTrackIndices(std::map<int, int> const&) = 0;

  // interfaces to attach properly encoded hit information to a FairMQ message
  // and to decode it
  virtual void attachHits(fair::mq::Channel&, fair::mq::Parts&) = 0;
  virtual void fillHitBranch(TTree& tr, fair::mq::Parts& parts, int& index) = 0;
  virtual void collectHits(int eventID, fair::mq::Parts& parts, int& index) = 0;
  virtual void mergeHitEntriesAndFlush(int eventID,
                                       TTree& target,
                                       std::vector<int> const& trackoffsets,
                                       std::vector<int> const& nprimaries,
                                       std::vector<int> const& subevtsOrdered) = 0;

  // interface needed to merge together hit entries in TBranches (as used by hit merger process)
  // trackoffsets: a map giving the corresponding trackoffset to be applied to the trackID property when
  // merging
  virtual void mergeHitEntries(TTree& origin, TTree& target, std::vector<int> const& trackoffsets, std::vector<int> const& nprimaries, std::vector<int> const& subevtsOrdered) = 0;

  // hook which is called automatically to custom initialize the O2 detectors
  // all initialization not able to do in constructors should be done here
  // (typically the case for geometry related stuff, etc)
  virtual void InitializeO2Detector() = 0;

  // the original FairModule/Detector virtual Initialize function
  // calls individual customized initializations and makes sure that the mother Initialize
  // is called as well. Marked final for this reason!
  void Initialize() final
  {
    InitializeO2Detector();
    // make sure the basic initialization is also done
    FairDetector::Initialize();
  }

  // a second initialization method for stuff that should be initialized late
  // (in our case after forking off from the main simulation setup
  // ... for things that should be setup in each simulation worker separately)
  virtual void initializeLate() = 0;

  /// helper wrapper function to register a geometry volume given by name with FairRoot
  /// @returns The MonteCarlo ID for the volume
  int registerSensitiveVolumeAndGetVolID(std::string const& name);

  /// helper wrapper function to register a geometry volume given by TGeoVolume vol
  /// @returns The MonteCarlo ID for the volume
  int registerSensitiveVolumeAndGetVolID(TGeoVolume const* vol);

  // The GetCollection interface is made final and deprecated since
  // we no longer support TClonesArrays
  [[deprecated("Use getHits API on concrete detectors!")]] TClonesArray* GetCollection(int iColl) const final;

  // static and reusable service function to set tracking parameters in relation to field
  // returns global integration mode (inhomogenety) for the field and the max field value
  // which is required for media creation
  static void initFieldTrackingParams(int& mode, float& maxfield);

 protected:
  Detector(const Detector& origin);

  Detector& operator=(const Detector&);

 private:
  /// Mapping of the ALICE internal material number to the one
  /// automatically assigned by geant/TGeo.
  /// This is required to easily being able to copy the geometry setup
  /// used in AliRoot
  std::map<int, int> mMapMaterial; //!< material mapping

  /// See comment for mMapMaterial
  std::map<int, int> mMapMedium; //!< medium mapping

  static Float_t mDensityFactor; //! factor that is multiplied to all material densities (ONLY for
  // systematic studies)

  ClassDefOverride(Detector, 1); // Base class for ALICE Modules
};

/// utility function to demangle cxx type names
inline std::string demangle(const char* name)
{
  int status = -4; // some arbitrary value to eliminate compiler warnings
  std::unique_ptr<char, void (*)(void*)> res{abi::__cxa_demangle(name, nullptr, nullptr, &status), std::free};
  return (status == 0) ? res.get() : name;
}

void attachShmMessage(void* hitsptr, fair::mq::Channel& channel, fair::mq::Parts& parts, bool* busy_ptr);
void* decodeShmCore(fair::mq::Parts& dataparts, int index, bool*& busy);

template <typename T>
T decodeShmMessage(fair::mq::Parts& dataparts, int index, bool*& busy)
{
  return reinterpret_cast<T>(decodeShmCore(dataparts, index, busy));
}

// this goes into the source
void attachMessageBufferToParts(fair::mq::Parts& parts, fair::mq::Channel& channel,
                                void* data, size_t size, void (*func_ptr)(void* data, void* hint), void* hint);

template <typename Container>
void attachTMessage(Container const& hits, fair::mq::Channel& channel, fair::mq::Parts& parts)
{
  TMessage* tmsg = new TMessage();
  tmsg->WriteObjectAny((void*)&hits, TClass::GetClass(typeid(hits)));
  attachMessageBufferToParts(
    parts, channel, tmsg->Buffer(), tmsg->BufferSize(),
    [](void* data, void* hint) { delete static_cast<TMessage*>(hint); }, tmsg);
}

void* decodeTMessageCore(fair::mq::Parts& dataparts, int index);
template <typename T>
T decodeTMessage(fair::mq::Parts& dataparts, int index)
{
  return static_cast<T>(decodeTMessageCore(dataparts, index));
}

void attachDetIDHeaderMessage(int id, fair::mq::Channel& channel, fair::mq::Parts& parts);

template <typename T>
TBranch* getOrMakeBranch(TTree& tree, const char* brname, T* ptr)
{
  if (auto br = tree.GetBranch(brname)) {
    br->SetAddress(static_cast<void*>(&ptr));
    return br;
  }
  // otherwise make it
  return tree.Branch(brname, ptr);
}

// a trait to determine if we should use shared mem or serialize using TMessage
template <typename Det>
struct UseShm {
  static constexpr bool value = false;
};

// an implementation helper template which automatically implements
// common functionality for deriving classes via the CRT pattern
// (example: it implements the updateHitTrackIndices function and avoids
// code duplication, while at the same time avoiding virtual function calls)
template <typename Det>
class DetImpl : public o2::base::Detector
{
 public:
  // offer same constructors as base
  using Detector::Detector;

  // default implementation for getHitBranchNames
  std::string getHitBranchNames(int probe) const override
  {
    if (probe == 0) {
      return addNameTo("Hit");
    }
    return std::string(); // empty string as undefined
  }

  // generic implementation for the updateHitTrackIndices interface
  // assumes Detectors have a GetHits(int) function that return some iterable
  // hits which are o2::BaseHits
  void updateHitTrackIndices(std::map<int, int> const& indexmapping) override
  {
    int probe = 0; // some Detectors have multiple hit vectors and we are probing
                   // them via a probe integer until we get a nullptr
    while (auto hits = static_cast<Det*>(this)->Det::getHits(probe++)) {
      for (auto& hit : *hits) {
        auto iter = indexmapping.find(hit.GetTrackID());
        hit.SetTrackID(iter->second);
      }
    }
  }

  void attachHits(fair::mq::Channel& channel, fair::mq::Parts& parts) override
  {
    int probe = 0;
    // check if there is anything to be attached
    // at least the first hit index should return non nullptr
    if (static_cast<Det*>(this)->Det::getHits(0) == nullptr) {
      return;
    }

    attachDetIDHeaderMessage(GetDetId(), channel, parts); // the DetId s are universal as they come from o2::detector::DetID

    while (auto hits = static_cast<Det*>(this)->Det::getHits(probe++)) {
      if (!UseShm<Det>::value || !o2::utils::ShmManager::Instance().isOperational()) {
        attachTMessage(*hits, channel, parts);
      } else {
        // this is the shared mem variant
        // we will just send the sharedmem ID and the offset inside
        *mShmBusy[mCurrentBuffer] = true;
        attachShmMessage((void*)hits, channel, parts, mShmBusy[mCurrentBuffer]);
      }
    }
  }

  // this merges several entries from the TBranch brname from the origin TTree
  // into a single entry in a target TTree / same branch
  // (assuming T is typically a vector; merging is simply done by appending)
  // make this function a (static helper)
  template <typename T>
  void mergeAndAdjustHits(std::string const& brname, TTree& origin, TTree& target,
                          std::vector<int> const& trackoffsets, std::vector<int> const& nprimaries, std::vector<int> const& subevtsOrdered)
  {
    auto originbr = origin.GetBranch(brname.c_str());
    if (originbr) {
      auto targetdata = new T;
      T* incomingdata = nullptr;
      originbr->SetAddress(&incomingdata);

      T* filladdress = nullptr;
      if (origin.GetEntries() == 1) {
        originbr->GetEntry(0);
        filladdress = incomingdata;
      } else {
        Int_t entries = origin.GetEntries();
        Int_t nprimTot = 0;
        for (auto entry = 0; entry < entries; entry++) {
          nprimTot += nprimaries[entry];
        }
        // offset for pimary track index
        Int_t idelta0 = 0;
        // offset for secondary track index
        Int_t idelta1 = nprimTot;
        for (int entry = entries - 1; entry >= 0; --entry) {
          // proceed in the order of subevent Ids
          Int_t index = subevtsOrdered[entry];
          // numbe of primaries for this event
          Int_t nprim = nprimaries[index];
          idelta1 -= nprim;
          filladdress = targetdata;
          originbr->GetEntry(index);
          if (incomingdata) {
            // fix the trackIDs for this data
            for (auto& hit : *incomingdata) {
              const auto oldID = hit.GetTrackID();
              // offset depends on whether the trackis a primary or secondary
              Int_t offset = (oldID < nprim) ? idelta0 : idelta1;
              hit.SetTrackID(oldID + offset);
            }
            // this could be further generalized by using a policy for T
            std::copy(incomingdata->begin(), incomingdata->end(), std::back_inserter(*targetdata));
            delete incomingdata;
            incomingdata = nullptr;
          }
          // adjust offsets for next subevent
          idelta0 += nprim;
          idelta1 += trackoffsets[index];
        } // subevent loop
      }
      // fill target for this event
      auto targetbr = o2::base::getOrMakeBranch(target, brname.c_str(), &filladdress);
      targetbr->SetAddress(&filladdress);
      targetbr->Fill();
      targetbr->ResetAddress();
      targetdata->clear();
      if (incomingdata) {
        delete incomingdata;
        incomingdata = nullptr;
      }
      delete targetdata;
    }
  }

  // this merges several entries from temporary hit buffer into
  // into a single entry in a target TTree / same branch
  // (assuming T is typically a vector; merging is simply done by appending)
  template <typename T, typename L>
  void mergeAndAdjustHits(std::string const& brname, L& hitbuffervector, TTree& target,
                          std::vector<int> const& trackoffsets, std::vector<int> const& nprimaries,
                          std::vector<int> const& subevtsOrdered)
  {
    auto entries = hitbuffervector.size();

    auto targetdata = new T;  // used to collect data inside a single container
    T* filladdress = nullptr; // pointer used for final ROOT IO
    if (entries == 1) {
      filladdress = hitbuffervector[0].get();
      // nothing to do; we can directly do IO from the existing buffer
    } else {
      // here we need to do merging and index adjustment
      int nprimTot = 0;
      for (auto entry = 0; entry < entries; entry++) {
        nprimTot += nprimaries[entry];
      }
      // offset for pimary track index
      int idelta0 = 0;
      // offset for secondary track index
      int idelta1 = nprimTot;
      filladdress = targetdata;
      for (int entry = entries - 1; entry >= 0; --entry) {
        // proceed in the order of subevent Ids
        int index = subevtsOrdered[entry];
        // number of primaries for this event
        int nprim = nprimaries[index];
        idelta1 -= nprim;

        // fetch correct data item
        auto incomingdata = hitbuffervector[index].get();
        if (incomingdata) {
          // fix the trackIDs for this data
          for (auto& hit : *incomingdata) {
            const auto oldID = hit.GetTrackID();
            // offset depends on whether the trackis a primary or secondary
            int offset = (oldID < nprim) ? idelta0 : idelta1;
            hit.SetTrackID(oldID + offset);
          }
          // this could be further generalized by using a policy for T
          std::copy(incomingdata->begin(), incomingdata->end(), std::back_inserter(*targetdata));
        }
        // adjust offsets for next subevent
        idelta0 += nprim;
        idelta1 += trackoffsets[index];
      } // subevent loop
    }
    // fill target for this event
    auto targetbr = o2::base::getOrMakeBranch(target, brname.c_str(), &filladdress);
    targetbr->SetAddress(&filladdress);
    targetbr->Fill();
    targetbr->ResetAddress();
    targetdata->clear();
    hitbuffervector.clear();
    hitbuffervector = L(); // swap with empty vector to release mem
    delete targetdata;
  }

  void mergeHitEntries(TTree& origin, TTree& target, std::vector<int> const& trackoffsets, std::vector<int> const& nprimaries, std::vector<int> const& subevtsOrdered) final
  {
    // loop over hit containers / different branches
    // adjust trackID in hits on the go
    int probe = 0;
    using Hit_t = decltype(static_cast<Det*>(this)->Det::getHits(probe));
    std::string name = static_cast<Det*>(this)->getHitBranchNames(probe++);
    while (name.size() > 0) {
      mergeAndAdjustHits<typename std::remove_pointer<Hit_t>::type>(name, origin, target, trackoffsets, nprimaries, subevtsOrdered);
      // next name
      name = static_cast<Det*>(this)->getHitBranchNames(probe++);
    }
  }

  void mergeHitEntriesAndFlush(int eventID, TTree& target, std::vector<int> const& trackoffsets, std::vector<int> const& nprimaries, std::vector<int> const& subevtsOrdered) final
  {
    // loop over hit containers / different branches
    // adjust trackID in hits on the go
    int probe = 0;
    using Hit_t = typename std::remove_pointer<decltype(static_cast<Det*>(this)->Det::getHits(0))>::type;
    // remove buffered event from the hit store
    using Collector_t = tbb::concurrent_unordered_map<int, std::vector<std::vector<std::unique_ptr<Hit_t>>>>;
    auto hitbufferPtr = reinterpret_cast<Collector_t*>(mHitCollectorBufferPtr);
    auto iter = hitbufferPtr->find(eventID);
    if (iter == hitbufferPtr->end()) {
      LOG(error) << "No buffered hits available for event " << eventID;
      return;
    }

    std::string name = static_cast<Det*>(this)->getHitBranchNames(probe);
    while (name.size() > 0) {
      auto& vectorofHitBuffers = (*iter).second[probe];
      // flushing and buffer removal is done inside here:
      mergeAndAdjustHits<Hit_t>(name, vectorofHitBuffers, target, trackoffsets, nprimaries, subevtsOrdered);
      // next name
      probe++;
      name = static_cast<Det*>(this)->getHitBranchNames(probe);
    }
  }

 public:
  /// Collect Hits available as incoming message (shared mem or not)
  /// inside this process for later streaming to output. A function needed
  /// by the hit-merger process (not for direct use by users)
  void collectHits(int eventID, fair::mq::Parts& parts, int& index) override
  {
    using Hit_t = typename std::remove_pointer<decltype(static_cast<Det*>(this)->Det::getHits(0))>::type;
    using Collector_t = tbb::concurrent_unordered_map<int, std::vector<std::vector<std::unique_ptr<Hit_t>>>>;
    static Collector_t hitcollector; // note: we can't put this as member because
    // decltype type deduction doesn't seem to work for class members; so we use a static member
    // and will use some pointer member to communicate this data to other functions
    mHitCollectorBufferPtr = (char*)&hitcollector;

    int probe = 0;
    bool* busy = nullptr;
    using HitPtr_t = decltype(static_cast<Det*>(this)->Det::getHits(probe));
    std::string name = static_cast<Det*>(this)->getHitBranchNames(probe);

    auto copyToBuffer = [this, eventID](HitPtr_t hitdata, Collector_t& collectbuffer, int probe) {
      std::vector<std::vector<std::unique_ptr<Hit_t>>>* hitvector = nullptr;
      {
        auto eventIter = collectbuffer.find(eventID);
        if (eventIter == collectbuffer.end()) {
          // key insertion and traversal are thread-safe with tbb so no need
          // to protect
          collectbuffer[eventID] = std::vector<std::vector<std::unique_ptr<Hit_t>>>();
        }
        hitvector = &(collectbuffer[eventID]);
      }
      if (probe >= hitvector->size()) {
        hitvector->resize(probe + 1);
      }
      // add empty hit bucket to list for this event and probe
      (*hitvector)[probe].emplace_back(new Hit_t());
      // copy the data into this bucket
      *((*hitvector)[probe].back()) = *hitdata;
    };

    while (name.size() > 0) {
      if (!UseShm<Det>::value || !o2::utils::ShmManager::Instance().isOperational()) {
        // for each branch name we extract/decode hits from the message parts ...
        auto hitsptr = decodeTMessage<HitPtr_t>(parts, index++);
        if (hitsptr) {
          // ... and copy them to the buffer
          copyToBuffer(hitsptr, hitcollector, probe);
          delete hitsptr;
        }
      } else {
        // for each branch name we extract/decode hits from the message parts ...
        auto hitsptr = decodeShmMessage<HitPtr_t>(parts, index++, busy);
        // ... and copy them to the buffer
        copyToBuffer(hitsptr, hitcollector, probe);
      }
      // next name
      probe++;
      name = static_cast<Det*>(this)->getHitBranchNames(probe);
    }
    // there is only one busy flag per detector so we need to clear it only
    // at the end (after all branches have been treated)
    if (busy) {
      *busy = false;
    }
  }

  void fillHitBranch(TTree& tr, fair::mq::Parts& parts, int& index) override
  {
    int probe = 0;
    bool* busy = nullptr;
    using Hit_t = decltype(static_cast<Det*>(this)->Det::getHits(probe));
    std::string name = static_cast<Det*>(this)->getHitBranchNames(probe++);
    while (name.size() > 0) {
      if (!UseShm<Det>::value || !o2::utils::ShmManager::Instance().isOperational()) {

        // for each branch name we extract/decode hits from the message parts ...
        auto hitsptr = decodeTMessage<Hit_t>(parts, index++);
        if (hitsptr) {
          // ... and fill the tree branch
          auto br = getOrMakeBranch(tr, name.c_str(), hitsptr);
          br->SetAddress(static_cast<void*>(&hitsptr));
          br->Fill();
          br->ResetAddress();
          delete hitsptr;
        }
      } else {
        // for each branch name we extract/decode hits from the message parts ...
        auto hitsptr = decodeShmMessage<Hit_t>(parts, index++, busy);
        // ... and fill the tree branch
        auto br = getOrMakeBranch(tr, name.c_str(), hitsptr);
        br->SetAddress(static_cast<void*>(&hitsptr));
        br->Fill();
        br->ResetAddress();
      }
      // next name
      name = static_cast<Det*>(this)->getHitBranchNames(probe++);
    }
    // there is only one busy flag per detector so we need to clear it only
    // at the end (after all branches have been treated)
    if (busy) {
      *busy = false;
    }
  }

  // implementing CloneModule (for G4-MT mode) automatically for each deriving
  // Detector class "Det"; calls copy constructor of Det
  FairModule* CloneModule() const final
  {
    return new Det(static_cast<const Det&>(*this));
  }

  void freeHitBuffers()
  {
    using Hit_t = decltype(static_cast<Det*>(this)->Det::getHits(0));
    if (UseShm<Det>::value) {
      for (int buffer = 0; buffer < NHITBUFFERS; ++buffer) {
        for (auto ptr : mCachedPtr[buffer]) {
          o2::utils::freeSimVector(static_cast<Hit_t>(ptr));
        }
      }
    }
  }

  // default implementation for setting hits
  // always returns false indicating that there is no other
  // component to assign to apart from i == 0
  template <typename Hit_t>
  bool setHits(int i, std::vector<Hit_t>* ptr)
  {
    if (i == 0) {
      static_cast<Det*>(this)->Det::mHits = ptr;
    }
    return false;
  }

  // creating a number of hit buffers (in shared mem) -- to which
  // detectors can write in round-robin fashion
  void createHitBuffers()
  {
    using VectorHit_t = decltype(static_cast<Det*>(this)->Det::getHits(0));
    using Hit_t = typename std::remove_pointer<VectorHit_t>::type::value_type;
    for (int buffer = 0; buffer < NHITBUFFERS; ++buffer) {
      int probe = 0;
      bool more{false};
      do {
        auto ptr = o2::utils::createSimVector<Hit_t>();
        more = static_cast<Det*>(this)->Det::setHits(probe, ptr);
        mCachedPtr[buffer].emplace_back(ptr);
        probe++;
      } while (more);
    }
  }

  void initializeLate() final
  {
    if (!mInitialized) {
      if (UseShm<Det>::value) {
        static_cast<Det*>(this)->Det::createHitBuffers();
        for (int b = 0; b < NHITBUFFERS; ++b) {
          auto& instance = o2::utils::ShmManager::Instance();
          mShmBusy[b] = instance.hasSegment() ? (bool*)instance.getmemblock(sizeof(bool)) : new bool;
          *mShmBusy[b] = false;
        }
      }
      mInitialized = true;
      mCurrentBuffer = 0;
    }
  }

  void BeginEvent() final
  {
    if (UseShm<Det>::value) {
      mCurrentBuffer = (mCurrentBuffer + 1) % NHITBUFFERS;
      while (mShmBusy[mCurrentBuffer] != nullptr && *mShmBusy[mCurrentBuffer]) {
        // this should ideally never happen
        LOG(info) << " BUSY WAITING SIZE ";
        sleep(1);
      }

      using Hit_t = decltype(static_cast<Det*>(this)->Det::getHits(0));

      // now we have to clear the hits before writing again
      int probe = 0;
      for (auto bareptr : mCachedPtr[mCurrentBuffer]) {
        auto hits = static_cast<Hit_t>(bareptr);
        // assign ..
        static_cast<Det*>(this)->Det::setHits(probe, hits);
        hits->clear();
        probe++;
      }
    }
  }

  ~DetImpl() override
  {
    for (int i = 0; i < NHITBUFFERS; ++i) {
      if (mShmBusy[i]) {
        auto& instance = o2::utils::ShmManager::Instance();
        if (instance.hasSegment()) {
          instance.freememblock(mShmBusy[i]);
        } else {
          delete mShmBusy[i];
        }
      }
    }
    freeHitBuffers();
  }

 protected:
  static constexpr int NHITBUFFERS = 3;    // number of buffers for hits in order to allow async processing
                                           // in the hit merger without blocking nor copying the data
                                           // (like done in typical data aquisition systems)
  bool* mShmBusy[NHITBUFFERS] = {nullptr}; //! pointer to bool in shared mem indicating of IO busy
  std::vector<void*> mCachedPtr[NHITBUFFERS];
  int mCurrentBuffer = 0; // holding the current buffer information
  int mInitialized = false;

  char* mHitCollectorBufferPtr = nullptr; //! pointer to hit (collector) buffer location (strictly internal)
  ClassDefOverride(DetImpl, 0);
};
} // namespace base
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file GeometryManager.h
/// \brief Definition of the GeometryManager class

#ifndef ALICEO2_BASE_GEOMETRYMANAGER_H_
#define ALICEO2_BASE_GEOMETRYMANAGER_H_

#include <TGeoManager.h> // for TGeoManager
#include <TGeoMaterial.h>
#include <TGeoPhysicalNode.h> // for TGeoPNEntry
#include <TGeoShape.h>
#include <TMath.h>
#include <TObject.h> // for TObject
#include <string_view>
#include "DetectorsCommonDataFormats/DetID.h"
#include "GPUCommonLogger.h" // for LOG
#include "MathUtils/Cartesian.h"
#include "DetectorsBase/MatCell.h"
#include <mutex>
class TGeoHMatrix; // lines 11-11
class TGeoManager; // lines 9-9

namespace o2
{
namespace detectors
{
class AlignParam;
}

namespace base
{
/// Class for interfacing to the geometry; it also builds and manages the look-up tables for fast
/// access to geometry and alignment information for sensitive alignable volumes:
/// 1) the look-up table mapping unique volume ids to TGeoPNEntries. This allows to access
/// directly by means of the unique index the associated symbolic name and original global matrix
/// in addition to the functionality of the physical node associated to a given alignable volume
/// 2) the look-up table of the alignment objects associated to the indexed alignable volumes
class GeometryManager : public TObject
{
 public:
  ///< load geometry from file
  ///< When applyMisalignedment == false --> read from unaligned file
  ///< When preferAlignedFile == true and applyMisalignment == true : Prefer reading from existing aligned file
  static void loadGeometry(std::string_view geomFilePath = "", bool applyMisalignment = false, bool preferAlignedFile = true);
  static bool isGeometryLoaded() { return gGeoManager != nullptr; }
  static void applyMisalignent(bool applyMisalignment = true);

  ///< Get the global transformation matrix (ideal geometry) for a given alignable volume
  ///< The alignable volume is identified by 'symname' which has to be either a valid symbolic
  ///< name, the query being performed after alignment, or a valid volume path if the query is
  ///< performed before alignment.
  static Bool_t getOriginalMatrix(o2::detectors::DetID detid, int sensid, TGeoHMatrix& m);
  static Bool_t getOriginalMatrix(const char* symname, TGeoHMatrix& m);
  static TGeoHMatrix* getMatrix(const char* symname);
  static const char* getSymbolicName(o2::detectors::DetID detid, int sensid);
  static TGeoPNEntry* getPNEntry(o2::detectors::DetID detid, Int_t sensid);
  static TGeoHMatrix* getMatrix(o2::detectors::DetID detid, Int_t sensid);

  static int getSensID(o2::detectors::DetID detid, int sensid)
  {
    /// compose combined detector+sensor ID for sensitive volumes
    return (detid << sDetOffset) | (sensid & sSensorMask);
  }

  /// Default destructor
  ~GeometryManager() override = default;

  /// misalign geometry with alignment objects from the array, optionaly check overlaps
  static bool applyAlignment(const std::vector<o2::detectors::AlignParam>& algPars);
  static bool applyAlignment(const std::vector<const std::vector<o2::detectors::AlignParam>*> algPars);

  struct MatBudgetExt {
    double meanRho = 0.;  // mean density: sum(x_i*rho_i)/sum(x_i) [g/cm3]
    double meanX2X0 = 0.; // equivalent rad length fraction: sum(x_i/X0_i) [adimensional]
    double meanA = 0.;    // mean A: sum(x_i*A_i)/sum(x_i) [adimensional]
    double meanZ = 0.;    // mean Z: sum(x_i*Z_i)/sum(x_i) [adimensional]
    double meanZ2A = 0.;  // Z/A mean: sum(x_i*Z_i/A_i)/sum(x_i) [adimensional]
    double length = -1.;  // length: sum(x_i) [cm]
    int nCross = 0;
    ; // number of boundary crosses

    MatBudgetExt() = default;
    ~MatBudgetExt() = default;
    MatBudgetExt(const MatBudgetExt& src) = default;
    MatBudgetExt& operator=(const MatBudgetExt& src) = default;
    void normalize(double nrm);
    ClassDefNV(MatBudgetExt, 1);
  };

  static o2::base::MatBudget meanMaterialBudget(float x0, float y0, float z0, float x1, float y1, float z1);
  static o2::base::MatBudget meanMaterialBudget(const math_utils::Point3D<float>& start, const math_utils::Point3D<float>& end)
  {
    return meanMaterialBudget(start.X(), start.Y(), start.Z(), end.X(), end.Y(), end.Z());
  }
  static o2::base::MatBudget meanMaterialBudget(const math_utils::Point3D<double>& start, const math_utils::Point3D<double>& end)
  {
    return meanMaterialBudget(start.X(), start.Y(), start.Z(), end.X(), end.Y(), end.Z());
  }

  static MatBudgetExt meanMaterialBudgetExt(float x0, float y0, float z0, float x1, float y1, float z1);
  static MatBudgetExt meanMaterialBudgetExt(const math_utils::Point3D<float>& start, const math_utils::Point3D<float>& end)
  {
    return meanMaterialBudgetExt(start.X(), start.Y(), start.Z(), end.X(), end.Y(), end.Z());
  }
  static MatBudgetExt meanMaterialBudgetExt(const math_utils::Point3D<double>& start, const math_utils::Point3D<double>& end)
  {
    return meanMaterialBudgetExt(start.X(), start.Y(), start.Z(), end.X(), end.Y(), end.Z());
  }

 private:
  /// Default constructor
  GeometryManager() = default;
  static TGeoHMatrix* getMatrix(TGeoPNEntry* pne);
  static void accountMaterial(const TGeoMaterial* material, MatBudgetExt& bd);
  static void accountMaterial(const TGeoMaterial* material, o2::base::MatBudget& bd)
  {
    bd.meanRho = material->GetDensity();
    bd.meanX2X0 = material->GetRadLen();
  }

  /// The method returns the global matrix for the volume identified by 'path' in the ideal
  /// detector geometry. The output global matrix is stored in 'm'.
  /// Returns kFALSE in case TGeo has not been initialized or the volume path is not valid.
  static Bool_t getOriginalMatrixFromPath(const char* path, TGeoHMatrix& m);
 private:
  /// sensitive volume identifier composed from (det_ID<<sDetOffset)|(sensid&sSensorMask)
  static constexpr UInt_t sDetOffset = 15; /// detector identifier will start from this bit
  static constexpr UInt_t sSensorMask =
    (0x1 << sDetOffset) - 1; /// mask=max sensitive volumes allowed per detector (0xffff)
  static std::mutex sTGMutex;

  ClassDefOverride(GeometryManager, 0); // Manager of geometry information for alignment
};
} // namespace base
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Detector.h
/// \brief Definition of the MaterialManager class

#ifndef ALICEO2_BASE_MATERIALMANAGER_H_
#define ALICEO2_BASE_MATERIALMANAGER_H_

#include "Rtypes.h"
#include <map>
#include <unordered_map>
#include <initializer_list>
#include <iosfwd>

class TGeoMedium;

namespace o2
{
namespace base
{
// put processes and cuts in namespace to make them available from there
/// processes available
enum class EProc { kPAIR = 0,
                   kCOMP,
                   kPHOT,
                   kPFIS,
                   kDRAY,
                   kANNI,
                   kBREM,
                   kHADR,
                   kMUNU,
                   kDCAY,
                   kLOSS,
                   kMULS,
                   kCKOV,
                   kLABS,
                   kRAYL
};

/// cuts available
enum class ECut { kCUTGAM = 0,
                  kCUTELE,
                  kCUTNEU,
                  kCUTHAD,
                  kCUTMUO,
                  kBCUTE,
                  kBCUTM,
                  kDCUTE,
                  kDCUTM,
                  kPPCUTM,
                  kTOFMAX };
// Central class managing creation of material, mixtures, mediums through
// the VMC interface. All material creations should go through this class.
// Also manages material indices and offers ways to retrieve them
// given a name (such as a given module name).
class MaterialManager
{
 public:
  static MaterialManager& Instance()
  {
    static MaterialManager inst;
    return inst;
  }

  // Module composition
  void Material(const char* modname, Int_t imat, const char* name, Float_t a, Float_t z, Float_t dens, Float_t radl,
                Float_t absl, Float_t* buf = nullptr, Int_t nwbuf = 0);

  void Mixture(const char* modname, Int_t imat, const char* name, Float_t* a, Float_t* z, Float_t dens, Int_t nlmat,
               Float_t* wmat);

  void Medium(const char* modname, Int_t numed, const char* name, Int_t nmat, Int_t isvol, Int_t ifield, Float_t fieldm,
              Float_t tmaxfd, Float_t stemax, Float_t deemax, Float_t epsil, Float_t stmin, Float_t* ubuf = nullptr,
              Int_t nbuf = 0);

  /// In Geant3/4 there is the possibility to set custom production cuts and to enable/disable certain processes.
  /// This can be done globally as well as for each medium separately. Hence, for both cases there is one method
  /// to set default processes and cuts and another 2 methods to set cuts and processes per medium. In any case,
  /// the respective cut/process setting method is a wrapper around a private, more general, method.
  /// Global settings of processes.
  //
  /// scoped enum to decide whether settings are done globally or for a certain medium
  enum class ESpecial : bool { kTRUE = true,
                               kFALSE = false };
  void DefaultProcesses(const std::initializer_list<std::pair<EProc, int>>& parIDValMap)
  {
    Processes(ESpecial::kFALSE, -1, parIDValMap);
  }
  /// Set processes per medium providing the module name and the local ID of the medium.
  /// To ignore a certain process to be set explicitly (default or Geant settings will be used in that case) use
  /// o2::base::MaterialManager::NOPROCESS
  void SpecialProcesses(const char* modname, int localindex,
                        const std::initializer_list<std::pair<EProc, int>>& parIDValMap)
  {
    int globalindex = getMediumID(modname, localindex);
    if (globalindex != -1) {
      Processes(ESpecial::kTRUE, globalindex, parIDValMap);
    }
  }
  /// set default process
  void DefaultProcess(EProc parID, int val) { Process(ESpecial::kFALSE, -1, parID, val); }

  /// Custom setting of process or cut given parameter name and value
  void SpecialProcess(const char* modname, int localindex, EProc parID, int val);

  /// Global settings of cuts.
  /// To ignore a certain cut to be set, just set it to o2::base::MaterialManager::NOPROCESS
  void DefaultCuts(const std::initializer_list<std::pair<ECut, Float_t>>& parIDValMap)
  {
    Cuts(ESpecial::kFALSE, -1, parIDValMap);
  }

  /// Set cuts per medium providing the module name and the local ID of the medium.
  /// To ignore a certain cut to be set explicitly (default or Geant settings will be used in that case) use
  /// o2::base::MaterialManager::NOPROCESS
  void SpecialCuts(const char* modname, int localindex,
                   const std::initializer_list<std::pair<ECut, Float_t>>& parIDValMap);

  /// set default cut
  void DefaultCut(ECut parID, Float_t val) { Cut(ESpecial::kFALSE, -1, parID, val); }

  /// Custom setting of process or cut given parameter name and value
  void SpecialCut(const char* modname, int localindex, ECut parID, Float_t val);

  /// load cuts and process flags from a data file (like AliRoot did)
  void loadCutsAndProcessesFromFile(const char* modname, const char* filename);
  void loadCutsAndProcessesFromJSON(ESpecial special = ESpecial::kFALSE, std::string const& filename = "");
  void writeCutsAndProcessesToJSON(std::string const& filename = "");

  /// Set flags whether to use special cuts and process settings
  void enableSpecialProcesses(bool val = true) { mApplySpecialProcesses = val; }
  bool specialProcessesEnabled() const { return mApplySpecialProcesses; }
  void enableSpecialCuts(bool val = true) { mApplySpecialCuts = val; }
  bool specialCutsEnabled() const { return mApplySpecialCuts; }

  // returns global material ID given a "local" material ID for this detector
  // returns -1 in case local ID not found
  int getMaterialID(const char* modname, int imat) const;

  // returns global medium ID given a "local" medium ID for this detector
  // returns -1 in case local ID not found
  int getMediumID(const char* modname, int imed) const;

  // various methods to get the TGeoMedium instance
  TGeoMedium* getTGeoMedium(const std::string& modname, int localid);
  TGeoMedium* getTGeoMedium(const char* mediumname);

  /// fill the medium index mapping into a standard vector
  /// the vector gets sized properly and will be overridden
  void getMediumIDMappingAsVector(const char* modname, std::vector<int>& mapping) const;

  /// Get the names of processes and cuts providing an respective enum member.
  const char* getProcessName(EProc process) const;

  const char* getCutName(ECut cut) const;

  /// Get module name which has medium of a certain global medium ID
  const char* getModuleFromMediumID(int globalindex) const;

  /// Get medium name from global medium ID
  const char* getMediumNameFromMediumID(int globalindex) const;

  /// get global medium IDs where special process is set along with process value
  void getMediaWithSpecialProcess(EProc process, std::vector<int>& mediumProcessVector) const;

  /// get global medium IDs where special cut is set along with cut value
  void getMediaWithSpecialCut(ECut cut, std::vector<Float_t>& mediumCutVector) const;

  /// Fill vector with default processes
  void getDefaultProcesses(std::vector<std::pair<EProc, int>>& processVector);

  /// Fill vector with default cuts
  void getDefaultCuts(std::vector<std::pair<ECut, Float_t>>& cutVector);

  /// Get special processes for global medium ID
  void getSpecialProcesses(int globalindex, std::vector<std::pair<EProc, int>>& processVector);

  /// Interface for module name and local medium ID
  void getSpecialProcesses(const char* modname, int localindex, std::vector<std::pair<EProc, int>>& processVector);

  /// Get special cuts for global medium ID
  void getSpecialCuts(int globalindex, std::vector<std::pair<ECut, Float_t>>& cutVector);

  /// Interface for module name and local medium ID
  void getSpecialCuts(const char* modname, int localindex, std::vector<std::pair<ECut, Float_t>>& cutVector);

  /// Print all processes for all media as well as defaults.
  void printProcesses(std::ostream& stream) const;
  /// Print all cuts for all media as well as defaults.
  void printCuts(std::ostream& stream) const;

  // print out all registered materials
  void printMaterials() const;

  // print out all registered media
  void printMedia() const;

  /// print all tracking media inside a logical volume (specified by name)
  /// and all of its daughters
  static void printContainingMedia(std::string const& volumename);

 private:
  MaterialManager() = default;

  bool mDensityMapInitialized = false;
  std::unordered_map<std::string, float> mDensityMap;

  void initDensityMap();
  float getDensity(std::string const& modname);

  // Hide details by providing these private methods so it cannot happen that special settings
  // are applied as default settings by accident using a boolean flag
  void Processes(ESpecial special, int globalindex, const std::initializer_list<std::pair<EProc, int>>& parIDValMap);
  void Cuts(ESpecial special, int globalindex, const std::initializer_list<std::pair<ECut, Float_t>>& parIDValMap);
  void Process(ESpecial special, int globalindex, EProc parID, int val);
  void Cut(ESpecial special, int globalindex, ECut parID, Float_t val);

  // insert material name
  void insertMaterialName(const char* uniquename, int index);
  void insertMediumName(const char* uniquename, int index);
  void insertTGeoMedium(std::string modname, int localindex);

  // lookup structures
  std::map<std::string, std::map<int, int>>
    mMaterialMap;                                       // map of module name -> map of local index to global index for Materials
  std::map<std::string, std::map<int, int>> mMediumMap; // map of module name -> map of local index to global index for Media

  std::map<int, std::map<EProc, int>> mMediumProcessMap; // map of global medium id to parameter-value map of processes
  std::map<int, std::map<ECut, Float_t>> mMediumCutMap;  // map of global medium id to parameter-value map of cuts
  std::map<ECut, Float_t> mDefaultCutMap;                // map of global cuts
  std::map<EProc, int> mDefaultProcessMap;               // map of global processes

  // a map allowing to lookup TGeoMedia from detector name and local medium index
  std::map<std::pair<std::string, int>, TGeoMedium*> mTGeoMediumMap;

  // finally, we'd like to keep track of tracking parameters and processes activated per medium

  std::map<std::string, int> mMaterialNameToGlobalIndexMap; // map of unique material name to global index
  std::map<std::string, int> mMediumNameToGlobalIndexMap;   // map of unique material name to global index

  /// In general, transport cuts and processes are properties of detector media. On the other hand different
  /// engines might provide different cuts and processes. Further, the naming convention might differ among
  /// engines.
  /// This must be handled by the MaterialManager to fit to the engine in use. In that way, the user does not need
  /// to care about the engine in use but only needs to set cuts according to ONE naming scheme.
  // \note Currently, the naming convention of GEANT4 v10.3.3 is used.
  // \note This might be overhead so far but makes the MaterialManager and therefore O2 finally capable of
  // forwarding cuts/processes to arbitrary engines.
  // \todo Is there a more elegant implementation?
  /// fixed names of cuts
  const static std::unordered_map<ECut, const char*> mCutIDToName;
  /// fixed names of processes
  const static std::unordered_map<EProc, const char*> mProcessIDToName;

  /// Decide whether special process and cut settings should be applied
  bool mApplySpecialProcesses = true;
  bool mApplySpecialCuts = true;

 public:
  ClassDefNV(MaterialManager, 0);
};

inline const char* MaterialManager::getProcessName(EProc process) const
{
  auto it = mProcessIDToName.find(process);
  if (it != mProcessIDToName.end()) {
    return it->second;
  }
  return "UNKNOWN";
}

inline const char* MaterialManager::getCutName(ECut cut) const
{
  auto it = mCutIDToName.find(cut);
  if (it != mCutIDToName.end()) {
    return it->second;
  }
  return "UNKNOWN";
}

} // namespace base
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef DETECTORS_BASE_INCLUDE_MATERIALMANAGERPARAM_H_
#define DETECTORS_BASE_INCLUDE_MATERIALMANAGERPARAM_H_

#include "CommonUtils/ConfigurableParam.h"
#include "CommonUtils/ConfigurableParamHelper.h"

namespace o2
{

struct MaterialManagerParam : public o2::conf::ConfigurableParamHelper<MaterialManagerParam> {
  std::string inputFile = "";
  std::string outputFile = "";
  // boilerplate stuff + make principal key "MaterialManagerParam"
  O2ParamDef(MaterialManagerParam, "MaterialManagerParam");
};

} // namespace o2

#endif /* DETECTORS_BASE_INCLUDE_MATERIALMANAGERPARAM_H_ */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Propagator
/// \brief Singleton class for track propagation routines
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_BASE_PROPAGATOR_
#define ALICEO2_BASE_PROPAGATOR_

#include "GPUCommonRtypes.h"
#include "GPUCommonArray.h"
#include "CommonConstants/PhysicsConstants.h"
#include "ReconstructionDataFormats/Track.h"
#include "ReconstructionDataFormats/DCA.h"
#include "ReconstructionDataFormats/TrackLTIntegral.h"
#include "DetectorsBase/MatLayerCylSet.h"

#ifndef GPUCA_GPUCODE
#include <string>
#endif

namespace o2
{
namespace parameters
{
class GRPObject;
class GRPMagField;
}

namespace dataformats
{
class VertexBase;
}

namespace field
{
class MagFieldFast;
class MagneticField;
}

namespace gpu
{
class GPUTPCGMPolynomialField;
}

namespace base
{

template <typename value_T>
class PropagatorImpl
{
 public:
  using value_type = value_T;
  using TrackPar_t = track::TrackParametrization<value_type>;
  using TrackParCov_t = track::TrackParametrizationWithError<value_type>;

  enum class MatCorrType : int {
    USEMatCorrNONE, // flag to not use material corrections
    USEMatCorrTGeo, // flag to use TGeo for material queries
    USEMatCorrLUT
  }; // flag to use LUT for material queries (user must provide a pointer

  static constexpr float MAX_SIN_PHI = 0.85f;
  static constexpr float MAX_STEP = 2.0f;

  GPUd() bool PropagateToXBxByBz(TrackParCov_t& track, value_type x,
                                 value_type maxSnp = MAX_SIN_PHI, value_type maxStep = MAX_STEP, MatCorrType matCorr = MatCorrType::USEMatCorrLUT,
                                 track::TrackLTIntegral* tofInfo = nullptr, int signCorr = 0) const;

  GPUd() bool PropagateToXBxByBz(TrackPar_t& track, value_type x,
                                 value_type maxSnp = MAX_SIN_PHI, value_type maxStep = MAX_STEP, MatCorrType matCorr = MatCorrType::USEMatCorrLUT,
                                 track::TrackLTIntegral* tofInfo = nullptr, int signCorr = 0) const;

  GPUd() bool propagateToX(TrackParCov_t& track, value_type x, value_type bZ,
                           value_type maxSnp = MAX_SIN_PHI, value_type maxStep = MAX_STEP, MatCorrType matCorr = MatCorrType::USEMatCorrLUT,
                           track::TrackLTIntegral* tofInfo = nullptr, int signCorr = 0) const;

  GPUd() bool propagateToX(TrackPar_t& track, value_type x, value_type bZ,
                           value_type maxSnp = MAX_SIN_PHI, value_type maxStep = MAX_STEP, MatCorrType matCorr = MatCorrType::USEMatCorrLUT,
                           track::TrackLTIntegral* tofInfo = nullptr, int signCorr = 0) const;

  template <typename track_T>
  GPUd() bool propagateTo(track_T& track, value_type x, bool bzOnly = false, value_type maxSnp = MAX_SIN_PHI, value_type maxStep = MAX_STEP,
                          MatCorrType matCorr = MatCorrType::USEMatCorrLUT, track::TrackLTIntegral* tofInfo = nullptr, int signCorr = 0) const
  {
    return bzOnly ? propagateToX(track, x, getNominalBz(), maxSnp, maxStep, matCorr, tofInfo, signCorr) : PropagateToXBxByBz(track, x, maxSnp, maxStep, matCorr, tofInfo, signCorr);
  }

  GPUd() bool propagateToDCA(const o2::dataformats::VertexBase& vtx, o2::track::TrackParametrizationWithError<value_type>& track, value_type bZ,
                             value_type maxStep = MAX_STEP, MatCorrType matCorr = MatCorrType::USEMatCorrLUT,
                             o2::dataformats::DCA* dcaInfo = nullptr, track::TrackLTIntegral* tofInfo = nullptr,
                             int signCorr = 0, value_type maxD = 999.f) const;

  GPUd() bool propagateToDCABxByBz(const o2::dataformats::VertexBase& vtx, o2::track::TrackParametrizationWithError<value_type>& track,
                                   value_type maxStep = MAX_STEP, MatCorrType matCorr = MatCorrType::USEMatCorrLUT,
                                   o2::dataformats::DCA* dcaInfo = nullptr, track::TrackLTIntegral* tofInfo = nullptr,
                                   int signCorr = 0, value_type maxD = 999.f) const;

  GPUd() bool propagateToDCA(const o2::math_utils::Point3D<value_type>& vtx, o2::track::TrackParametrization<value_type>& track, value_type bZ,
                             value_type maxStep = MAX_STEP, MatCorrType matCorr = MatCorrType::USEMatCorrLUT,
                             gpu::gpustd::array<value_type, 2>* dca = nullptr, track::TrackLTIntegral* tofInfo = nullptr,
                             int signCorr = 0, value_type maxD = 999.f) const;

  GPUd() bool propagateToDCABxByBz(const o2::math_utils::Point3D<value_type>& vtx, o2::track::TrackParametrization<value_type>& track,
                                   value_type maxStep = MAX_STEP, MatCorrType matCorr = MatCorrType::USEMatCorrLUT,
                                   gpu::gpustd::array<value_type, 2>* dca = nullptr, track::TrackLTIntegral* tofInfo = nullptr,
                                   int signCorr = 0, value_type maxD = 999.f) const;

  PropagatorImpl(PropagatorImpl const&) = delete;
  PropagatorImpl(PropagatorImpl&&) = delete;
  PropagatorImpl& operator=(PropagatorImpl const&) = delete;
  PropagatorImpl& operator=(PropagatorImpl&&) = delete;

  // Bz at the origin
  GPUd() void updateField();
  GPUd() value_type getNominalBz() const { return mBz; }
  GPUd() void setTGeoFallBackAllowed(bool v) { mTGeoFallBackAllowed = v; }
  GPUd() bool isTGeoFallBackAllowed() const { return mTGeoFallBackAllowed; }
  GPUd() void setMatLUT(const o2::base::MatLayerCylSet* lut) { mMatLUT = lut; }
  GPUd() const o2::base::MatLayerCylSet* getMatLUT() const { return mMatLUT; }
  GPUd() void setGPUField(const o2::gpu::GPUTPCGMPolynomialField* field) { mGPUField = field; }
  GPUd() const o2::gpu::GPUTPCGMPolynomialField* getGPUField() const { return mGPUField; }
  GPUd() void setBz(value_type bz) { mBz = bz; }

  GPUd() void estimateLTFast(o2::track::TrackLTIntegral& lt, const o2::track::TrackParametrization<value_type>& trc) const;

#ifndef GPUCA_GPUCODE
  static PropagatorImpl* Instance(bool uninitialized = false)
  {
    static PropagatorImpl instance(uninitialized);
    return &instance;
  }
  static int initFieldFromGRP(const o2::parameters::GRPMagField* grp, bool verbose = false);

  static int initFieldFromGRP(const o2::parameters::GRPObject* grp, bool verbose = false);
  static int initFieldFromGRP(const std::string grpFileName = "", bool verbose = false);
#endif

  GPUd() MatBudget getMatBudget(MatCorrType corrType, const o2::math_utils::Point3D<value_type>& p0, const o2::math_utils::Point3D<value_type>& p1) const;

  GPUd() void getFieldXYZ(const math_utils::Point3D<float> xyz, float* bxyz) const;

  GPUd() void getFieldXYZ(const math_utils::Point3D<double> xyz, double* bxyz) const;

 private:
#ifndef GPUCA_GPUCODE
  PropagatorImpl(bool uninitialized = false);
  ~PropagatorImpl() = default;
#endif

  template <typename T>
  GPUd() void getFieldXYZImpl(const math_utils::Point3D<T> xyz, T* bxyz) const;

  const o2::field::MagFieldFast* mFieldFast = nullptr; ///< External fast field map (barrel only for the moment)
  o2::field::MagneticField* mField = nullptr;          ///< External nominal field map
  value_type mBz = 0;                                  ///< nominal field

  bool mTGeoFallBackAllowed = true;                            ///< allow fall back to TGeo if requested MatLUT is not available
  const o2::base::MatLayerCylSet* mMatLUT = nullptr;           // externally set LUT
  const o2::gpu::GPUTPCGMPolynomialField* mGPUField = nullptr; // externally set GPU Field

  ClassDefNV(PropagatorImpl, 0);
};

using PropagatorF = PropagatorImpl<float>;
using PropagatorD = PropagatorImpl<double>;
using Propagator = PropagatorF;

} // namespace base
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Ray.cxx
/// \brief Call for the ray between start-end points for material budget estimate

#ifndef ALICEO2_RAY_H
#define ALICEO2_RAY_H

#include "GPUCommonRtypes.h"
#include "GPUCommonDef.h"
#include "GPUCommonMath.h"
#include "DetectorsBase/MatLayerCyl.h"
#include "MathUtils/Utils.h"

#ifndef GPUCA_ALIGPUCODE // this part is unvisible on GPU version
#include "MathUtils/Cartesian.h"
#endif // !GPUCA_ALIGPUCODE

/**********************************************************************
 *                                                                    *
 * Ray parameterized via its endpoints as                             *
 * Vi = Vi0 + t*(Vi1-Vi0), with Vi (i=0,1,2) for global X,Y,Z         *
 * and 0 < t < 1                                                      *
 *                                                                    *
 **********************************************************************/
namespace o2
{
namespace base
{

class Ray
{

 public:
  using vecF3 = float[3];
  static constexpr float MinDistToConsider = 1e-4; // treat as 0 lenght distance below this
  static constexpr float InvalidT = -1e9;
  static constexpr float Tiny = 1e-9;

  GPUd() Ray() : mP{0.f}, mD{0.f}, mDistXY2(0.f), mDistXY2i(0.f), mDistXYZ(0.f), mXDxPlusYDy(0.f), mXDxPlusYDyRed(0.f), mXDxPlusYDy2(0.f), mR02(0.f), mR12(0.f)
  {
  }
  GPUdDefault() ~Ray() CON_DEFAULT;

#ifndef GPUCA_ALIGPUCODE // this part is unvisible on GPU version
  Ray(const math_utils::Point3D<float> point0, const math_utils::Point3D<float> point1);
#endif // !GPUCA_ALIGPUCODE
  GPUd() Ray(float x0, float y0, float z0, float x1, float y1, float z1);
  GPUd() int crossLayer(const MatLayerCyl& lr);
  GPUd() bool crossCircleR(float r2, float& cross1, float& cross2) const;

  GPUd() float crossRadial(const MatLayerCyl& lr, int sliceID) const;
  GPUd() float crossRadial(float cs, float sn) const;
  GPUd() float crossZ(float z) const;

  GPUd() void getCrossParams(int i, float& par1, float& par2) const
  {
    par1 = mCrossParams1[i];
    par2 = mCrossParams2[i];
  }

  GPUd() bool isTooShort() const { return mDistXYZ < MinDistToConsider; }
  GPUd() void getMinMaxR2(float& rmin2, float& rmax2) const;

  GPUd() float getDist() const { return mDistXYZ; }
  GPUd() float getDist(float deltaT) const { return mDistXYZ * (deltaT > 0 ? deltaT : -deltaT); }

  // for debud only
  float getPos(float t, int i) const { return mP[i] + t * mD[i]; }

  GPUd() float getPhi(float t) const
  {
    float p = o2::gpu::CAMath::ATan2(mP[1] + t * mD[1], mP[0] + t * mD[0]);
    o2::math_utils::bringTo02Pi(p);
    return p;
  }

  GPUd() float getZ(float t) const { return mP[2] + t * mD[2]; }

  GPUd() bool validateZRange(float& cpar1, float& cpar2, const MatLayerCyl& lr) const;

 private:
  vecF3 mP;               ///< entrance point
  vecF3 mD;               ///< X,Y,Zdistance
  float mDistXY2;         ///< dist^2 between points in XY plane
  float mDistXY2i;        ///< inverse dist^2 between points in XY plane
  float mDistXYZ;         ///< distance between 2 points
  float mXDxPlusYDy;      ///< aux x0*DX+y0*DY
  float mXDxPlusYDyRed;   ///< aux (x0*DX+y0*DY)/mDistXY2
  float mXDxPlusYDy2;     ///< aux (x0*DX+y0*DY)^2
  float mR02;             ///< radius^2 of mP
  float mR12;             ///< radius^2 of mP1
  float mCrossParams1[2]; ///< parameters of crossing the layer (first parameter)
  float mCrossParams2[2]; ///< parameters of crossing the layer (second parameter)

  ClassDefNV(Ray, 1);
};

//______________________________________________________
#ifndef GPUCA_ALIGPUCODE // this part is unvisible on GPU version

inline Ray::Ray(const math_utils::Point3D<float> point0, const math_utils::Point3D<float> point1)
  : mP{point0.X(), point0.Y(), point0.Z()}, mD{point1.X() - point0.X(), point1.Y() - point0.Y(), point1.Z() - point0.Z()}
{
  mDistXY2 = mD[0] * mD[0] + mD[1] * mD[1];
  mDistXY2i = mDistXY2 > Tiny ? 1.f / mDistXY2 : 0.f;
  mDistXYZ = o2::gpu::CAMath::Sqrt(mDistXY2 + mD[2] * mD[2]);
  mXDxPlusYDy = point0.X() * mD[0] + point0.Y() * mD[1];
  mXDxPlusYDyRed = -mXDxPlusYDy * mDistXY2i;
  mXDxPlusYDy2 = mXDxPlusYDy * mXDxPlusYDy;
  mR02 = point0.Perp2();
  mR12 = point1.Perp2();
}
#endif // !GPUCA_ALIGPUCODE

//______________________________________________________
GPUdi() Ray::Ray(float x0, float y0, float z0, float x1, float y1, float z1)
  : mP{x0, y0, z0}, mD{x1 - x0, y1 - y0, z1 - z0}
{
  mDistXY2 = mD[0] * mD[0] + mD[1] * mD[1];
  mDistXY2i = mDistXY2 > Tiny ? 1.f / mDistXY2 : 0.f;
  mDistXYZ = o2::gpu::CAMath::Sqrt(mDistXY2 + mD[2] * mD[2]);
  mXDxPlusYDy = x0 * mD[0] + y0 * mD[1];
  mXDxPlusYDyRed = -mXDxPlusYDy * mDistXY2i;
  mXDxPlusYDy2 = mXDxPlusYDy * mXDxPlusYDy;
  mR02 = x0 * x0 + y0 * y0;
  mR12 = x1 * x1 + y1 * y1;
}

//______________________________________________________
GPUdi() float Ray::crossRadial(float cs, float sn) const
{
  // calculate t of crossing with radial line with inclination cosine and sine
  float den = mD[0] * sn - mD[1] * cs;
  return den != 0. ? (mP[1] * cs - mP[0] * sn) / den : InvalidT;
}

//______________________________________________________
GPUdi() bool Ray::crossCircleR(float r2, float& cross1, float& cross2) const
{
  // calculate parameters t of intersection with circle of radius r^2
  // calculated as solution of equation
  // t^2*mDistXY2 +- sqrt( mXDxPlusYDy^2 - mDistXY2*(mR02 - r^2) )
  //
  float det = mXDxPlusYDy2 - mDistXY2 * (mR02 - r2);
  if (det < 0.f) {
    return false; // no intersection
  }
  float detRed = o2::gpu::CAMath::Sqrt(det) * mDistXY2i;
  cross1 = mXDxPlusYDyRed + detRed; // (-mXDxPlusYDy + det)*mDistXY2i;
  cross2 = mXDxPlusYDyRed - detRed; // (-mXDxPlusYDy - det)*mDistXY2i;
  return true;
}

//______________________________________________________
GPUdi() float Ray::crossRadial(const MatLayerCyl& lr, int sliceID) const
{
  // calculate t of crossing with phimin of layer's slice sliceID
  return crossRadial(lr.getSliceCos(sliceID), lr.getSliceSin(sliceID));
}

//______________________________________________________
GPUdi() float Ray::crossZ(float z) const
{
  // calculate t of crossing XY plane at Z
  return mD[2] != 0. ? (z - mP[2]) / mD[2] : InvalidT;
}

//______________________________________________________
GPUdi() bool Ray::validateZRange(float& cpar1, float& cpar2, const MatLayerCyl& lr) const
{
  // make sure that estimated crossing parameters are compatible
  // with Z coverage of the layer
  MatLayerCyl::RangeStatus zout0 = lr.isZOutside(getZ(cpar1)), zout1 = lr.isZOutside(getZ(cpar2));
  if (zout0 == zout1) { // either both points outside w/o crossing or boht inside
    return zout0 == MatLayerCyl::Within ? true : false;
  }
  // at least 1 point is outside, but there is a crossing
  if (zout0 != MatLayerCyl::Within) {
    cpar1 = crossZ(zout0 == MatLayerCyl::Below ? lr.getZMin() : lr.getZMax());
  }
  if (zout1 != MatLayerCyl::Within) {
    cpar2 = crossZ(zout1 == MatLayerCyl::Below ? lr.getZMin() : lr.getZMax());
  }
  return true;
}

//______________________________________________________
GPUdi() void Ray::getMinMaxR2(float& rmin2, float& rmax2) const
{
  // calculate min and max R2
  if (mR02 > mR12) {
    rmin2 = mR12;
    rmax2 = mR02;
  } else {
    rmin2 = mR02;
    rmax2 = mR12;
  }
  if (mXDxPlusYDyRed > 0.f && mXDxPlusYDyRed < 1.f) {
    // estimate point of closest approach to origin as the crossing of normal from the origin to input vector
    // use r^2(t) = mR02 + t^2 (mD[0]^2+mD[1]^2) + 2t*mXDxPlusYDy
    float xMin = mP[0] + mXDxPlusYDyRed * mD[0], yMin = mP[1] + mXDxPlusYDyRed * mD[1];
    rmin2 = xMin * xMin + yMin * yMin;
  }
}

} // namespace base
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file MatCell.h
/// \brief Declarations for material properties of the cell (voxel)

#ifndef ALICEO2_MATCELL_H
#define ALICEO2_MATCELL_H

#include "GPUCommonDef.h"
#include "GPUCommonRtypes.h"

namespace o2
{
namespace base
{

struct MatCell {
  // small struct to hold <X/X0> and <rho> of the voxel

  static constexpr int NParams = 2; // number of material parameters described
  float meanRho;                    ///< mean density, g/cm^3
  float meanX2X0;                   ///< fraction of radiaton lenght

  GPUd() MatCell() : meanRho(0.f), meanX2X0(0.f) {}
  GPUdDefault() MatCell(const MatCell& src) CON_DEFAULT;

  GPUd() void scale(float scale)
  {
    meanRho *= scale;
    meanX2X0 *= scale;
  }

  ClassDefNV(MatCell, 1);
};

struct MatBudget : MatCell {

  // small struct to hold <X/X0>, <rho> and length traversed by track in the voxel
  static constexpr int NParams = 3; // number of material parameters described
  float length;                     ///< length in material

  GPUd() MatBudget() : length(0.f) {}
  GPUdDefault() MatBudget(const MatBudget& src) CON_DEFAULT;

  GPUd() void scale(float scale)
  {
    MatCell::scale(scale);
    length *= scale;
  }

  GPUd() float getXRho() const
  {
    return meanRho * length;
  }

  GPUd() float getXRho(int signCorr) const
  {
    return meanRho * (signCorr < 0 ? -length : length);
  }

  ClassDefNV(MatBudget, 1);
};

} // namespace base
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file MatLayerCyl.h
/// \brief Declarations for single cylindrical material layer class

#ifndef ALICEO2_MATLAYERCYL_H
#define ALICEO2_MATLAYERCYL_H

#ifndef GPUCA_GPUCODE_DEVICE
#include <cmath>
#include <cstring>
#endif
#include "GPUCommonDef.h"
#include "FlatObject.h"
#include "GPUCommonRtypes.h"
#include "GPUCommonMath.h"
#include "DetectorsBase/MatCell.h"

namespace o2
{
namespace base
{

/**********************************************************************
 *                                                                    *
 * Material data on the cells of cylindrical layer                    *
 * Cell is limited by 2 radial planes at phiMin,phiMax,               *
 * radii radMin,radMax and XY planes at zMin, zMax.                   *
 * This limits are defined in the cell container class                *
 *                                                                    *
 *                                                                    *
 * Cylindrical material layer                                         *
 *                                                                    *
 * Logical division is given by mNZBins and mNPhiBins                 *
 * but the actual number phi slices might be less if neighbouring     *
 * phi bins with similar properties are merged together. The actual   *
 * phi slice should be accessed via mPhiBin2Slice map.                *
 *                                                                    *
 **********************************************************************/
class MatLayerCyl : public o2::gpu::FlatObject
{

 public:
  enum RangeStatus : short { Below = -1,
                             Within = 0,
                             Above = 1 };

  MatLayerCyl();
  MatLayerCyl(const MatLayerCyl& src) CON_DELETE;
  ~MatLayerCyl() CON_DEFAULT;

#ifndef GPUCA_ALIGPUCODE // this part is unvisible on GPU version
  MatLayerCyl(float rMin, float rMax, float zHalfSpan, float dzMin, float drphiMin);

  void initSegmentation(float rMin, float rMax, float zHalfSpan, int nz, int nphi);
  void initSegmentation(float rMin, float rMax, float zHalfSpan, float dzMin, float drphiMin);
  void populateFromTGeo(int ntrPerCell = 10);
  void populateFromTGeo(int ip, int iz, int ntrPerCell);
  void print(bool data = false) const;
#endif // !GPUCA_ALIGPUCODE

  GPUd() float getRMin() const
  {
    return o2::gpu::CAMath::Sqrt(getRMin2());
  }
  GPUd() float getRMax() const { return o2::gpu::CAMath::Sqrt(getRMax2()); }
  GPUd() float getZMin() const { return -mZHalf; }
  GPUd() float getZMax() const { return mZHalf; }

  GPUd() int getNZBins() const { return mNZBins; }
  GPUd() int getNPhiBins() const { return mNPhiBins; }
  GPUd() int getNPhiSlices() const { return mNPhiSlices; }
  GPUd() int getNPhiBinsInSlice(int iSlice, int& binMin, int& binMax) const;

  GPUd() float getRMin2() const { return mRMin2; }
  GPUd() float getRMax2() const { return mRMax2; }
  GPUd() float getDZ() const { return mDZ; }
  GPUd() float getDPhi() const { return mDPhi; }

  // obtain material cell, cell ID must be valid
  GPUd() const MatCell& getCellPhiBin(int iphi, int iz) const { return mCells[getCellIDPhiBin(iphi, iz)]; }
  GPUd() const MatCell& getCell(int iphiSlice, int iz) const { return mCells[getCellID(iphiSlice, iz)]; }

  // ---------------------- Z slice manipulation
  // convert Z to Zslice
  GPUd() RangeStatus isZOutside(float z) const { return z < getZMin() ? Below : (z > getZMax() ? Above : Within); }
  GPUd() int getZBinID(float z) const
  {
    int idz = int((z - getZMin()) * getDZInv()); // cannot be negative since before isZOutside is applied
    return idz < getNZBins() ? idz : getNZBins() - 1;
  }

  // lower boundary of Z slice
  GPUd() float getZBinMin(int id) const { return getZMin() + id * getDZ(); }

  // upper boundary of Z slice
  GPUd() float getZBinMax(int id) const { return getZMin() + (id + 1) * getDZ(); }

  // ---------------------- Phi slice manipulation (0:2pi convention, no check is done)
  GPUd() int phiBin2Slice(int i) const { return mPhiBin2Slice[i]; }
  GPUd() int getPhiSliceID(float phi) const { return phiBin2Slice(getPhiBinID(phi)); }

  // lower boundary of phi slice
  GPUd() float getPhiBinMin(int id) const { return id * getDPhi(); }

  // upper boundary of phi slice
  GPUd() float getPhiBinMax(int id) const { return (id + 1) * getDPhi(); }

  // sin and cosine of the slice lower angle
  GPUd() float getSliceCos(int i) const { return mSliceCos[i]; }
  GPUd() float getSliceSin(int i) const { return mSliceSin[i]; }

#ifndef GPUCA_ALIGPUCODE // this part is unvisible on GPU version
  void getMeanRMS(MatCell& mean, MatCell& rms) const;
  bool cellsDiffer(const MatCell& cellA, const MatCell& cellB, float maxRelDiff) const;
  bool canMergePhiSlices(int i, int j, float maxRelDiff = 0.05, int maxDifferent = 1) const;
  void optimizePhiSlices(float maxRelDiff = 0.05);
  void flatten(char* newPtr);
#endif // !GPUCA_ALIGPUCODE

#ifndef GPUCA_GPUCODE
  std::size_t estimateFlatBufferSize() const
  {
    return estimateFlatBufferSize(getNPhiBins(), getNPhiSlices(), getNZBins());
  }
  static std::size_t estimateFlatBufferSize(int nPhiBins, int nPhiSlices, int nZBins)
  {
    size_t sz = 0;
    sz += alignSize(sz + nPhiBins * sizeof(short), getBufferAlignmentBytes());              // mPhiBin2Slice
    sz += alignSize(sz + nPhiSlices * sizeof(float), getBufferAlignmentBytes());            // mSliceCos
    sz += alignSize(sz + nPhiSlices * sizeof(float), getBufferAlignmentBytes());            // mSliceSin
    sz += alignSize(sz + nPhiSlices * nZBins * sizeof(MatCell), getBufferAlignmentBytes()); // mSliceSin
    return sz;
  }
  void fixPointers(char* oldPtr, char* newPtr);
  void setFlatPointer(char* ptr)
  {
    // brute force assignment of new pointers
    mFlatBufferPtr = ptr;
    if (mFlatBufferContainer) {
      mFlatBufferContainer = ptr;
    }
  }

  /// Gives minimal alignment in bytes required for the class object
  static constexpr size_t getClassAlignmentBytes() { return 8; }
  /// Gives minimal alignment in bytes required for the flat buffer
  static constexpr size_t getBufferAlignmentBytes() { return 8; }
#endif

 protected:
  GPUd() int getNCells() const { return getNZBins() * getNPhiSlices(); }
  GPUd() float getDZInv() const { return mDZInv; }
  GPUd() float getDPhiInv() const { return mDPhiInv; }

  // linearized cell ID from phi slice and z bin
  GPUd() int getCellID(int iphi, int iz) const { return iphi * getNZBins() + iz; }

  // linearized cell ID from phi bin and z bin
  GPUd() int getCellIDPhiBin(int iphi, int iz) const { return getCellID(phiBin2Slice(iphi), iz); }

  // convert Phi (in 0:2pi convention) to PhiBinID
  GPUd() int getPhiBinID(float phi) const
  {
    auto idphi = int(phi * getDPhiInv());
    return idphi < getNPhiBins() ? idphi : getNPhiBins() - 1;
  }

  GPUd() int getEdgePhiBinOfSlice(int phiBin, int dir) const
  {
    // Get edge bin (in direction dir) of the slice, to which phiBin belongs
    // No check for phiBin validity is done
    auto slice = phiBin2Slice(phiBin);
    while (slice == phiBin2Slice((phiBin += dir))) {
      ;
    }
    return phiBin - dir;
  }

  //------------------------------------------------------

  short mNZBins;     ///< number of Z bins
  short mNPhiBins;   ///< number of phi bins (logical)
  short mNPhiSlices; ///< actual number of phi slices
  //
  float mZHalf;   ///< Z half span
  float mRMin2;   ///< squared min r
  float mRMax2;   ///< squared max r
  float mDZ;      ///< Z slice thickness
  float mDZInv;   ///< Z slice thickness inverse
  float mDPhi;    ///< phi slice thickness
  float mDPhiInv; ///< phi slice thickness inverse

  short* mPhiBin2Slice; //! mapping from analytical phi bin ID to real slice ID

  float* mSliceCos; //! cached cos each phi slice
  float* mSliceSin; //! cached sin each phi slice

  MatCell* mCells; //! mat.budget per cell

  ClassDefNV(MatLayerCyl, 1);
};

} // namespace base
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file MatLayerCylSet.h
/// \brief Declarations for the wrapper for the set of cylindrical material layers

#ifndef ALICEO2_MATLAYERCYLSET_H
#define ALICEO2_MATLAYERCYLSET_H

#include "GPUCommonDef.h"
#include "DetectorsBase/MatLayerCyl.h"
#include "DetectorsBase/Ray.h"
#include "FlatObject.h"

#ifndef GPUCA_ALIGPUCODE // this part is unvisible on GPU version
#include "MathUtils/Cartesian.h"
#endif // !GPUCA_ALIGPUCODE

/**********************************************************************
 *                                                                    *
 * Set of cylindrical material layer                                  *
 *                                                                    *
 **********************************************************************/
namespace o2
{
namespace base
{

struct MatLayerCylSetLayout {
  float mRMin;          ///< min radius
  float mRMax;          ///< max radius
  float mZMax;          ///< max Z span
  float mRMin2;         ///< precalculater rmin^2
  float mRMax2;         ///< precalculater rmax^2
  int mNLayers;         ///< number of layers
  int mNRIntervals;     ///< number of R interval boundaries (gaps are possible)
  MatLayerCyl* mLayers; //[mNLayers] set of cylinrical layers
  float* mR2Intervals;  //[mNRIntervals+1] limits of layers
  int* mInterval2LrID;  //[mNRIntervals] mapping from r2 interval to layer ID
};

class MatLayerCylSet : public o2::gpu::FlatObject
{

 public:
  MatLayerCylSet() CON_DEFAULT;
  ~MatLayerCylSet() CON_DEFAULT;
  MatLayerCylSet(const MatLayerCylSet& src) CON_DELETE;

  GPUd() const MatLayerCylSetLayout* get() const { return reinterpret_cast<const MatLayerCylSetLayout*>(mFlatBufferPtr); }
  GPUd() MatLayerCylSetLayout* get() { return reinterpret_cast<MatLayerCylSetLayout*>(mFlatBufferPtr); }

  GPUd() int getNLayers() const { return get() ? get()->mNLayers : 0; }
  GPUd() const MatLayerCyl& getLayer(int i) const { return get()->mLayers[i]; }

  GPUd() bool getLayersRange(const Ray& ray, short& lmin, short& lmax) const;
  GPUd() float getRMin() const { return get()->mRMin; }
  GPUd() float getRMax() const { return get()->mRMax; }
  GPUd() float getZMax() const { return get()->mZMax; }
  GPUd() float getRMin2() const { return get()->mRMin2; }
  GPUd() float getRMax2() const { return get()->mRMax2; }

#ifndef GPUCA_ALIGPUCODE // this part is unvisible on GPU version
  void print(bool data = false) const;
  void addLayer(float rmin, float rmax, float zmax, float dz, float drphi);
  void populateFromTGeo(int ntrPerCel = 10);
  void optimizePhiSlices(float maxRelDiff = 0.05);

  void dumpToTree(const std::string& outName = "matbudTree.root") const;
  void writeToFile(const std::string& outFName = "matbud.root");
  static MatLayerCylSet* loadFromFile(const std::string& inpFName = "matbud.root");
  static MatLayerCylSet* rectifyPtrFromFile(MatLayerCylSet* ptr);

  void flatten();

#endif // !GPUCA_ALIGPUCODE

#ifndef GPUCA_ALIGPUCODE // this part is unvisible on GPU version
  MatBudget getMatBudget(const math_utils::Point3D<float>& point0, const math_utils::Point3D<float>& point1) const
  {
    // get material budget traversed on the line between point0 and point1
    return getMatBudget(point0.X(), point0.Y(), point0.Z(), point1.X(), point1.Y(), point1.Z());
  }
#endif // !GPUCA_ALIGPUCODE
  GPUd() MatBudget getMatBudget(float x0, float y0, float z0, float x1, float y1, float z1) const;

  GPUd() int searchSegment(float val, int low = -1, int high = -1) const;

#ifndef GPUCA_GPUCODE
  //-----------------------------------------------------------
  std::size_t estimateFlatBufferSize() const;
  void moveBufferTo(char* newFlatBufferPtr);

  void setActualBufferAddress(char* actualFlatBufferPtr);
  void setFutureBufferAddress(char* futureFlatBufferPtr);
  void cloneFromObject(const MatLayerCylSet& obj, char* newFlatBufferPtr);
  using o2::gpu::FlatObject::adoptInternalBuffer;
  using o2::gpu::FlatObject::releaseInternalBuffer;

  void fixPointers(char* newPtr = nullptr);
  void fixPointers(char* oldPtr, char* newPtr, bool newPtrValid = true);

  /// Gives minimal alignment in bytes required for the class object
  static constexpr size_t getClassAlignmentBytes() { return 8; }
  /// Gives minimal alignment in bytes required for the flat buffer
  static constexpr size_t getBufferAlignmentBytes() { return 8; }
#endif // !GPUCA_GPUCODE

  ClassDefNV(MatLayerCylSet, 1);
};

} // namespace base
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef O2_ALIGNER_H_
#define O2_ALIGNER_H_

// Helper class to pass and deploy geometry (mis)alignment

#include "CommonUtils/ConfigurableParam.h"
#include "CommonUtils/ConfigurableParamHelper.h"
#include "DetectorsCommonDataFormats/DetID.h"
#include <string>

namespace o2
{
namespace base
{

// Global parameters for digitization
class Aligner : public o2::conf::ConfigurableParamHelper<Aligner>
{
 public:
  const std::string& getDetectors() const { return mDetectors; }
  long getTimeStamp() const;
  o2::detectors::DetID::mask_t getDetectorsMask() const;

  bool isAlignmentRequested() const { return getDetectorsMask().any(); }
  void applyAlignment(long timestamp = 0, o2::detectors::DetID::mask_t addMask = o2::detectors::DetID::FullMask) const;

 private:
  std::string mDetectors = "all";                      // comma-separated list of modules to align, "all" or "none"
  long mTimeStamp = 0;                                 // assigned TimeStamp or now() if 0

  O2ParamDef(Aligner, "align-geom");
};

} // namespace base
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file SimFieldUtils.h
/// \brief Methods to create simulation mag field

#ifndef ALICEO2_BASE_SIMFIELDUTILS_H_
#define ALICEO2_BASE_SIMFIELDUTILS_H_

namespace o2
{
namespace field
{
class MagneticField;
}

namespace base
{

class SimFieldUtils
{
 public:
  // a common entry point to create the mag field for simulation
  // based on the simulation configuration in SimConfig
  static o2::field::MagneticField* const createMagField();
};

} // namespace base
} // namespace o2
#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from G__O2ITSMFTReconstruction dictionary payload:181:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:21:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/AlpideCoder.h:27:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/DataFormatsITSMFT/NoiseMap.h:86:48: error: use of overloaded operator '<<' is ambiguous (with operand types 'basic_ostream<char, std::char_traits<char> >' and 'unsigned long')
        std::cout << "chip, row, col, noise: " << chipID << ' ' << row << ' ' << col << ' ' << pair.second << '\n';
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^  ~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:517:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:511:5: note: candidate function [with _CharT = char, _Traits = std::char_traits<char>]
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:523:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:528:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/SimulationDataFormat/MCCompLabel.h:145:15: note: candidate function
std::ostream& operator<<(std::ostream& os, MCCompLabel const& c);
              ^
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:21:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/AlpideCoder.h:156:7: error: no matching function for call to 'format'
      LOGP(debug, "dataC: {:#x} expect {:#b}", int(dataC), int(expectInp));
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:403:14: note: expanded from macro 'LOGP'
#define LOGP FAIR_LOGP
             ^
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:434:51: note: expanded from macro 'FAIR_LOGP'
#define FAIR_LOGP(severity, ...) LOG(severity) << fmt::format(__VA_ARGS__)
                                                  ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <int, int>] not viable: no known conversion from 'const char [26]' to 'format_string<int, int>' (aka 'basic_format_string<char, int, int>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [26], void>::value' was not satisfied [with Locale = char [26], T = <int>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:21:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/AlpideCoder.h:229:11: error: no matching function for call to 'format'
          LOGP(debug, "dataC: {:#x} dataS: {:#x} expect {:#b} in ExpectData", int(dataC), int(dataS), int(expectInp));
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:403:14: note: expanded from macro 'LOGP'
#define LOGP FAIR_LOGP
             ^
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:434:51: note: expanded from macro 'FAIR_LOGP'
#define FAIR_LOGP(severity, ...) LOG(severity) << fmt::format(__VA_ARGS__)
                                                  ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <int, int, int>] not viable: no known conversion from 'const char [53]' to 'format_string<int, int, int>' (aka 'basic_format_string<char, int, int, int>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [53], void>::value' was not satisfied [with Locale = char [53], T = <int, int>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:21:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/AlpideCoder.h:272:15: error: no matching function for call to 'format'
              LOGP(debug, "hitsPattern: {:#b} expect {:#b}", int(hitsPattern), int(expectInp));
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:403:14: note: expanded from macro 'LOGP'
#define LOGP FAIR_LOGP
             ^
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:434:51: note: expanded from macro 'FAIR_LOGP'
#define FAIR_LOGP(severity, ...) LOG(severity) << fmt::format(__VA_ARGS__)
                                                  ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <int, int>] not viable: no known conversion from 'const char [32]' to 'format_string<int, int>' (aka 'basic_format_string<char, int, int>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [32], void>::value' was not satisfied [with Locale = char [32], T = <int>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:21:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/AlpideCoder.h:298:13: error: no matching function for call to 'format'
            LOGP(debug, "hitsPattern: {:#b} expect {:#b}", int(hitsPattern), int(expectInp));
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:403:14: note: expanded from macro 'LOGP'
#define LOGP FAIR_LOGP
             ^
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:434:51: note: expanded from macro 'FAIR_LOGP'
#define FAIR_LOGP(severity, ...) LOG(severity) << fmt::format(__VA_ARGS__)
                                                  ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <int, int>] not viable: no known conversion from 'const char [32]' to 'format_string<int, int>' (aka 'basic_format_string<char, int, int>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [32], void>::value' was not satisfied [with Locale = char [32], T = <int>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:21:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/AlpideCoder.h:312:40: error: no matching function for call to 'format'
                  return unexpectedEOF(fmt::format("Non-existing encoder {} decoded, DataLong was {:x}", pixID, dataS)); // abandon cable data
                                       ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <unsigned short &, unsigned short &>] not viable: no known conversion from 'const char [51]' to 'format_string<unsigned short &, unsigned short &>' (aka 'basic_format_string<char, unsigned short &, unsigned short &>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [51], void>::value' was not satisfied [with Locale = char [51], T = <unsigned short &>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:21:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/AlpideCoder.h:332:32: error: no matching function for call to 'format'
          return unexpectedEOF(fmt::format("Expected DataShort or DataLong mask, got {:x}", dataS)); // abandon cable data
                               ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <unsigned short &>] not viable: no known conversion from 'const char [46]' to 'format_string<unsigned short &>' (aka 'basic_format_string<char, unsigned short &>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [46], void>::value' was not satisfied [with Locale = char [46], T = <>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:21:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/AlpideCoder.h:375:32: error: no matching function for call to 'format'
          return unexpectedEOF(fmt::format("APE error {:#02x} [expectation = {:#02x}]", int(dataC), int(expectInp))); // abandon cable data
                               ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <int, int>] not viable: no known conversion from 'const char [42]' to 'format_string<int, int>' (aka 'basic_format_string<char, int, int>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [42], void>::value' was not satisfied [with Locale = char [42], T = <int>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:21:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/AlpideCoder.h:377:11: error: no matching function for call to 'format'
          LOGP(error, "Code should not have entered here, APE: {:#02x}, expectation: {:#02x}", codeAPE, int(expectInp));
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:403:14: note: expanded from macro 'LOGP'
#define LOGP FAIR_LOGP
             ^
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:434:51: note: expanded from macro 'FAIR_LOGP'
#define FAIR_LOGP(severity, ...) LOG(severity) << fmt::format(__VA_ARGS__)
                                                  ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <int &, int>] not viable: no known conversion from 'const char [70]' to 'format_string<int &, int>' (aka 'basic_format_string<char, int &, int>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [70], void>::value' was not satisfied [with Locale = char [70], T = <int>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:21:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/AlpideCoder.h:378:32: error: no matching function for call to 'format'
          return unexpectedEOF(fmt::format("APE error {:#02x} [expectation = {:#02x}]", int(dataC), int(expectInp))); // abandon cable data
                               ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <int, int>] not viable: no known conversion from 'const char [42]' to 'format_string<int, int>' (aka 'basic_format_string<char, int, int>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [42], void>::value' was not satisfied [with Locale = char [42], T = <int>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:21:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/AlpideCoder.h:392:28: error: no matching function for call to 'format'
      return unexpectedEOF(fmt::format("Unknown word 0x{:x} [expectation = 0x{:x}]", int(dataC), int(expectInp))); // abandon cable data
                           ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <int, int>] not viable: no known conversion from 'const char [43]' to 'format_string<int, int>' (aka 'basic_format_string<char, int, int>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [43], void>::value' was not satisfied [with Locale = char [43], T = <int>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ext/aligned_buffer.h:94:55: error: no type named 'type' in 'std::aligned_storage<12, 4>'
        std::aligned_storage<sizeof(_Tp), __alignof__(_Tp)>::type _M_storage;
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable_policy.h:233:43: note: in instantiation of template class '__gnu_cxx::__aligned_buffer<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > >' requested here
      __gnu_cxx::__aligned_buffer<_Value> _M_storage;
                                          ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable_policy.h:279:40: note: in instantiation of template class 'std::__detail::_Hash_node_value_base<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > >' requested here
    struct _Hash_node<_Value, false> : _Hash_node_value_base<_Value>
                                       ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable_policy.h:1974:25: note: in instantiation of template class 'std::__detail::_Hash_node<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> >, false>' requested here
        rebind_traits<typename __node_type::value_type>;
                               ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable.h:184:15: note: in instantiation of template class 'std::__detail::_Hashtable_alloc<std::allocator<std::__detail::_Hash_node<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> >, false> > >' requested here
      private __detail::_Hashtable_alloc<
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/unordered_map.h:105:18: note: in instantiation of template class 'std::_Hashtable<unsigned int, std::pair<const unsigned int, std::pair<unsigned int, unsigned int> >, std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > >, std::__detail::_Select1st, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >' requested here
      _Hashtable _M_h;
                 ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:50:63: note: in instantiation of template class 'std::unordered_map<unsigned int, std::pair<unsigned int, unsigned int>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > > >' requested here
  std::unordered_map<uint32_t, std::pair<uint32_t, uint32_t>> chipErrorsTF; // vector of chip decoding errors seen in the given TF
                                                              ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable.h:218:24: error: type 'std::_Hashtable<unsigned int, std::pair<const unsigned int, std::pair<unsigned int, unsigned int> >, std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > >, std::__detail::_Select1st, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::__value_alloc_traits' (aka 'int') cannot be used prior to '::' because it has no members
      typedef typename __value_alloc_traits::pointer            pointer;
                       ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/unordered_map.h:105:18: note: in instantiation of template class 'std::_Hashtable<unsigned int, std::pair<const unsigned int, std::pair<unsigned int, unsigned int> >, std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > >, std::__detail::_Select1st, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >' requested here
      _Hashtable _M_h;
                 ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:50:63: note: in instantiation of template class 'std::unordered_map<unsigned int, std::pair<unsigned int, unsigned int>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > > >' requested here
  std::unordered_map<uint32_t, std::pair<uint32_t, uint32_t>> chipErrorsTF; // vector of chip decoding errors seen in the given TF
                                                              ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable.h:219:24: error: type 'std::_Hashtable<unsigned int, std::pair<const unsigned int, std::pair<unsigned int, unsigned int> >, std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > >, std::__detail::_Select1st, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >::__value_alloc_traits' (aka 'int') cannot be used prior to '::' because it has no members
      typedef typename __value_alloc_traits::const_pointer      const_pointer;
                       ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/unordered_map.h:113:36: error: no type named 'mapped_type' in 'std::_Hashtable<unsigned int, std::pair<const unsigned int, std::pair<unsigned int, unsigned int> >, std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > >, std::__detail::_Select1st, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >'
      typedef typename _Hashtable::mapped_type  mapped_type;
              ~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:50:63: note: in instantiation of template class 'std::unordered_map<unsigned int, std::pair<unsigned int, unsigned int>, std::hash<unsigned int>, std::equal_to<unsigned int>, std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > > >' requested here
  std::unordered_map<uint32_t, std::pair<uint32_t, uint32_t>> chipErrorsTF; // vector of chip decoding errors seen in the given TF
                                                              ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/unordered_map.h:114:36: error: no type named 'hasher' in 'std::_Hashtable<unsigned int, std::pair<const unsigned int, std::pair<unsigned int, unsigned int> >, std::allocator<std::pair<const unsigned int, std::pair<unsigned int, unsigned int> > >, std::__detail::_Select1st, std::equal_to<unsigned int>, std::hash<unsigned int>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<false, false, true> >'
      typedef typename _Hashtable::hasher       hasher;
              ~~~~~~~~~~~~~~~~~~~~~^~~~~~
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:53:3: error: call to implicitly-deleted default constructor of 'std::unordered_map<uint64_t, uint32_t>' (aka 'unordered_map<unsigned long, unsigned int>')
  RUDecodeData()
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/unordered_map.h:141:7: note: explicitly defaulted function was implicitly deleted here
      unordered_map() = default;
      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/unordered_map.h:105:18: note: default constructor of 'unordered_map<unsigned long, unsigned int, std::hash<unsigned long>, std::equal_to<unsigned long>, std::allocator<std::pair<const unsigned long, unsigned int> > >' is implicitly deleted because field '_M_h' has a deleted default constructor
      _Hashtable _M_h;
                 ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable.h:451:7: note: explicitly defaulted function was implicitly deleted here
      _Hashtable() = default;
      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable.h:174:7: note: default constructor of '_Hashtable<unsigned long, std::pair<const unsigned long, unsigned int>, std::allocator<std::pair<const unsigned long, unsigned int> >, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__detail::_Hashtable_traits<true, false, true> >' is implicitly deleted because base class '__detail::_Hashtable_base<unsigned long, pair<const unsigned long, unsigned int>, _Select1st, equal_to<unsigned long>, hash<unsigned long>, _Mod_range_hashing, _Default_ranged_hash, _Hashtable_traits<true, false, true> >' has a deleted default constructor
    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable_policy.h:1791:5: note: explicitly defaulted function was implicitly deleted here
    _Hashtable_base() = default;
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable_policy.h:1726:5: note: default constructor of '_Hashtable_base<unsigned long, std::pair<const unsigned long, unsigned int>, std::__detail::_Select1st, std::equal_to<unsigned long>, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Hashtable_traits<true, false, true> >' is implicitly deleted because base class '_Hash_code_base<unsigned long, std::pair<const unsigned long, unsigned int>, std::__detail::_Select1st, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, _Hashtable_traits<true, false, true>::__hash_cached::value>' has a deleted default constructor
  : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable_policy.h:1368:7: note: explicitly defaulted function was implicitly deleted here
      _Hash_code_base() = default;
      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable_policy.h:1344:7: note: default constructor of '_Hash_code_base<unsigned long, std::pair<const unsigned long, unsigned int>, std::__detail::_Select1st, std::hash<unsigned long>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true>' is implicitly deleted because base class '_Hashtable_ebo_helper<1, std::hash<unsigned long> >' has a deleted default constructor
      private _Hashtable_ebo_helper<1, _H1>,
      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable_policy.h:1112:7: note: explicitly defaulted function was implicitly deleted here
      _Hashtable_ebo_helper() = default;
      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/hashtable_policy.h:1110:7: note: default constructor of '_Hashtable_ebo_helper<1, std::hash<unsigned long>, true>' is implicitly deleted because base class 'std::hash<unsigned long>' has a deleted default constructor
    : private _Tp
      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/functional_hash.h:101:19: note: default constructor of 'hash<unsigned long>' is implicitly deleted because base class '__hash_enum<unsigned long>' has no default constructor
    struct hash : __hash_enum<_Tp>
                  ^
In file included from G__O2ITSMFTReconstruction dictionary payload:181:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ITSMFTReconstruction/RUDecodeData.h:94:11: error: no matching function for call to 'format'
          LOGP(debug, "re-entry into the data of the chip {} after previously detector error", chipData->getChipID());
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:403:14: note: expanded from macro 'LOGP'
#define LOGP FAIR_LOGP
             ^
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:434:51: note: expanded from macro 'FAIR_LOGP'
#define FAIR_LOGP(severity, ...) LOG(severity) << fmt::format(__VA_ARGS__)
                                                  ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <unsigned short>] not viable: no known conversion from 'const char [70]' to 'format_string<unsigned short>' (aka 'basic_format_string<char, unsigned short>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [70], void>::value' was not satisfied [with Locale = char [70], T = <>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
G__O2ITSMFTReconstruction dictionary payload:449:11: error: no matching function for call to 'format'
          LOGP(debug, "SetCalibData for RU:{} at bc:{}/orb:{} : [{}/{}]", ruPtr->ruSWID, gbtTrg ? gbtTrg->bc : -1, gbtTrg ? gbtTrg->orbit : -1, gbtC->calibCounter, gbtC->calibUserField);
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:403:14: note: expanded from macro 'LOGP'
#define LOGP FAIR_LOGP
             ^
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:434:51: note: expanded from macro 'FAIR_LOGP'
#define FAIR_LOGP(severity, ...) LOG(severity) << fmt::format(__VA_ARGS__)
                                                  ^~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3117:31: note: candidate function [with T = <int &, int, unsigned int, const unsigned long &, const unsigned long &>] not viable: no known conversion from 'const char [49]' to 'format_string<int &, int, unsigned int, const unsigned long &, const unsigned long &>' (aka 'basic_format_string<char, int &, int, unsigned int, const unsigned long &, const unsigned long &>') for 1st argument
FMT_NODISCARD FMT_INLINE auto format(format_string<T...> fmt, T&&... args)
                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/format.h:3058:13: note: candidate template ignored: requirement 'detail::is_locale<char [49], void>::value' was not satisfied [with Locale = char [49], T = <int, unsigned int, const unsigned long &, const unsigned long &>]
inline auto format(const Locale& loc, format_string<T...> fmt, T&&... args)
            ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
Error in <TInterpreter::AutoParse>: Error parsing payload code for class o2::itsmft::GBTLink with content:

#line 1 "G__O2ITSMFTReconstruction dictionary payload"

#ifndef WITH_OPENMP
  #define WITH_OPENMP 1
#endif
#ifndef ZDC_FASTSIM_ONNX
  #define ZDC_FASTSIM_ONNX 1
#endif
#ifndef ENABLE_UPGRADES
  #define ENABLE_UPGRADES 1
#endif
#ifndef FMT_LOCALE
  #define FMT_LOCALE 1
#endif
#ifndef FMT_SHARED
  #define FMT_SHARED 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef FAIRMQ_HAS_STD_FILESYSTEM
  #define FAIRMQ_HAS_STD_FILESYSTEM 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_CONTAINER_DYN_LINK
  #define BOOST_CONTAINER_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_PROGRAM_OPTIONS_DYN_LINK
  #define BOOST_PROGRAM_OPTIONS_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_FILESYSTEM_DYN_LINK
  #define BOOST_FILESYSTEM_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_REGEX_DYN_LINK
  #define BOOST_REGEX_DYN_LINK 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_IOSTREAMS_DYN_LINK
  #define BOOST_IOSTREAMS_DYN_LINK 1
#endif
#ifndef DPL_ENABLE_BACKTRACE
  #define DPL_ENABLE_BACKTRACE 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_SERIALIZATION_DYN_LINK
  #define BOOST_SERIALIZATION_DYN_LINK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file PixelReader.h
/// \brief Abstract class for Alpide data reader class

#ifndef ALICEO2_ITSMFT_PIXELREADER_H
#define ALICEO2_ITSMFT_PIXELREADER_H

#include <Rtypes.h>
#include "ITSMFTReconstruction/PixelData.h"
#include "SimulationDataFormat/MCCompLabel.h"
#include "SimulationDataFormat/ConstMCTruthContainer.h"
#include "CommonDataFormat/InteractionRecord.h"
#include <vector>

namespace o2
{

namespace itsmft
{
/// \class PixelReader
/// \brief PixelReader class for the ITSMFT
///
class PixelReader
{
 public:
  /// Transient data for single fired pixel

  PixelReader() = default;
  virtual ~PixelReader() = default;
  PixelReader(const PixelReader& cluster) = delete;

  PixelReader& operator=(const PixelReader& src) = delete;
  virtual void init() = 0;
  virtual bool getNextChipData(ChipPixelData& chipData) = 0;
  virtual ChipPixelData* getNextChipData(std::vector<ChipPixelData>& chipDataVec) = 0;

  // prepare data of next trigger, return number of non-empty links or chips
  virtual int decodeNextTrigger() = 0;
  virtual const o2::dataformats::ConstMCTruthContainerView<o2::MCCompLabel>* getDigitsMCTruth() const
  {
    return nullptr;
  }
  const o2::InteractionRecord& getInteractionRecordHB() const
  {
    return mInteractionRecordHB;
  }
  const o2::InteractionRecord& getInteractionRecord() const
  {
    return mInteractionRecord;
  }
  uint32_t getTrigger() const
  {
    return mTrigger;
  }

  bool getDecodeNextAuto() const { return mDecodeNextAuto; }
  void setDecodeNextAuto(bool v) { mDecodeNextAuto = v; }
  //
 protected:
  //
  o2::InteractionRecord mInteractionRecordHB = {}; // interation record for the HB
  o2::InteractionRecord mInteractionRecord = {};   // interation record for the trigger
  uint32_t mTrigger = 0;
  bool mDecodeNextAuto = true; // try to fetch/decode next trigger when getNextChipData does not see any decoded data

  ClassDef(PixelReader, 1);
};

} // namespace itsmft
} // namespace o2

#endif /* ALICEO2_ITS_PIXELREADER_H */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file GBTLink.h
/// \brief Declarations of helper classes for the ITS/MFT raw data decoding

#ifndef _ALICEO2_ITSMFT_GBTLINK_H_
#define _ALICEO2_ITSMFT_GBTLINK_H_

#define _RAW_READER_ERROR_CHECKS_ // comment this to disable error checking

#include <string>
#include <memory>
#include <gsl/gsl>
#include "ITSMFTReconstruction/PayLoadCont.h"
#include "ITSMFTReconstruction/PayLoadSG.h"
#include "ITSMFTReconstruction/GBTWord.h"
#include "ITSMFTReconstruction/RUDecodeData.h"
#include "ITSMFTReconstruction/DecodingStat.h"
#include "ITSMFTReconstruction/RUInfo.h"
#include "DataFormatsITSMFT/PhysTrigger.h"
#include "Headers/RAWDataHeader.h"
#include "DetectorsRaw/RDHUtils.h"
#include "CommonDataFormat/InteractionRecord.h"

#define GBTLINK_DECODE_ERRORCHECK(errRes, errEval)                            \
  errRes = errEval;                                                           \
  if ((errRes)&uint8_t(ErrorPrinted)) {                                       \
    ruPtr->linkHBFToDump[(uint64_t(subSpec) << 32) + hbfEntry] = irHBF.orbit; \
    errRes &= ~uint8_t(ErrorPrinted);                                         \
  }                                                                           \
  if ((errRes)&uint8_t(Abort)) {                                              \
    discardData();                                                            \
    return AbortedOnError;                                                    \
  }

namespace o2
{
namespace itsmft
{

struct RUDecodeData; // forward declaration to allow its linking in the GBTlink
struct GBTHeader;
struct GBTTrailer;
struct GBTTrigger;

/// support for the GBT single link data
struct GBTLink {

  enum RawDataDumps : int { DUMP_NONE, // no raw data dumps on error
                            DUMP_HBF,  // dump HBF for FEEID with error
                            DUMP_TF,   // dump whole TF at error
                            DUMP_NTYPES };

  enum Format : int8_t { OldFormat,
                         NewFormat,
                         NFormats };

  enum CollectedDataStatus : int8_t { None,
                                      AbortedOnError,
                                      StoppedOnEndOfData,
                                      DataSeen }; // None is set before starting collectROFCableData

  enum ErrorType : uint8_t { NoError = 0x0,
                             Warning = 0x1,
                             Skip = 0x2,
                             Abort = 0x4,
                             ErrorPrinted = 0x1 << 7 };

  enum Verbosity : int8_t { Silent = -1,
                            VerboseErrors,
                            VerboseHeaders,
                            VerboseData };

  using RDH = o2::header::RDHAny;
  using RDHUtils = o2::raw::RDHUtils;

  CollectedDataStatus status = None;
  Format format = NewFormat;
  Verbosity verbosity = VerboseErrors;
  std::vector<PhysTrigger>* extTrigVec = nullptr;
  uint8_t idInRU = 0;     // link ID within the RU
  uint8_t idInCRU = 0;    // link ID within the CRU
  uint8_t endPointID = 0; // endpoint ID of the CRU
  bool gbtErrStatUpadated = false;
  uint16_t cruID = 0;     // CRU ID
  uint16_t feeID = 0;     // FEE ID
  uint16_t channelID = 0; // channel ID in the reader input
  uint32_t lanes = 0;     // lanes served by this link
  uint32_t subSpec = 0;   // link subspec
  // RS do we need this >> ? // Legacy from old data format encoder
  int lastPageSize = 0; // size of last added page = offset from the end to get to the RDH
  int nTriggers = 0;    // number of triggers loaded (the last one might be incomplete)
  // << ?

  PayLoadCont data; // data buffer used for encoding

  // transient data filled from current RDH
  uint32_t lanesActive = 0;   // lanes declared by the payload header
  uint32_t lanesStop = 0;     // lanes received stop in the payload trailer
  uint32_t lanesTimeOut = 0;  // lanes received timeout
  uint32_t lanesWithData = 0; // lanes with data transmitted
  int32_t packetCounter = -1; // current packet counter from RDH (RDH.packetCounter)
  uint32_t trigger = 0;       // trigger word
  uint32_t errorBits = 0;     // bits of the error code of last frame decoding (if any)
  uint32_t hbfEntry = 0;      // entry of the current HBF page in the rawData SG list
  const RDH* lastRDH = nullptr;
  o2::InteractionRecord ir;       // interaction record of the ROF
  o2::InteractionRecord irHBF;    // interaction record of the HBF
  GBTLinkDecodingStat statistics; // link decoding statistics
  ChipStat chipStat;              // chip decoding statistics
  RUDecodeData* ruPtr = nullptr;  // pointer on the parent RU

  PayLoadSG rawData;         // scatter-gatter buffer for cached CRU pages, each starting with RDH
  size_t dataOffset = 0;     //
  size_t currOffsWrtRDH = 0; // index of 1st unread element in the current CRU page
  //------------------------------------------------------------------------

  GBTLink() = default;
  GBTLink(uint16_t _cru, uint16_t _fee, uint8_t _ep, uint8_t _idInCru = 0, uint16_t _chan = 0);
  std::string describe() const;
  void clear(bool resetStat = true, bool resetTFRaw = false);

  template <class Mapping>
  CollectedDataStatus collectROFCableData(const Mapping& chmap);

  void cacheData(const void* ptr, size_t sz)
  {
    rawData.add(reinterpret_cast<const PayLoadSG::DataType*>(ptr), sz);
  }

 private:
  bool needToPrintError(uint32_t count) { return verbosity == Silent ? false : (verbosity > VerboseErrors || count == 1); }
  void discardData() { rawData.setDone(); }
  void printTrigger(const GBTTrigger* gbtTrg, int offs);
  void printHeader(const GBTDataHeader* gbtH, int offs);
  void printHeader(const GBTDataHeaderL* gbtH, int offs);
  void printTrailer(const GBTDataTrailer* gbtT, int offs);
  void printDiagnostic(const GBTDiagnostic* gbtD, int offs);
  void printCableDiagnostic(const GBTCableDiagnostic* gbtD);
  void printCalibrationWord(const GBTCalibration* gbtCal, int offs);
  void printCableStatus(const GBTCableStatus* gbtS);
  bool nextCRUPage();

#ifndef _RAW_READER_ERROR_CHECKS_ // define dummy inline check methods, will be compiled out
  bool checkErrorsRDH(const RDH& rdh) const
  {
    return true;
  }
  uint8_t checkErrorsRDHStop(const RDH& rdh) const { return NoError; }
  uint8_t checkErrorsRDHStopPageEmpty(const RDH& rdh) const { return NoError; }
  uint8_t checkErrorsTriggerWord(const GBTTrigger* gbtTrg) const { return NoError; }
  uint8_t checkErrorsHeaderWord(const GBTDataHeader* gbtH) const { return NoError; }
  uint8_t checkErrorsHeaderWord(const GBTDataHeaderL* gbtH) const { return NoError; }
  uint8_t checkErrorsActiveLanes(int cables) const { return NoError; }
  uint8_t checkErrorsGBTData(int cablePos) const { return NoError; }
  uint8_t checkErrorsTrailerWord(const GBTDataTrailer* gbtT) const { return NoError; }
  uint8_t checkErrorsPacketDoneMissing(const GBTDataTrailer* gbtT, bool notEnd) const { return NoError; }
  uint8_t checkErrorsLanesStops() const { return NoError; }
  uint8_t checkErrorsDiagnosticWord(const GBTDiagnostic* gbtD) const { return NoError; }
  uint8_t checkErrorsCalibrationWord(const GBTCalibration* gbtCal) const { return NoError; }
  uint8_t checkErrorsCableID(const GBTData* gbtD, uint8_t cableSW) const { return NoError; }
#else
  uint8_t checkErrorsRDH(const RDH& rdh);
  uint8_t checkErrorsRDHStop(const RDH& rdh);
  uint8_t checkErrorsRDHStopPageEmpty(const RDH& rdh);
  uint8_t checkErrorsTriggerWord(const GBTTrigger* gbtTrg);
  uint8_t checkErrorsHeaderWord(const GBTDataHeader* gbtH);
  uint8_t checkErrorsHeaderWord(const GBTDataHeaderL* gbtH);
  uint8_t checkErrorsActiveLanes(int cables);
  uint8_t checkErrorsGBTData(int cablePos);
  uint8_t checkErrorsTrailerWord(const GBTDataTrailer* gbtT);
  uint8_t checkErrorsPacketDoneMissing(const GBTDataTrailer* gbtT, bool notEnd);
  uint8_t checkErrorsLanesStops();
  uint8_t checkErrorsDiagnosticWord(const GBTDiagnostic* gbtD);
  uint8_t checkErrorsCalibrationWord(const GBTCalibration* gbtCal);
  uint8_t checkErrorsCableID(const GBTData* gbtD, uint8_t cableSW);
#endif
  uint8_t checkErrorsGBTDataID(const GBTData* dbtD);

  ClassDefNV(GBTLink, 1);
};

///_________________________________________________________________
/// collect cables data for single ROF, return number of real payload words seen,
/// -1 in case of critical error
template <class Mapping>
GBTLink::CollectedDataStatus GBTLink::collectROFCableData(const Mapping& chmap)
{
  status = None;
  auto* currRawPiece = rawData.currentPiece();
  uint8_t errRes = uint8_t(GBTLink::NoError);
  bool expectPacketDone = false;
  ir.clear();
  while (currRawPiece) { // we may loop over multiple CRU page
    if (dataOffset >= currRawPiece->size) {
      dataOffset = 0;                              // start of the RDH
      if (!(currRawPiece = rawData.nextPiece())) { // fetch next CRU page
        break;                                     // Data chunk (TF?) is done
      }
    }
    if (!dataOffset) { // here we always start with the RDH
      auto hbfEntrySav = hbfEntry;
      hbfEntry = 0xffffffff; // in case of problems with RDH, dump full TF
      const auto* rdh = reinterpret_cast<const RDH*>(&currRawPiece->data[dataOffset]);
      if (verbosity >= VerboseHeaders) {
        RDHUtils::printRDH(rdh);
      }
      GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsRDH(*rdh)); // make sure we are dealing with RDH
      hbfEntry = hbfEntrySav; // critical check of RDH passed
      lastRDH = rdh;
      statistics.nPackets++;
      if (RDHUtils::getPageCounter(*rdh) == 0 || irHBF.isDummy()) { // for the threshold scan data it is not guaranteed that the page0 is found)
        irHBF = RDHUtils::getHeartBeatIR(*rdh);
        hbfEntry = rawData.currentPieceID();
      }
      GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsRDHStop(*rdh)); // if new HB starts, the lastRDH must have stop
      //      GBTLINK_DECODE_ERRORCHECK(checkErrorsRDHStopPageEmpty(*rdh)); // end of HBF should be an empty page with stop
      dataOffset += sizeof(RDH);
      auto psz = RDHUtils::getMemorySize(*rdh);
      if (psz == sizeof(RDH)) {
        continue; // filter out empty page
      }
      if (format == NewFormat && RDHUtils::getStop(*rdh)) { // only diagnostic word can be present after the stop
        auto gbtDiag = reinterpret_cast<const GBTDiagnostic*>(&currRawPiece->data[dataOffset]);
        if (verbosity >= VerboseHeaders) {
          printDiagnostic(gbtDiag, dataOffset);
        }
        GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsDiagnosticWord(gbtDiag));
        dataOffset += RDHUtils::getOffsetToNext(*rdh) - sizeof(RDH);
        continue;
      }

      // data must start with the GBTHeader
      auto gbtH = reinterpret_cast<const GBTDataHeader*>(&currRawPiece->data[dataOffset]); // process GBT header
      if (verbosity >= VerboseHeaders) {
        printHeader(gbtH, dataOffset);
      }
      dataOffset += GBTPaddedWordLength;
      if (format == OldFormat) {
        GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsHeaderWord(reinterpret_cast<const GBTDataHeaderL*>(gbtH)));
        lanesActive = reinterpret_cast<const GBTDataHeaderL*>(gbtH)->activeLanesL; // TODO do we need to update this for every page?
      } else {
        GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsHeaderWord(gbtH));
        lanesActive = gbtH->activeLanes; // TODO do we need to update this for every page?
      }

      GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsActiveLanes(chmap.getCablesOnRUType(ruPtr->ruInfo->ruType)));
      if (format == OldFormat && reinterpret_cast<const GBTDataHeaderL*>(gbtH)->packetIdx == 0) { // reset flags in case of 1st page of new ROF (old format: judge by RDH)
        lanesStop = 0;
        lanesWithData = 0;
      }

      continue;
    }

    ruPtr->nCables = ruPtr->ruInfo->nCables; // RSTODO is this needed? TOREMOVE

    // then we expect GBT trigger word (unless we work with old format)
    if (format == NewFormat) {
      int ntrig = 0;
      const GBTTrigger* gbtTrg = nullptr;
      while (dataOffset < currRawPiece->size) { // we may have multiple trigger words in case there were physics triggers
        const GBTTrigger* gbtTrgTmp = reinterpret_cast<const GBTTrigger*>(&currRawPiece->data[dataOffset]);
        if (gbtTrgTmp->isTriggerWord()) {
          ntrig++;
          if (verbosity >= VerboseHeaders) {
            printTrigger(gbtTrgTmp, dataOffset);
          }
          dataOffset += GBTPaddedWordLength;
          if (gbtTrgTmp->noData == 0 || gbtTrgTmp->internal) {
            gbtTrg = gbtTrgTmp; // this is a trigger describing the following data
          } else {
            if (extTrigVec) { // this link collects external triggers
              extTrigVec->emplace_back(PhysTrigger{o2::InteractionRecord(uint16_t(gbtTrgTmp->bc), uint32_t(gbtTrgTmp->orbit)), uint64_t(gbtTrgTmp->triggerType)});
            }
          }
          continue;
        }
        auto gbtC = reinterpret_cast<const o2::itsmft::GBTCalibration*>(&currRawPiece->data[dataOffset]);
        if (gbtC->isCalibrationWord()) {
          if (verbosity >= VerboseHeaders) {
            printCalibrationWord(gbtC, dataOffset);
          }
          dataOffset += GBTPaddedWordLength;
          LOGP(debug, "SetCalibData for RU:{} at bc:{}/orb:{} : [{}/{}]", ruPtr->ruSWID, gbtTrg ? gbtTrg->bc : -1, gbtTrg ? gbtTrg->orbit : -1, gbtC->calibCounter, gbtC->calibUserField);
          ruPtr->calibData = {gbtC->calibCounter, gbtC->calibUserField};
          continue;
        }
        break;
      }
      if (gbtTrg) {
        if (!gbtTrg->continuation) { // this is a continuation from the previous CRU page
          statistics.nTriggers++;
          lanesStop = 0;
          lanesWithData = 0;
          ir.bc = gbtTrg->bc;
          ir.orbit = gbtTrg->orbit;
          trigger = gbtTrg->triggerType;
        }
        if (gbtTrg->noData) {
          if (verbosity >= VerboseHeaders) {
            LOGP(info, "Offs {} Returning with status {} for {}", dataOffset, int(status), describe());
          }
          return status;
        }
      }
      if (dataOffset >= currRawPiece->size) { // end of CRU page was reached while scanning triggers
        if (verbosity >= VerboseHeaders) {
          LOGP(info, "Offs {} End of the CRU page reached while scanning triggers, continue to next page, {}", dataOffset, int(status), describe());
        }
        continue;
      }
    }
    auto gbtD = reinterpret_cast<const o2::itsmft::GBTData*>(&currRawPiece->data[dataOffset]);
    expectPacketDone = true;
    while (!gbtD->isDataTrailer()) { // start reading real payload
      if (verbosity >= VerboseData) {
        gbtD->printX();
      }
      GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsGBTDataID(gbtD));
      if (errRes != uint8_t(GBTLink::Skip)) {
        int cableHW = gbtD->getCableID(), cableSW = chmap.cableHW2SW(ruPtr->ruInfo->ruType, cableHW);
        GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsCableID(gbtD, cableSW));
        if (errRes != uint8_t(GBTLink::Skip)) {
          GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsGBTData(chmap.cableHW2Pos(ruPtr->ruInfo->ruType, cableHW)));
          ruPtr->cableData[cableSW].add(gbtD->getW8(), 9);
          ruPtr->cableHWID[cableSW] = cableHW;
          ruPtr->cableLinkID[cableSW] = idInRU;
          ruPtr->cableLinkPtr[cableSW] = this;
        }
      }
      dataOffset += GBTPaddedWordLength;
      gbtD = reinterpret_cast<const o2::itsmft::GBTData*>(&currRawPiece->data[dataOffset]);
    } // we are at the trailer, packet is over, check if there are more data on the next page

    auto gbtT = reinterpret_cast<const o2::itsmft::GBTDataTrailer*>(&currRawPiece->data[dataOffset]); // process GBT trailer
    if (verbosity >= VerboseHeaders) {
      printTrailer(gbtT, dataOffset);
    }
    dataOffset += GBTPaddedWordLength;

    GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsTrailerWord(gbtT));
    // we finished the GBT page, but there might be continuation on the next CRU page
    if (!gbtT->packetDone) {
      GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsPacketDoneMissing(gbtT, dataOffset < currRawPiece->size));
      continue; // keep reading next CRU page
    }
    if (format == OldFormat) {
      GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsLanesStops());
    }
    // accumulate packet states
    statistics.packetStates[gbtT->getPacketState()]++;
    if (format != NewFormat) {
      ir = RDHUtils::getTriggerIR(*lastRDH);
      trigger = RDHUtils::getTriggerType(*lastRDH);
    }
    if (verbosity >= VerboseHeaders) {
      LOGP(info, "Offs {} Leaving collectROFCableData for {} with DataSeen", dataOffset, describe());
    }
    return (status = DataSeen);
  }

  if (expectPacketDone) { // no trailer with packet done was encountered, register error
    GBTLINK_DECODE_ERRORCHECK(errRes, checkErrorsPacketDoneMissing(nullptr, false));
    return (status = DataSeen);
  }
  return (status = StoppedOnEndOfData);
}

} // namespace itsmft
} // namespace o2

#endif // _ALICEO2_ITSMFT_GBTLINK_H_
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file RUDecodeData.h
/// \brief Declaration of the Readout Unite decoder class
#ifndef ALICEO2_ITSMFT_RUDECODEDATA_H_
#define ALICEO2_ITSMFT_RUDECODEDATA_H_

#include <array>
#include <memory>
#include "ITSMFTReconstruction/PixelData.h"
#include "ITSMFTReconstruction/PayLoadCont.h"
#include "ITSMFTReconstruction/AlpideCoder.h"
#include "DataFormatsITSMFT/GBTCalibData.h"

namespace o2
{
namespace itsmft
{
struct RUInfo;
struct GBTLink;

struct RUDecodeData {

  static constexpr int MaxCablesPerRU = 28; // max number of cables RU can readout
  static constexpr int MaxChipsPerRU = 196; // max number of chips the RU can readout
  static constexpr int MaxLinksPerRU = 3;   // max number of GBT links per RU

  std::array<PayLoadCont, MaxCablesPerRU> cableData;       // cable data in compressed ALPIDE format
  std::vector<o2::itsmft::ChipPixelData> chipsData;        // fully decoded data in 1st nChipsFired chips
  std::array<int, MaxLinksPerRU> links;                    // link entry RSTODO: consider removing this and using pointer
  std::array<uint8_t, MaxCablesPerRU> cableHWID;           // HW ID of cable whose data is in the corresponding slot of cableData
  std::array<uint8_t, MaxCablesPerRU> cableLinkID;         // ID of the GBT link transmitting this cable data
  std::array<GBTLink*, MaxCablesPerRU> cableLinkPtr;       // Ptr of the GBT link transmitting this cable data
  std::unordered_map<uint64_t, uint32_t> linkHBFToDump;    // FEEID<<32+hbfEntry to dump in case of error
  int ruSWID = -1;         // SW (stave) ID
  int nCables = 0;         // total number of cables decoded for single trigger
  int nChipsFired = 0;     // number of chips with data or with errors
  int lastChipChecked = 0; // last chips checked among nChipsFired
  int verbosity = 0;       // verbosity level, for -1,0 print only summary data, for 1: print once every error
  GBTCalibData calibData{}; // calibration info from GBT calibration word
  std::unordered_map<uint32_t, std::pair<uint32_t, uint32_t>> chipErrorsTF; // vector of chip decoding errors seen in the given TF
  const RUInfo* ruInfo = nullptr;

  RUDecodeData()
  {
    memset(&links[0], -1, MaxLinksPerRU * sizeof(int));
  }

  int decodeROF();
  void clear();
  void setROFInfo(ChipPixelData* chipData, const GBTLink* lnk);
  template <class Mapping>
  int decodeROF(const Mapping& mp);
  void fillChipStatistics(int icab, const ChipPixelData* chipData);

  ClassDefNV(RUDecodeData, 2);
};

///_________________________________________________________________
/// decode single readout frame, the cable's data must be filled in advance via GBTLink::collectROFCableData
template <class Mapping>
int RUDecodeData::decodeROF(const Mapping& mp)
{
  nChipsFired = 0;
  lastChipChecked = 0;
  int ntot = 0;
  std::array<bool, Mapping::getNChips()> doneChips{};
  auto* chipData = &chipsData[0];
  for (int icab = 0; icab < nCables; icab++) { // cableData is ordered in such a way to have chipIDs in increasing order
    if (!cableData[icab].getSize()) {
      continue;
    }
    auto cabHW = cableHWID[icab];
    auto chIdGetter = [this, &mp, cabHW](int cid) {
      //return mp.getGlobalChipID(cid, cabHW, *this->ruInfo);
      auto chip = mp.getGlobalChipID(cid, cabHW, *this->ruInfo);
      return chip;
    };
    int ret = 0;
    while ((ret = AlpideCoder::decodeChip(*chipData, cableData[icab], chIdGetter)) || chipData->isErrorSet()) { // we register only chips with hits or errors flags set
      setROFInfo(chipData, cableLinkPtr[icab]);
      auto nhits = chipData->getData().size();
      if (nhits && doneChips[chipData->getChipID()]) {
        if (chipData->getChipID() == chipsData[nChipsFired - 1].getChipID()) {
          LOGP(debug, "re-entry into the data of the chip {} after previously detector error", chipData->getChipID());
        }
#ifdef ALPIDE_DECODING_STAT
        else {
          chipData->setError(ChipStat::InterleavedChipData);
        }
#endif
        ret = -1; // discard decoded data
        nhits = 0;
      }
#ifdef ALPIDE_DECODING_STAT
      fillChipStatistics(icab, chipData);
#endif
      if (nhits && chipData->getChipID() < Mapping::getNChips()) {
        doneChips[chipData->getChipID()] = true;
        ntot += nhits;
        if (++nChipsFired < chipsData.size()) { // fetch next free chip
          chipData = &chipsData[nChipsFired];
        } else {
          break; // last chip decoded
        }
      }
      if (ret < 0) {
        break; // negative code was returned by decoder: abandon cable data
      }
    }
  }

  return ntot;
}

} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file DigitPixelReader.h
/// \brief Definition of the Alpide pixel reader for MC digits processing

#ifndef ALICEO2_ITSMFT_DIGITPIXELREADER_H
#define ALICEO2_ITSMFT_DIGITPIXELREADER_H

#include "ITSMFTReconstruction/PixelReader.h"
#include "ITSMFTReconstruction/PixelData.h"
#include "DataFormatsITSMFT/ROFRecord.h"
#include "DataFormatsITSMFT/Digit.h"
#include "DetectorsCommonDataFormats/DetID.h"
#include "SimulationDataFormat/IOMCTruthContainerView.h"
#include "SimulationDataFormat/ConstMCTruthContainer.h"
#include "SimulationDataFormat/MCCompLabel.h"
#include <TTree.h>
#include <vector>
#include <memory>
#include <gsl/span>

namespace o2
{
namespace itsmft
{

class DigitPixelReader : public PixelReader
{
 public:
  DigitPixelReader() = default;
  ~DigitPixelReader() override;

  const auto getMC2ROFRecords() const
  {
    return mMC2ROFRecVec;
  }

  void setMC2ROFRecords(const gsl::span<const o2::itsmft::MC2ROFRecord> a)
  {
    mMC2ROFRecVec = a;
  }

  void setROFRecords(const gsl::span<const o2::itsmft::ROFRecord> a)
  {
    mROFRecVec = a;
    mIdROF = -1;
  }

  void setDigits(const gsl::span<const o2::itsmft::Digit> a)
  {
    mDigits = a;
    mIdDig = 0;
  }

  void setDigitsMCTruth(const o2::dataformats::ConstMCTruthContainerView<o2::MCCompLabel>* m)
  {
    mDigitsMCTruth = m;
  }

  const o2::dataformats::ConstMCTruthContainerView<o2::MCCompLabel>* getDigitsMCTruth() const override
  {
    return mDigitsMCTruth;
  }

  bool getNextChipData(ChipPixelData& chipData) override;
  ChipPixelData* getNextChipData(std::vector<ChipPixelData>& chipDataVec) override;

  void init() override
  {
    mIdDig = 0;
    mIdROF = -1;
  }

  // prepare next trigger
  int decodeNextTrigger() override;

  // methods for standalone reading
  void openInput(const std::string rawInput, o2::detectors::DetID det);
  bool readNextEntry();

  void clear();

 private:
  void addPixel(ChipPixelData& chipData, const Digit* dig)
  {
    // add new fired pixel
    chipData.getData().emplace_back(dig);
  }

  // pointer for input containers in the self-managed mode: due to the requirements of the
  // fairroot the externally settable pointers must be const...
  std::vector<o2::itsmft::Digit>* mDigitsSelf = nullptr;
  std::vector<o2::itsmft::ROFRecord>* mROFRecVecSelf = nullptr;
  std::vector<o2::itsmft::MC2ROFRecord>* mMC2ROFRecVecSelf = nullptr;
  const o2::dataformats::IOMCTruthContainerView* mDigitsMCTruthSelf = nullptr;

  gsl::span<const o2::itsmft::Digit> mDigits;
  gsl::span<const o2::itsmft::ROFRecord> mROFRecVec;
  gsl::span<const o2::itsmft::MC2ROFRecord> mMC2ROFRecVec;

  const o2::dataformats::ConstMCTruthContainerView<o2::MCCompLabel>* mDigitsMCTruth = nullptr;
  Int_t mIdDig = 0; // Digits slot read within ROF
  Int_t mIdROF = 0; // ROFRecord being red

  std::unique_ptr<TTree> mInputTree;       // input tree for digits

  ClassDefOverride(DigitPixelReader, 1);
};

} // namespace itsmft
} // namespace o2

#endif /* ALICEO2_ITS_DIGITPIXELREADER_H */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file RawPixelReader.h
/// \brief Definition of the Alpide pixel reader for raw data processing
#ifndef ALICEO2_ITSMFT_RAWPIXELREADER_H_
#define ALICEO2_ITSMFT_RAWPIXELREADER_H_

#include "Headers/RAWDataHeader.h"
#include "CommonDataFormat/InteractionRecord.h"
#include "ITSMFTReconstruction/PixelReader.h"
#include "ITSMFTReconstruction/PixelData.h"
#include "ITSMFTReconstruction/ChipMappingITS.h" // this will become template parameter
#include "ITSMFTReconstruction/AlpideCoder.h"
#include "ITSMFTReconstruction/GBTWord.h"
#include "CommonConstants/Triggers.h"
#include "ITSMFTReconstruction/PayLoadCont.h"
#include "ITSMFTReconstruction/PayLoadSG.h"

#include "ITSMFTReconstruction/GBTLink.h"
#include "ITSMFTReconstruction/RUDecodeData.h"
#include "DetectorsRaw/RDHUtils.h"

#include <TTree.h>
#include <TStopwatch.h>
#include <FairLogger.h>
#include <vector>
#include <limits>
#include <climits>
#include <memory>
#include <algorithm>
#include <cassert>
#include <fstream>
#include <string_view>
#include <array>
#include <bitset>
#include <iomanip>

#define _RAW_READER_ERROR_CHECKS_

#define OUTHEX(v, l) "0x" << std::hex << std::setfill('0') << std::setw(l) << v << std::dec

namespace o2
{
namespace itsmft
{

constexpr int MaxGBTPacketBytes = 8 * 1024; // Max size of GBT packet in bytes (8KB)
constexpr int MaxGBTWordsPerPacket = MaxGBTPacketBytes / GBTPaddedWordLength; // Max N of GBT words per CRU page
constexpr int NCRUPagesPerSuperpage = 256;  // Expected max number of CRU pages per superpage
using RDHUtils = o2::raw::RDHUtils;

struct RawDecodingStat {
  enum DecErrors : int {
    ErrInvalidFEEId, // RDH provided invalid FEEId
    NErrorsDefined
  };

  using ULL = unsigned long long;
  uint64_t nTriggersProcessed = 0;                  // total number of triggers processed
  uint64_t nPagesProcessed = 0;                     // total number of pages processed
  uint64_t nRUsProcessed = 0;                       // total number of RUs processed (1 RU may take a few pages)
  uint64_t nBytesProcessed = 0;                     // total number of bytes (rdh->memorySize) processed
  uint64_t nNonEmptyChips = 0;                      // number of non-empty chips found
  uint64_t nHitsDecoded = 0;                        // number of hits found
  std::array<int, NErrorsDefined> errorCounts = {}; // error counters

  RawDecodingStat() = default;

  void clear()
  {
    nTriggersProcessed = 0;
    nPagesProcessed = 0;
    nRUsProcessed = 0;
    nBytesProcessed = 0;
    nNonEmptyChips = 0;
    nHitsDecoded = 0;
    errorCounts.fill(0);
  }

  void print(bool skipNoErr = true) const
  {
    printf("\nDecoding statistics\n");
    printf("%llu bytes for %llu RUs processed in %llu pages for %llu triggers\n", (ULL)nBytesProcessed, (ULL)nRUsProcessed,
           (ULL)nPagesProcessed, (ULL)nTriggersProcessed);
    printf("%llu hits found in %llu non-empty chips\n", (ULL)nHitsDecoded, (ULL)nNonEmptyChips);
    int nErr = 0;
    for (int i = NErrorsDefined; i--;) {
      nErr += errorCounts[i];
    }
    printf("Decoding errors: %d\n", nErr);
    for (int i = 0; i < NErrorsDefined; i++) {
      if (!skipNoErr || errorCounts[i]) {
        printf("%-70s: %d\n", ErrNames[i].data(), errorCounts[i]);
      }
    }
  }

  static constexpr std::array<std::string_view, NErrorsDefined> ErrNames = {
    "RDH cointains invalid FEEID" // ErrInvalidFEEId
  };

  ClassDefNV(RawDecodingStat, 2);
};

/// Used both for encoding to and decoding from the alpide raw data format
/// Requires as a template parameter a helper class for detector-specific
/// mapping between the software global chip ID and HW module ID and chip ID
/// within the module, see for example ChipMappingITS class.
/// Similar helper class must be provided for the MFT

template <class Mapping = o2::itsmft::ChipMappingITS>
class RawPixelReader : public PixelReader
{
  using Coder = o2::itsmft::AlpideCoder;

 public:
  RawPixelReader()
  {
    mRUEntry.fill(-1); // no known links in the beginning
  }

  ~RawPixelReader() override
  {
    mSWIO.Stop();
    printf("RawPixelReader IO time: ");
    mSWIO.Print();

    printf("Cache filling time: ");
    mSWCache.Print();
  }

  /// do we interpred GBT words as padded to 128 bits?
  bool isPadding128() const { return mPadding128; }

  /// do we treat CRU pages as having max size?
  bool isMaxPageImposed() const { return mImposeMaxPage; }

  /// assumed GBT word size (accounting for eventual padding)
  int getGBTWordSize() const { return mGBTWordSize; }

  /// impose padding model for GBT words
  void setPadding128(bool v)
  {
    mPadding128 = v;
    mGBTWordSize = mPadding128 ? o2::itsmft::GBTPaddedWordLength : o2::itsmft::GBTWordLength;
  }

  /// set min number of triggers to cache per frame
  void setMinTriggersToCache(int n) { mMinTriggersToCache = n > NCRUPagesPerSuperpage ? n : NCRUPagesPerSuperpage + 1; }

  int getMinTriggersToCache() const { return mMinTriggersToCache; }

  /// CRU pages are of max size of 8KB
  void imposeMaxPage(bool v) { mImposeMaxPage = v; }

  ///______________________________________________________________________
  ChipPixelData* getNextChipData(std::vector<ChipPixelData>& chipDataVec) override
  {
    // decode new RU if no cached non-empty chips

    if (mCurRUDecodeID >= 0) { // make sure current RU has fired chips to extract
      for (; mCurRUDecodeID < mNRUs; mCurRUDecodeID++) {
        auto& ru = mRUDecodeVec[mCurRUDecodeID];
        if (ru.lastChipChecked < ru.nChipsFired) {
          auto& chipData = ru.chipsData[ru.lastChipChecked++];
          int id = chipData.getChipID();
          chipDataVec[id].swap(chipData);
          return &chipDataVec[id];
        }
      }
      mCurRUDecodeID = 0; // no more decoded data if reached this place,
    }
    // will need to decode new trigger
    if (!mDecodeNextAuto) { // no more data in the current ROF and no automatic decoding of next one was requested
      return nullptr;
    }
    if (mMinTriggersCached < 2) { // last trigger might be incomplete, need to cache more data
      cacheLinksData(mRawBuffer);
    }
    if (mMinTriggersCached < 1 || !decodeNextTrigger()) {
      mCurRUDecodeID = -1;
      return nullptr; // nothing left
    }
    return getNextChipData(chipDataVec); // is it ok to use recursion here?
  }

  ///______________________________________________________________________
  void init() override{};

  ///______________________________________________________________________
  void clear(bool resetStat = true)
  {
    LOG(info) << "Cleaning decoder, reset_statistics_flag " << resetStat;
    if (resetStat) {
      mDecodingStat.clear();
    }
    for (auto& rudec : mRUDecodeVec) {
      rudec.clear();
    }
    for (auto& lnk : mGBTLinks) {
      lnk.clear(resetStat);
    }
    mMinTriggersCached = 0;
    mCurRUDecodeID = -1;
    mIOFile.close();
    mRawBuffer.clear();
  }

  ///================================== Encoding methods ========================

  ///______________________________________________________________________
  int digits2raw(const std::vector<o2::itsmft::Digit>& digiVec, int from, int ndig, const o2::InteractionRecord& bcData,
                 uint8_t ruSWMin = 0, uint8_t ruSWMax = 0xff)
  {
    // Convert ndig digits belonging to the same trigger to raw data
    // The digits in the vector must be in increasing chipID order
    // Return the number of pages in the link with smallest amount of pages

    int nDigTot = digiVec.size();
    assert(from < nDigTot);
    int last = (from + ndig <= nDigTot) ? from + ndig : nDigTot;
    RUDecodeData* curRUDecode = nullptr;
    ChipPixelData* curChipData = nullptr;
    ChipInfo chInfo;
    UShort_t curChipID = 0xffff; // currently processed SW chip id
    mInteractionRecord = bcData;
    ruSWMax = (ruSWMax < uint8_t(mMAP.getNRUs())) ? ruSWMax : mMAP.getNRUs() - 1;

    if (mNRUs < int(ruSWMax) - ruSWMin) { // book containers if needed
      for (uint8_t ru = ruSWMin; ru <= ruSWMax; ru++) {
        auto& ruData = getCreateRUDecode(ru);
        int nLinks = 0;
        for (int il = 0; il < RUDecodeData::MaxLinksPerRU; il++) {
          nLinks += ruData.links[il] < 0 ? 0 : 1;
        }
        mNLinks += nLinks;
        if (!nLinks) {
          LOG(info) << "Imposing single link readout for RU " << int(ru);
          ruData.links[0] = addGBTLink();
          getGBTLink(ruData.links[0])->lanes = mMAP.getCablesOnRUType(ruData.ruInfo->ruType);
          mNLinks++;
        }
      }
    }

    // place digits into corresponding chip buffers
    for (int id = from; id < last; id++) {
      const auto& dig = digiVec[id];
      if (curChipID != dig.getChipIndex()) {
        mMAP.getChipInfoSW(dig.getChipIndex(), chInfo);
        if (chInfo.ru < ruSWMin || chInfo.ru > ruSWMax) { // ignore this chip?
          continue;
        }
        curChipID = dig.getChipIndex();
        mCurRUDecodeID = chInfo.ru;
        curRUDecode = &mRUDecodeVec[mCurRUDecodeID];
        curChipData = &curRUDecode->chipsData[curRUDecode->nChipsFired++];
        curChipData->setChipID(chInfo.chOnRU->id); // set ID within the RU
      }
      curChipData->getData().emplace_back(&dig); // add new digit to the container
    }
    // convert digits to alpide data in the per-cable buffers
    int minPages = 0xffffff;
    for (mCurRUDecodeID = ruSWMin; mCurRUDecodeID <= int(ruSWMax); mCurRUDecodeID++) {
      curRUDecode = &mRUDecodeVec[mCurRUDecodeID];
      uint16_t next2Proc = 0, nchTot = mMAP.getNChipsOnRUType(curRUDecode->ruInfo->ruType);
      for (int ich = 0; ich < curRUDecode->nChipsFired; ich++) {
        auto& chipData = curRUDecode->chipsData[ich];
        convertEmptyChips(next2Proc, chipData.getChipID()); // if needed store EmptyChip flags
        next2Proc = chipData.getChipID() + 1;
        convertChip(chipData);
        chipData.clear();
      }
      convertEmptyChips(next2Proc, nchTot); // if needed store EmptyChip flags
      int minPageRU = fillGBTLinks();       // flush per-lane buffers to link buffers
      if (minPageRU < minPages) {
        minPages = minPageRU;
      }
    }

    return minPages;
  }

  //___________________________________________________________________________________
  void convertChip(o2::itsmft::ChipPixelData& chipData)
  {
    ///< convert digits of single chip to Alpide format.

    auto& ruData = mRUDecodeVec[mCurRUDecodeID]; // current RU container
    // fetch info of the chip with chipData->getChipID() ID within the RU
    const auto& chip = *mMAP.getChipOnRUInfo(ruData.ruInfo->ruType, chipData.getChipID());
    ruData.cableHWID[chip.cableHWPos] = chip.cableHW; // register the cable HW ID

    auto& pixels = chipData.getData();
    std::sort(pixels.begin(), pixels.end(),
              [](auto lhs, auto rhs) {
                if (lhs.getRow() < rhs.getRow()) {
                  return true;
                }
                if (lhs.getRow() > rhs.getRow()) {
                  return false;
                }
                return lhs.getCol() < rhs.getCol();
              });
    ruData.cableData[chip.cableHWPos].ensureFreeCapacity(40 * (2 + pixels.size())); // make sure buffer has enough capacity
    mCoder.encodeChip(ruData.cableData[chip.cableHWPos], chipData, chip.chipOnModuleHW, mInteractionRecord.bc);
  }

  //______________________________________________________
  void convertEmptyChips(int fromChip, int uptoChip)
  {
    // add empty chip words to respective cable's buffers for all chips of the current RU container
    auto& ruData = mRUDecodeVec[mCurRUDecodeID];                     // current RU container
    for (int chipIDSW = fromChip; chipIDSW < uptoChip; chipIDSW++) { // flag chips w/o data
      const auto& chip = *mMAP.getChipOnRUInfo(ruData.ruInfo->ruType, chipIDSW);
      ruData.cableHWID[chip.cableHWPos] = chip.cableHW; // register the cable HW ID
      ruData.cableData[chip.cableHWPos].ensureFreeCapacity(100);
      mCoder.addEmptyChip(ruData.cableData[chip.cableHWPos], chip.chipOnModuleHW, mInteractionRecord.bc);
    }
  }

  //___________________________________________________________________________________
  int fillGBTLinks()
  {
    // fill data of the RU to links buffer, return the number of pages in the link with smallest amount of pages
    constexpr uint8_t zero16[o2::itsmft::GBTPaddedWordLength] = {0}; // to speedup padding
    const int dummyNPages = 0xffffff;                                // any large number
    int minPages = dummyNPages;
    auto& ruData = mRUDecodeVec[mCurRUDecodeID];
    ruData.nCables = ruData.ruInfo->nCables;
    o2::header::RAWDataHeader rdh;

    RDHUtils::setTriggerOrbit(rdh, mInteractionRecord.orbit);
    RDHUtils::setHeartBeatOrbit(rdh, mInteractionRecord.orbit);
    RDHUtils::setTriggerBC(rdh, mInteractionRecord.orbit);
    RDHUtils::setHeartBeatBC(rdh, mInteractionRecord.orbit);
    RDHUtils::setTriggerType(rdh, o2::trigger::PhT); // ??
    RDHUtils::setDetectorField(rdh, mMAP.getRUDetectorField());

    int maxGBTWordsPerPacket = (MaxGBTPacketBytes - RDHUtils::getHeaderSize(rdh)) / o2::itsmft::GBTPaddedWordLength - 2;

    int nGBTW[RUDecodeData::MaxLinksPerRU] = {0};
    for (int il = 0; il < RUDecodeData::MaxLinksPerRU; il++) {

      auto* link = getGBTLink(ruData.links[il]);
      if (!link) {
        continue;
      }
      int nGBTWordsNeeded = 0;
      for (int icab = ruData.nCables; icab--;) { // calculate number of GBT words per link
        if ((link->lanes & (0x1 << icab))) {
          int nb = ruData.cableData[icab].getSize();
          nGBTWordsNeeded += nb ? 1 + (nb - 1) / 9 : 0;
        }
      }
      // move data in padded GBT words from cable buffers to link buffers
      RDHUtils::setFEEID(rdh, mMAP.RUSW2FEEId(ruData.ruInfo->idSW, il)); // write on link 0 always
      RDHUtils::setLinkID(rdh, il);
      RDHUtils::setPageCounter(rdh, 0);
      RDHUtils::setStop(rdh, 0);
      int loadsize = RDHUtils::getHeaderSize(rdh) + (nGBTWordsNeeded + 2) * o2::itsmft::GBTPaddedWordLength; // total data to dump
      RDHUtils::setMemorySize(rdh, loadsize < MaxGBTPacketBytes ? loadsize : MaxGBTPacketBytes);
      RDHUtils::setOffsetToNext(rdh, mImposeMaxPage ? MaxGBTPacketBytes : RDHUtils::getMemorySize(rdh));

      link->data.ensureFreeCapacity(MaxGBTPacketBytes);
      link->data.addFast(reinterpret_cast<uint8_t*>(&rdh), RDHUtils::getHeaderSize(rdh)); // write RDH for current packet
      link->nTriggers++;                                                    // acknowledge the page, note: here we count pages, not triggers
      o2::itsmft::GBTDataHeaderL gbtHeader(0, link->lanes);
      o2::itsmft::GBTDataTrailer gbtTrailer; // lanes will be set on closing the last page

      gbtHeader.packetIdx = RDHUtils::getPageCounter(rdh);
      link->data.addFast(gbtHeader.getW8(), mGBTWordSize); // write GBT header for current packet
      if (mVerbose) {
        LOG(info) << "Filling RU data";
        RDHUtils::printRDH(rdh);
        gbtHeader.printX(mPadding128);
      }

      // now loop over the lanes served by this link, writing each time at most 9 bytes, untill all lanes are copied
      int nGBTWordsInPacket = 0;
      do {
        for (int icab = 0; icab < ruData.nCables; icab++) {
          if ((link->lanes & (0x1 << icab))) {
            auto& cableData = ruData.cableData[icab];
            int nb = cableData.getUnusedSize();
            if (!nb) {
              continue; // write 80b word only if there is something to write
            }
            if (nb > 9) {
              nb = 9;
            }
            int gbtWordStart = link->data.getSize();                                                               // beginning of the current GBT word in the link
            link->data.addFast(cableData.getPtr(), nb);                                                            // fill payload of cable
            link->data.addFast(zero16, mGBTWordSize - nb);                                                         // fill the rest of the GBT word by 0
            link->data[gbtWordStart + 9] = mMAP.getGBTHeaderRUType(ruData.ruInfo->ruType, ruData.cableHWID[icab]); // set cable flag
            cableData.setPtr(cableData.getPtr() + nb);
            nGBTWordsNeeded--;
            if (mVerbose > 1) {
              ((GBTData*)(&link->data[gbtWordStart]))->printX(mPadding128);
            }
            if (++nGBTWordsInPacket == maxGBTWordsPerPacket) { // check if new GBT packet must be created
              break;
            }
          } // storing data of single cable
        }   // loop over cables of this link

        if (nGBTWordsNeeded && nGBTWordsInPacket >= maxGBTWordsPerPacket) {
          // more data to write, write trailer and add new GBT packet
          link->data.add(gbtTrailer.getW8(), mGBTWordSize); // write empty GBT trailer for current packet
          if (mVerbose) {
            gbtTrailer.printX(mPadding128);
          }
          RDHUtils::setPageCounter(rdh, RDHUtils::getPageCounter(rdh) + 1); // flag new page
          RDHUtils::setStop(rdh, nGBTWordsNeeded < maxGBTWordsPerPacket);   // flag if this is the last packet of multi-packet
          // update remaining size, using padded GBT words (as CRU writes)
          loadsize = RDHUtils::getHeaderSize(rdh) + (nGBTWordsNeeded + 2) * o2::itsmft::GBTPaddedWordLength; // update remaining size
          RDHUtils::setMemorySize(rdh, loadsize < MaxGBTPacketBytes ? loadsize : MaxGBTPacketBytes);
          RDHUtils::setOffsetToNext(rdh, mImposeMaxPage ? MaxGBTPacketBytes : RDHUtils::getMemorySize(rdh));
          link->data.ensureFreeCapacity(MaxGBTPacketBytes);
          link->data.addFast(reinterpret_cast<uint8_t*>(&rdh), RDHUtils::getHeaderSize(rdh)); // write RDH for current packet
          link->nTriggers++;                                                    // acknowledge the page, note: here we count pages, not triggers
          if (mVerbose) {
            RDHUtils::printRDH(rdh);
          }
          gbtHeader.packetIdx = RDHUtils::getPageCounter(rdh);
          link->data.addFast(gbtHeader.getW8(), mGBTWordSize); // write GBT header for current packet
          if (mVerbose) {
            gbtHeader.printX(mPadding128);
          }
          nGBTWordsInPacket = 0; // reset counter of words in the packet
        }
      } while (nGBTWordsNeeded);

      gbtTrailer.lanesStops = link->lanes;
      gbtTrailer.packetDone = true;
      link->data.addFast(gbtTrailer.getW8(), mGBTWordSize); // write GBT trailer for the last packet
      if (mVerbose) {
        gbtTrailer.printX(mPadding128);
      }
      // NOTE: here we don't pad the page to 8KB, will do this when flushing everything to the sink

      if (minPages > link->nTriggers) {
        minPages = link->nTriggers;
      }

    } // loop over links of RU
    ruData.clear();
    return minPages == dummyNPages ? 0 : minPages;
  }

  //___________________________________________________________________________________
  int flushSuperPages(int maxPages, PayLoadCont& sink, bool unusedToHead = true)
  {
    // flush superpage (at most maxPages) of each link to the output,
    // return total number of pages flushed

    int totPages = 0;
    for (int ru = 0; ru < mMAP.getNRUs(); ru++) {
      auto* ruData = getRUDecode(ru);
      if (!ruData) {
        continue;
      }
      for (int il = 0; il < RUDecodeData::MaxLinksPerRU; il++) {
        auto link = getGBTLink(ruData->links[il]);
        if (!link || link->data.isEmpty()) {
          continue;
        }
        int nPages = 0;
        sink.ensureFreeCapacity(maxPages * MaxGBTPacketBytes);
        const auto* ptrIni = link->data.getPtr();
        while (nPages < maxPages && !link->data.isEmpty()) {
          const auto ptr = link->data.getPtr();
          o2::header::RAWDataHeader* rdh = reinterpret_cast<o2::header::RAWDataHeader*>(ptr);
          sink.addFast(ptr, RDHUtils::getMemorySize(rdh));                    // copy header + payload
          sink.fillFast(0, MaxGBTPacketBytes - RDHUtils::getMemorySize(rdh)); // complete with 0's till the end of the page
          link->data.setPtr(ptr + RDHUtils::getMemorySize(rdh));
          link->nTriggers--; // here we count pages, not triggers
          nPages++;
        }
        totPages += nPages;
        if (unusedToHead) {
          link->data.moveUnusedToHead();
        }
      } // loop over links
    }   // loop over RUs
    return totPages;
  }

  ///================================== Decoding methods ========================

  //_____________________________________
  size_t cacheLinksData(PayLoadCont& buffer)
  {
    // distribute data from the single buffer among the links caches

    LOG(info) << "Caching links data, currently in cache: " << mMinTriggersCached << " triggers";
    auto nRead = loadInput(buffer);
    if (buffer.isEmpty()) {
      return nRead;
    }
    mSWCache.Start(false);
    enum LinkFlag : int8_t { NotUpdated,
                             Updated,
                             HasEnoughTriggers };
    LinkFlag linkFlags[Mapping::getNRUs()][3] = {NotUpdated};        // flag that enough triggeres were loaded for this link
    int nLEnoughTriggers = 0;                                        // number of links for we which enough number of triggers were loaded
    auto ptr = buffer.getPtr();
    o2::header::RAWDataHeader* rdh = reinterpret_cast<o2::header::RAWDataHeader*>(ptr);

    do {
      if (!RDHUtils::checkRDH(rdh)) { // does it look like RDH?
        if (!findNextRDH(buffer)) { // try to recover the pointer
          break;                    // no data to continue
        }
        ptr = buffer.getPtr();
        rdh = reinterpret_cast<o2::header::RAWDataHeader*>(ptr);
      }
      if (mVerbose) {
        RDHUtils::printRDH(rdh);
      }

      int ruIDSW = mMAP.FEEId2RUSW(RDHUtils::getFEEID(rdh));
#ifdef _RAW_READER_ERROR_CHECKS_
      if (ruIDSW >= mMAP.getNRUs()) {
        mDecodingStat.errorCounts[RawDecodingStat::ErrInvalidFEEId]++;
        LOG(error) << mDecodingStat.ErrNames[RawDecodingStat::ErrInvalidFEEId]
                   << " : FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << ", skipping CRU page";
        RDHUtils::printRDH(rdh);
        ptr += RDHUtils::getOffsetToNext(rdh);
        buffer.setPtr(ptr);
        if (buffer.getUnusedSize() < MaxGBTPacketBytes) {
          nRead += loadInput(buffer); // update
          ptr = buffer.getPtr();      // pointer might have been changed
        }
        continue;
      }
#endif
      auto& ruDecode = getCreateRUDecode(ruIDSW);

      bool newTrigger = true; // check if we see new trigger
      uint16_t lr, ruOnLr, linkIDinRU;
      mMAP.expandFEEId(RDHUtils::getFEEID(rdh), lr, ruOnLr, linkIDinRU);
      auto link = getGBTLink(ruDecode.links[linkIDinRU]);
      if (link) {                                                                                                    // was there any data seen on this link before?
        const auto rdhPrev = reinterpret_cast<o2::header::RAWDataHeader*>(link->data.getEnd() - link->lastPageSize); // last stored RDH
        if (isSameRUandTrigger(rdhPrev, rdh)) {
          newTrigger = false;
        }
      } else { // a new link was added
        ruDecode.links[linkIDinRU] = addGBTLink();
        link = getGBTLink(ruDecode.links[linkIDinRU]);
        link->statistics.feeID = RDHUtils::getFEEID(rdh);
        LOG(info) << "Adding new GBT LINK FEEId:" << OUTHEX(link->statistics.feeID, 4);
        mNLinks++;
      }
      if (linkFlags[ruIDSW][linkIDinRU] == NotUpdated) {
        link->data.moveUnusedToHead(); // reuse space of already processed data
        linkFlags[ruIDSW][linkIDinRU] = Updated;
      }
      // copy data to the buffer of the link and memorize its RDH pointer
      link->data.add(ptr, RDHUtils::getMemorySize(rdh));
      link->lastPageSize = RDHUtils::getMemorySize(rdh); // account new added size
      auto rdhC = reinterpret_cast<o2::header::RAWDataHeader*>(link->data.getEnd() - link->lastPageSize);
      RDHUtils::setOffsetToNext(rdhC, RDHUtils::getMemorySize(rdh)); // since we skip 0-s, we have to modify the offset

      if (newTrigger) {
        link->nTriggers++; // acknowledge 1st trigger
        if (link->nTriggers >= mMinTriggersToCache && linkFlags[ruIDSW][linkIDinRU] != HasEnoughTriggers) {
          nLEnoughTriggers++;
          linkFlags[ruIDSW][linkIDinRU] = HasEnoughTriggers;
        }
      }

      ptr += RDHUtils::getOffsetToNext(rdh);
      buffer.setPtr(ptr);
      if (buffer.getUnusedSize() < MaxGBTPacketBytes) {
        nRead += loadInput(buffer); // update
        ptr = buffer.getPtr();      // pointer might have been changed
      }

      rdh = reinterpret_cast<o2::header::RAWDataHeader*>(ptr);

      if (mNLinks == nLEnoughTriggers) {
        break;
      }

    } while (!buffer.isEmpty());

    if (mNLinks == nLEnoughTriggers) {
      mMinTriggersCached = mMinTriggersToCache; // wanted number of triggers acquired
    } else {                                    // there were no enough triggers to fulfill mMinTriggersToCache requirement
      mMinTriggersCached = INT_MAX;
      for (int ir = 0; ir < mNRUs; ir++) {
        const auto& ruDecData = mRUDecodeVec[ir];
        for (auto linkID : ruDecData.links) {
          const auto* link = getGBTLink(linkID);
          if (link && link->nTriggers < mMinTriggersCached) {
            mMinTriggersCached = link->nTriggers;
          }
        }
      }
    }
    mSWCache.Stop();
    LOG(info) << "Cached at least " << mMinTriggersCached << " triggers on " << mNLinks << " links of " << mNRUs << " RUs";

    return nRead;
  }

  //_____________________________________
  int decodeNextTrigger() final
  {
    // Decode next trigger from the cached links data and decrease cached triggers counter, return N links decoded
    if (mMinTriggersCached < 1) {
      cacheLinksData(mRawBuffer);
      if (mMinTriggersCached < 1) {
        return 0;
      }
    }
    int nlinks = 0;
    for (int ir = mNRUs; ir--;) {
      auto& ruDecode = mRUDecodeVec[ir];
      if (!nlinks) {                        // on 1st occasion extract trigger data
        for (auto linkID : ruDecode.links) { // loop over links to fill cable buffers
          auto* link = getGBTLink(linkID);
          if (link && !link->data.isEmpty()) {
            const auto rdh = reinterpret_cast<const o2::header::RAWDataHeader*>(link->data.getPtr());
            mInteractionRecord = RDHUtils::getTriggerIR(rdh);
            mTrigger = RDHUtils::getTriggerType(rdh);
            mInteractionRecordHB = RDHUtils::getHeartBeatIR(rdh);
            break;
          }
        }
      }

      nlinks += decodeNextRUData(ruDecode);
      mDecodingStat.nRUsProcessed++;
    }
    if (nlinks) {
      mDecodingStat.nTriggersProcessed++;
    }
    mCurRUDecodeID = 0;
    mMinTriggersCached--;
    return nlinks;
  }

  //_____________________________________
  int decodeNextRUData(RUDecodeData& ruDecData)
  {
    // process data of single RU trigger from its links buffers
    int minTriggers = INT_MAX;
    int res = 0;
    ruDecData.clear();
    bool aborted = false;
    for (auto linkID : ruDecData.links) { // loop over links to fill cable buffers
      auto* link = getGBTLink(linkID);
      if (link && !link->data.isEmpty()) {
        link->data.setPtr(decodeRUData(link->data.getPtr(), ruDecData, aborted));
        // we don't need to check the "abort" status since the checks for links data presence and synchronization
        // should have been done in advance
        if (--link->nTriggers < minTriggers) { // decrement counter of cached triggers
          minTriggers = link->nTriggers;
        }
        res++;
        if (link->data.isEmpty()) {
          link->data.clear();
        }
      }
    }
    if (ruDecData.nCables) {       // there are cables with data to decode
      decodeAlpideData(ruDecData); // decode Alpide data from the compressed RU Data
    }
    return res;
  }

  //_____________________________________
  bool findNextRDH(PayLoadCont& buffer)
  {
    // keep reading GRB words until RDH is found
    size_t nRead = 0;
    int scan = 0;
    bool goodRDH = false;
    auto ptr = buffer.getPtr();
    o2::header::RAWDataHeader* rdh = nullptr;
    do {
      if (buffer.isEmpty()) {
        auto nrl = loadInput(buffer);
        if (!nrl) {
          break;
        }
        nRead += nrl;
        ptr = buffer.getPtr();
      }
      scan++;
      ptr += o2::itsmft::GBTPaddedWordLength;
      buffer.setPtr(ptr);
      if (!buffer.isEmpty()) {
        rdh = reinterpret_cast<o2::header::RAWDataHeader*>(ptr);
      } else {
        break;
      }
    } while (!(goodRDH = RDHUtils::checkRDH(rdh)));
    LOG(info) << "End of pointer recovery after skipping " << scan << " GBT words, RDH is"
              << (goodRDH ? "" : " not") << " found";
    return goodRDH;
  }

  //_____________________________________
  uint8_t* decodeRUData(uint8_t* raw, RUDecodeData& ruDecData, bool& aborted)
  {
    /// Decode raw data of single RU (possibly in a few GBT packets), collecting raw data
    /// for every cable in the corresponding slot of the provided ruDecData.
    /// No check is done if the necessary data are fully contained in the raw buffer.
    /// Return the pointer on the last raw data byte after decoding the RU
    /// In case of unrecoverable error set aborted to true

    aborted = false;

    // data must start by RDH
    auto rdh = reinterpret_cast<o2::header::RAWDataHeader*>(raw);

#ifdef _RAW_READER_ERROR_CHECKS_
    if (!RDHUtils::checkRDH(rdh)) {
      LOG(error) << "Page does not start with RDH";
      RDHUtils::printRDH(rdh);
      for (int i = 0; i < 4; i++) {
        auto gbtD = reinterpret_cast<const o2::itsmft::GBTData*>(raw + i * 16);
        gbtD->printX(mPadding128);
      }
      raw += mGBTWordSize;
      aborted = true;
      return raw;
    }
#endif

    int ruIDSW = mMAP.FEEId2RUSW(RDHUtils::getFEEID(rdh));
#ifdef _RAW_READER_ERROR_CHECKS_
    if (ruIDSW >= mMAP.getNRUs()) {
      mDecodingStat.errorCounts[RawDecodingStat::ErrInvalidFEEId]++;
      LOG(error) << mDecodingStat.ErrNames[RawDecodingStat::ErrInvalidFEEId]
                 << " : FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << ", skipping CRU page";
      RDHUtils::printRDH(rdh);
      raw += RDHUtils::getOffsetToNext(rdh);
      return raw;
    }

    if (ruIDSW != ruDecData.ruInfo->idSW) { // should not happen with cached data
      LOG(error) << "RDG RU IDSW " << ruIDSW << " differs from expected " << ruDecData.ruInfo->idSW;
      RDHUtils::printRDH(rdh);
    }
#endif

    uint16_t lr, ruOnLr, linkIDinRU;
    mMAP.expandFEEId(RDHUtils::getFEEID(rdh), lr, ruOnLr, linkIDinRU);
    auto* ruLink = getGBTLink(ruDecData.links[linkIDinRU]);
    auto& ruLinkStat = ruLink->statistics;
    ruLink->lastRDH = reinterpret_cast<o2::header::RDHAny*>(rdh); // hack but this reader should be outphased anyway
    ruLinkStat.nPackets++;

#ifdef _RAW_READER_ERROR_CHECKS_
    if (RDHUtils::getPacketCounter(rdh) > ruLink->packetCounter + 1) {
      ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrPacketCounterJump]++;
      LOG(warn) << ruLinkStat.ErrNames[GBTLinkDecodingStat::ErrPacketCounterJump]
                << " : FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << ": jump from " << int(ruLink->packetCounter)
                << " to " << int(RDHUtils::getPacketCounter(rdh));
      RDHUtils::printRDH(rdh);
    }
#endif

    ruDecData.nCables = ruDecData.ruInfo->nCables;
    while (1) {
      ruLink->packetCounter = RDHUtils::getPacketCounter(rdh);

      mDecodingStat.nBytesProcessed += RDHUtils::getMemorySize(rdh);
      mDecodingStat.nPagesProcessed++;
      raw += RDHUtils::getHeaderSize(rdh);
      int nGBTWords = (RDHUtils::getMemorySize(rdh) - RDHUtils::getHeaderSize(rdh)) / mGBTWordSize - 2; // number of GBT words excluding header/trailer
      auto gbtH = reinterpret_cast<const o2::itsmft::GBTDataHeaderL*>(raw);                             // process GBT header

#ifdef _RAW_READER_ERROR_CHECKS_
      if (mVerbose) {
        RDHUtils::printRDH(rdh);
        gbtH->printX(mPadding128);
        LOG(info) << "Expect " << nGBTWords << " GBT words";
      }

      if (!gbtH->isDataHeader()) {
        gbtH->printX(mPadding128);
        LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " GBT payload header was expected, abort page decoding";
        RDHUtils::printRDH(rdh);
        ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrMissingGBTHeader]++;
        gbtH->printX(mPadding128);
        aborted = true;
        return raw;
      }

      if (gbtH->packetIdx != RDHUtils::getPageCounter(rdh)) {
        LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " Different GBT header " << gbtH->packetIdx
                   << " and RDH page " << RDHUtils::getPageCounter(rdh) << " counters";
        RDHUtils::printRDH(rdh);
        ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrRDHvsGBTHPageCnt]++;
      }

      if (ruLink->lanesActive == ruLink->lanesStop) { // all lanes received their stop, new page 0 expected
        if (RDHUtils::getPageCounter(rdh)) {          // flag lanes of this FEE
          LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " Non-0 page counter (" << RDHUtils::getPageCounter(rdh) << ") while all lanes were stopped";
          RDHUtils::printRDH(rdh);
          ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrNonZeroPageAfterStop]++;
        }
      }

      ruLink->lanesActive = gbtH->activeLanes; // TODO do we need to update this for every page?

      if (~(mMAP.getCablesOnRUType(ruDecData.ruInfo->ruType)) & ruLink->lanesActive) { // are there wrong lanes?
        std::bitset<32> expectL(mMAP.getCablesOnRUType(ruDecData.ruInfo->ruType)), gotL(ruLink->lanesActive);
        LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " Active lanes pattern " << gotL
                   << " conflicts with expected " << expectL << " for given RU type, skip page";
        RDHUtils::printRDH(rdh);
        ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrInvalidActiveLanes]++;
        raw = ((uint8_t*)rdh) + RDHUtils::getOffsetToNext(rdh); // jump to the next packet
        return raw;
      }

      if (!RDHUtils::getPageCounter(rdh)) { // reset flags
        ruLink->lanesStop = 0;
        ruLink->lanesWithData = 0;
      }

#endif
      raw += mGBTWordSize;
      for (int iw = 0; iw < nGBTWords; iw++, raw += mGBTWordSize) {
        auto gbtD = reinterpret_cast<const o2::itsmft::GBTData*>(raw);
        // TODO: need to clarify if the nGBTWords from the RDHUtils::getMemorySize(rdh) is reliable estimate of the real payload, at the moment this is not the case

        if (mVerbose > 1) {
          printf("W%4d |", iw);
          gbtD->printX(mPadding128);
        }
        if (gbtD->isDataTrailer()) {
          nGBTWords = iw;
          break; // this means that the nGBTWords estimate was wrong
        }

        int cableHW = gbtD->getCableID();
        int cableSW = mMAP.cableHW2SW(ruDecData.ruInfo->ruType, cableHW);
        ruDecData.cableData[cableSW].add(gbtD->getW8(), 9);
        ruDecData.cableHWID[cableSW] = cableHW;

#ifdef _RAW_READER_ERROR_CHECKS_
        int cableHWPos = mMAP.cableHW2Pos(ruDecData.ruInfo->ruType, cableHW);
        ruDecData.cableLinkID[cableSW] = linkIDinRU;
        ruLink->lanesWithData |= 0x1 << cableHWPos;    // flag that the data was seen on this lane
        if (ruLink->lanesStop & (0x1 << cableHWPos)) { // make sure stopped lanes do not transmit the data
          ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrDataForStoppedLane]++;
          LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " Data received for stopped lane " << cableHW << " (sw:" << cableSW << ")";
          RDHUtils::printRDH(rdh);
        }
#endif

      } // we are at the trailer, packet is over, check if there are more for the same ru

      auto gbtT = reinterpret_cast<const o2::itsmft::GBTDataTrailer*>(raw); // process GBT trailer
#ifdef _RAW_READER_ERROR_CHECKS_

      if (mVerbose) {
        gbtT->printX(mPadding128);
      }

      if (!gbtT->isDataTrailer()) {
        gbtT->printX(mPadding128);
        LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << std::dec
                   << " GBT payload trailer was expected, abort page decoding NW" << nGBTWords;
        RDHUtils::printRDH(rdh);
        ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrMissingGBTTrailer]++;
        aborted = true;
        return raw;
      }

      ruLink->lanesTimeOut |= gbtT->lanesTimeout; // register timeouts
      ruLink->lanesStop |= gbtT->lanesStops;      // register stops
#endif
      raw += mGBTWordSize;
      // we finished the GBT page, see if there is a continuation and if it belongs to the same multipacket

      if (!RDHUtils::getOffsetToNext(rdh)) { // RS TODO: what the last page in memory will contain as offsetToNext, is it 0?
        break;
      }

      raw = ((uint8_t*)rdh) + RDHUtils::getOffsetToNext(rdh); // jump to the next packet:
      auto rdhN = reinterpret_cast<o2::header::RAWDataHeader*>(raw);
      // check if data of given RU are over, i.e. we the page counter was wrapped to 0 (should be enough!) or other RU/trigger started
      if (!isSameRUandTrigger(rdh, rdhN)) {

#ifdef _RAW_READER_ERROR_CHECKS_
        // make sure all lane stops for finished page are received
        if ((ruLink->lanesActive & ~ruLink->lanesStop) && nGBTWords) {
          if (RDHUtils::getTriggerType(rdh) != o2::trigger::SOT) { // only SOT trigger allows unstopped lanes?
            std::bitset<32> active(ruLink->lanesActive), stopped(ruLink->lanesStop);
            LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " end of FEE data but not all lanes received stop"
                       << "| active: " << active << " stopped: " << stopped;
            RDHUtils::printRDH(rdh);
            ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrUnstoppedLanes]++;
          }
        }

        // make sure all active lanes (except those in time-out) have sent some data
        if ((~ruLink->lanesWithData & ruLink->lanesActive) != ruLink->lanesTimeOut && nGBTWords) {
          std::bitset<32> withData(ruLink->lanesWithData), active(ruLink->lanesActive), timeOut(ruLink->lanesTimeOut);
          LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " Lanes not in time-out but not sending data"
                     << "\n| with data: " << withData << " active: " << active << " timeOut: " << timeOut;
          RDHUtils::printRDH(rdh);
          ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrNoDataForActiveLane]++;
        }
#endif
        // accumulate packet states
        ruLinkStat.packetStates[gbtT->getPacketState()]++;

        break;
      }
#ifdef _RAW_READER_ERROR_CHECKS_
      // check if the page counter increases
      if (RDHUtils::getPageCounter(rdhN) != RDHUtils::getPageCounter(rdh) + 1) {
        LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " Discontinuity in the RDH page counter of the same RU trigger: old "
                   << RDHUtils::getPageCounter(rdh) << " new: " << RDHUtils::getPageCounter(rdhN);
        RDHUtils::printRDH(rdh);
        RDHUtils::printRDH(rdhN);
        ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrPageCounterDiscontinuity]++;
      }
#endif
      rdh = rdhN;
      ruLink->lastRDH = reinterpret_cast<o2::header::RDHAny*>(rdh);
    }

#ifdef _RAW_READER_ERROR_CHECKS_
//    if (RDHUtils::getPageCounter(rdh) && !RDHUtils::getStop(rdh)) {
//      LOG(warning) << "Last packet(" << RDHUtils::getPageCounter(rdh) << ") of GBT multi-packet is reached w/o STOP set in the RDH";
//    }
#endif

    return raw;
  }

  //_____________________________________
  int skimNextRUData(PayLoadCont& outBuffer)
  {
    if (mIOFile) {
      loadInput(mRawBuffer); // if needed, upload additional data to the buffer
    }

    int res = 0;
    if (!mRawBuffer.isEmpty()) {
      bool aborted = false;

      auto ptr = skimPaddedRUData(mRawBuffer.getPtr(), outBuffer, aborted);
      mDecodingStat.nRUsProcessed++;
      if (!aborted) {
        mRawBuffer.setPtr(ptr);
        res = 1; // success
        if (mRawBuffer.isEmpty()) {
          mRawBuffer.clear();
        }
      } else { // try to seek to the next RDH, can be done only for 128b padded GBT words
        if (findNextRDH(mRawBuffer)) {
          ptr = mRawBuffer.getPtr();
          res = 1;
        } else {
          mRawBuffer.clear(); // did not find new RDH
        }
      } // try to seek to the next ...
    }
    return res;
  }

  //_____________________________________
  uint8_t* skimPaddedRUData(uint8_t* raw, PayLoadCont& outBuffer, bool& aborted)
  {
    /// Skim CRU data with 128b-padded GBT words and fixed 8KB pages to 80b-GBT words and
    /// page size corresponding to real payload.

    aborted = false;

    // data must start by RDH
    auto rdh = reinterpret_cast<o2::header::RAWDataHeader*>(raw);
#ifdef _RAW_READER_ERROR_CHECKS_
    if (!RDHUtils::checkRDH(rdh)) {
      LOG(error) << "Page does not start with RDH";
      RDHUtils::printRDH(rdh);
      for (int i = 0; i < 4; i++) {
        auto gbtD = reinterpret_cast<const o2::itsmft::GBTData*>(raw + i * 16);
        gbtD->printX(mPadding128);
      }
      aborted = true;
      return raw;
    }
    int ruIDSWD = mMAP.FEEId2RUSW(RDHUtils::getFEEID(rdh));
    if (ruIDSWD >= mMAP.getNRUs()) {
      mDecodingStat.errorCounts[RawDecodingStat::ErrInvalidFEEId]++;
      LOG(error) << mDecodingStat.ErrNames[RawDecodingStat::ErrInvalidFEEId]
                 << " : FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << ", skipping CRU page";
      RDHUtils::printRDH(rdh);
      raw += RDHUtils::getOffsetToNext(rdh);
      return raw;
    }
#endif
    uint16_t lr, ruOnLr, linkIDinRU;
    mMAP.expandFEEId(RDHUtils::getFEEID(rdh), lr, ruOnLr, linkIDinRU);
    int ruIDSW = mMAP.FEEId2RUSW(RDHUtils::getFEEID(rdh));
    auto& ruDecode = getCreateRUDecode(ruIDSW);
    auto ruInfo = mMAP.getRUInfoSW(ruIDSW);

    if (ruDecode.links[linkIDinRU] < 0) {
      ruDecode.links[linkIDinRU] = addGBTLink();
      getGBTLink(ruDecode.links[linkIDinRU])->statistics.feeID = RDHUtils::getFEEID(rdh);
      mNLinks++;
    }

    mInteractionRecord = RDHUtils::getTriggerIR(rdh);

    mTrigger = RDHUtils::getTriggerType(rdh);

    mInteractionRecordHB = RDHUtils::getHeartBeatIR(rdh);

    auto ruLink = getGBTLink(ruDecode.links[linkIDinRU]);
    auto& ruLinkStat = ruLink->statistics;
    ruLink->lastRDH = reinterpret_cast<o2::header::RDHAny*>(rdh); // hack but this reader should be outphased anyway
    ruLinkStat.nPackets++;

#ifdef _RAW_READER_ERROR_CHECKS_
    if (RDHUtils::getPacketCounter(rdh) > ruLink->packetCounter + 1) {
      ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrPacketCounterJump]++;
      LOG(warn) << ruLinkStat.ErrNames[GBTLinkDecodingStat::ErrPacketCounterJump]
                << " : FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << ": jump from " << int(ruLink->packetCounter)
                << " to " << int(RDHUtils::getPacketCounter(rdh));
      RDHUtils::printRDH(rdh);
    }
#endif
    ruLink->packetCounter = RDHUtils::getPacketCounter(rdh);

    int sizeAtEntry = outBuffer.getSize(); // save the size of outbuffer size at entry, in case of severe error we will need to rewind to it.

    while (1) {
      mDecodingStat.nPagesProcessed++;
      mDecodingStat.nBytesProcessed += RDHUtils::getMemorySize(rdh);
      raw += RDHUtils::getHeaderSize(rdh);
      // number of 128 b GBT words excluding header/trailer
      int nGBTWords = (RDHUtils::getMemorySize(rdh) - RDHUtils::getHeaderSize(rdh)) / o2::itsmft::GBTPaddedWordLength - 2;
      auto gbtH = reinterpret_cast<const o2::itsmft::GBTDataHeaderL*>(raw); // process GBT header

#ifdef _RAW_READER_ERROR_CHECKS_
      if (mVerbose) {
        RDHUtils::printRDH(rdh);
        gbtH->printX(true);
        LOG(info) << "Expect " << nGBTWords << " GBT words";
      }
      if (!gbtH->isDataHeader()) {
        gbtH->printX(true);
        LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " GBT payload header was expected, abort page decoding";
        RDHUtils::printRDH(rdh);
        gbtH->printX(true);
        ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrMissingGBTHeader]++;
        aborted = true;
        outBuffer.shrinkToSize(sizeAtEntry); // reset output buffer to initial state
        return raw;
      }
      if (gbtH->packetIdx != RDHUtils::getPageCounter(rdh)) {
        LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " Different GBT header " << gbtH->packetIdx
                   << " and RDH page " << RDHUtils::getPageCounter(rdh) << " counters";
        RDHUtils::printRDH(rdh);
        ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrRDHvsGBTHPageCnt]++;
      }

      if (ruLink->lanesActive == ruLink->lanesStop) { // all lanes received their stop, new page 0 expected
        if (RDHUtils::getPageCounter(rdh)) {          // flag lanes of this FEE
          LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " Non-0 page counter (" << RDHUtils::getPageCounter(rdh) << ") while all lanes were stopped";
          RDHUtils::printRDH(rdh);
          ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrNonZeroPageAfterStop]++;
        }
      }

      ruLink->lanesActive = gbtH->activeLanes; // TODO do we need to update this for every page?

      if (!RDHUtils::getPageCounter(rdh)) { // reset flags
        ruLink->lanesStop = 0;
        ruLink->lanesWithData = 0;
      }

#endif
      // start writting skimmed data for this page, making sure the buffer has enough free slots
      outBuffer.ensureFreeCapacity(8 * 1024);
      auto rdhS = reinterpret_cast<o2::header::RAWDataHeader*>(outBuffer.getEnd()); // save RDH and make saved copy editable
      outBuffer.addFast(reinterpret_cast<const uint8_t*>(rdh), RDHUtils::getHeaderSize(rdh));

      outBuffer.addFast(reinterpret_cast<const uint8_t*>(gbtH), mGBTWordSize); // save gbt header w/o 128b padding

      raw += o2::itsmft::GBTPaddedWordLength;
      for (int iw = 0; iw < nGBTWords; iw++, raw += o2::itsmft::GBTPaddedWordLength) {
        auto gbtD = reinterpret_cast<const o2::itsmft::GBTData*>(raw);
        // TODO: need to clarify if the nGBTWords from the RDHUtils::getMemorySize(rdh) is reliable estimate of the real payload, at the moment this is not the case

        if (mVerbose > 1) {
          printf("W%4d |", iw);
          gbtD->printX(mPadding128);
        }
        if (gbtD->isDataTrailer()) {
          nGBTWords = iw;
          break; // this means that the nGBTWords estimate was wrong
        }

        int cableHW = gbtD->getCableID();
        int cableSW = mMAP.cableHW2SW(ruInfo->ruType, cableHW);

        outBuffer.addFast(reinterpret_cast<const uint8_t*>(gbtD), mGBTWordSize); // save gbt word w/o 128b padding

#ifdef _RAW_READER_ERROR_CHECKS_
        int cableHWPos = mMAP.cableHW2Pos(ruInfo->ruType, cableHW);
        ruLink->lanesWithData |= 0x1 << cableHWPos;    // flag that the data was seen on this lane
        if (ruLink->lanesStop & (0x1 << cableHWPos)) { // make sure stopped lanes do not transmit the data
          ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrDataForStoppedLane]++;
          LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " Data received for stopped lane " << cableHW << " (sw:" << cableSW << ")";
          RDHUtils::printRDH(rdh);
        }
#endif

      } // we are at the trailer, packet is over, check if there are more for the same ru

      auto gbtT = reinterpret_cast<const o2::itsmft::GBTDataTrailer*>(raw); // process GBT trailer
#ifdef _RAW_READER_ERROR_CHECKS_

      if (mVerbose) {
        gbtT->printX(true);
      }

      if (!gbtT->isDataTrailer()) {
        gbtT->printX(true);
        LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " GBT payload trailer was expected, abort page decoding at NW" << nGBTWords;
        RDHUtils::printRDH(rdh);
        ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrMissingGBTTrailer]++;
        aborted = true;
        outBuffer.shrinkToSize(sizeAtEntry); // reset output buffer to initial state
        return raw;
      }

      ruLink->lanesTimeOut |= gbtT->lanesTimeout; // register timeouts
      ruLink->lanesStop |= gbtT->lanesStops;      // register stops
#endif

      outBuffer.addFast(reinterpret_cast<const uint8_t*>(gbtT), mGBTWordSize); // save gbt trailer w/o 128b padding

      raw += o2::itsmft::GBTPaddedWordLength;

      // we finished the GBT page, register in the stored RDH the memory size and new offset
      RDHUtils::setMemorySize(rdhS, RDHUtils::getHeaderSize(rdhS) + (2 + nGBTWords) * mGBTWordSize);
      RDHUtils::setOffsetToNext(rdhS, RDHUtils::getMemorySize(rdhS));

      if (!RDHUtils::getOffsetToNext(rdh)) { // RS TODO: what the last page in memory will contain as offsetToNext, is it 0?
        break;
      }

      raw = ((uint8_t*)rdh) + RDHUtils::getOffsetToNext(rdh); // jump to the next packet:
      auto rdhN = reinterpret_cast<o2::header::RAWDataHeader*>(raw);
      // check if data of given RU are over, i.e. we the page counter was wrapped to 0 (should be enough!) or other RU/trigger started
      if (!isSameRUandTrigger(rdh, rdhN)) {

#ifdef _RAW_READER_ERROR_CHECKS_
        // make sure all lane stops for finished page are received
        if (ruLink->lanesActive != ruLink->lanesStop && nGBTWords) {
          if (RDHUtils::getTriggerType(rdh) != o2::trigger::SOT) { // only SOT trigger allows unstopped lanes?
            std::bitset<32> active(ruLink->lanesActive), stopped(ruLink->lanesStop);
            LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " end of FEE data but not all lanes received stop"
                       << "| active: " << active << " stopped: " << stopped;
            RDHUtils::printRDH(rdh);
            ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrUnstoppedLanes]++;
          }
        }

        // make sure all active lanes (except those in time-out) have sent some data
        if ((~ruLink->lanesWithData & ruLink->lanesActive) != ruLink->lanesTimeOut && nGBTWords) {
          std::bitset<32> withData(ruLink->lanesWithData), active(ruLink->lanesActive), timeOut(ruLink->lanesTimeOut);
          LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " Lanes not in time-out but not sending data"
                     << "| with data: " << withData << " active: " << active << " timeOut: " << timeOut;
          RDHUtils::printRDH(rdh);
          ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrNoDataForActiveLane]++;
        }

        // accumulate packet states
        ruLinkStat.packetStates[gbtT->getPacketState()]++;
#endif

        break;
      }
#ifdef _RAW_READER_ERROR_CHECKS_
      // check if the page counter increases
      if (RDHUtils::getPageCounter(rdhN) != RDHUtils::getPageCounter(rdh) + 1) {
        LOG(error) << "FEEId:" << OUTHEX(RDHUtils::getFEEID(rdh), 4) << " Discontinuity in the RDH page counter of the same RU trigger: old "
                   << RDHUtils::getPageCounter(rdh) << " new: " << RDHUtils::getPageCounter(rdhN);
        RDHUtils::printRDH(rdh);
        RDHUtils::printRDH(rdhN);
        ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrPageCounterDiscontinuity]++;
      }
#endif
      rdh = rdhN;
      ruLink->lastRDH = reinterpret_cast<o2::header::RDHAny*>(rdh); // hack but this reader should be outphased anyway
    }

#ifdef _RAW_READER_ERROR_CHECKS_
//    if (RDHUtils::getPageCounter(rdh) && !RDHUtils::getStop(rdh)) {
//      LOG(warning) << "Last packet(" << RDHUtils::getPageCounter(rdh) << ") of GBT multi-packet is reached w/o STOP set in the RDH";
//    }
#endif

    return raw;
  }

  //_____________________________________
  bool isSameRUandTrigger(const o2::header::RAWDataHeader* rdhOld, const o2::header::RAWDataHeader* rdhNew) const
  {
    /// check if the rdhNew is just a continuation of the data described by the rdhOld
    if (RDHUtils::getPageCounter(rdhNew) == 0 || RDHUtils::getFEEID(rdhNew) != RDHUtils::getFEEID(rdhOld) ||
        RDHUtils::getTriggerIR(rdhNew) != RDHUtils::getTriggerIR(rdhOld) ||
        RDHUtils::getHeartBeatIR(rdhNew) != RDHUtils::getHeartBeatIR(rdhOld) ||
        !(RDHUtils::getTriggerType(rdhNew) & RDHUtils::getTriggerType(rdhOld))) {
      return false;
    }
    return true;
  }

  //_____________________________________
  int decodeAlpideData(RUDecodeData& decData)
  {
    /// decode the ALPIDE data from the buffer of single lane

    auto* chipData = &decData.chipsData[0];

    decData.nChipsFired = decData.lastChipChecked = 0;
    int ntot = 0;
    for (int icab = 0; icab < decData.nCables; icab++) {
      auto& cableData = decData.cableData[icab];
      int res = 0;

#ifdef _RAW_READER_ERROR_CHECKS_
      auto& ruLinkStat = getGBTLink(decData.links[decData.cableLinkID[icab]])->statistics;

      // make sure the lane data starts with chip header or empty chip
      uint8_t h;
      if (cableData.current(h) && !mCoder.isChipHeaderOrEmpty(h)) {
        LOG(error) << "FEEId:" << OUTHEX(decData.ruInfo->idHW, 4) << " cable " << icab
                   << " data does not start with ChipHeader or ChipEmpty";
        ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrCableDataHeadWrong]++;
        RDHUtils::printRDH(reinterpret_cast<const o2::header::RAWDataHeader*>(getGBTLink(decData.links[decData.cableLinkID[icab]])->lastRDH));
      }
#endif
      auto cabHW = decData.cableHWID[icab];
      auto ri = decData.ruInfo;
      auto chIdGetter = [this, cabHW, ri](int cid) {
        return this->mMAP.getGlobalChipID(cid, cabHW, *ri);
      };
      while ((res = mCoder.decodeChip(*chipData, cableData, chIdGetter))) { // we register only chips with hits or errors flags set
        if (res > 0) {
#ifdef _RAW_READER_ERROR_CHECKS_
          // for the IB staves check if the cable ID is the same as the chip ID on the module
          if (mMAP.getName() == "ITS" && decData.ruInfo->ruType == 0) { // ATTENTION: this is a hack tailored for temporary check
            if (chipData->getChipID() != icab) {
              LOG(error) << "FEEId:" << OUTHEX(decData.ruInfo->idHW, 4) << " IB cable " << icab
                         << " shipped chip ID= " << chipData->getChipID();
              ruLinkStat.errorCounts[GBTLinkDecodingStat::ErrIBChipLaneMismatch]++;
              RDHUtils::printRDH(reinterpret_cast<const o2::header::RAWDataHeader*>(getGBTLink(decData.links[decData.cableLinkID[icab]])->lastRDH));
            }
          }
#endif
          // convert HW chip id within the module to absolute chip id
          // chipData->setChipID(mMAP.getGlobalChipID(chipData->getChipID(), decData.cableHWID[icab], *decData.ruInfo));
          chipData->setInteractionRecord(mInteractionRecord);
          chipData->setTrigger(mTrigger);
          mDecodingStat.nNonEmptyChips++;
          mDecodingStat.nHitsDecoded += chipData->getData().size();
          ntot += res;
          // fetch next free chip
          if (++decData.nChipsFired < int(decData.chipsData.size())) {
            chipData = &decData.chipsData[decData.nChipsFired];
          } else {
            break; // last chip decoded
          }
        }
      }
    }
    return ntot;
  }

  //_____________________________________
  bool getNextChipData(ChipPixelData& chipData) override
  {
    /// read single chip data to the provided container

    if (mCurRUDecodeID >= 0) { // make sure current RU has fired chips to extract
      for (; mCurRUDecodeID < mNRUs; mCurRUDecodeID++) {
        auto& ru = mRUDecodeVec[mCurRUDecodeID];
        if (ru.lastChipChecked < ru.nChipsFired) {
          chipData.swap(ru.chipsData[ru.lastChipChecked++]);
          return true;
        }
      }
      mCurRUDecodeID = 0; // no more decoded data if reached this place,
    }

    // will need to decode new trigger
    if (!mDecodeNextAuto) { // no more data in the current ROF and no automatic decoding of next one was requested
      return false;
    }

    if (mMinTriggersCached < 2) { // last trigger might be incomplete, need to cache more data
      cacheLinksData(mRawBuffer);
    }
    if (mMinTriggersCached < 1 || !decodeNextTrigger()) {
      mCurRUDecodeID = -1;
      return false; // nothing left
    }
    return getNextChipData(chipData); // is it ok to use recursion here?
  }

  //_____________________________________
  void openInput(const std::string filename)
  {
    // open input for raw data decoding from file
    mSWIO.Stop();
    mSWIO.Start();
    clear(false); // do not reset statistics
    LOG(info) << "opening raw data input file " << filename;
    mIOFile.open(filename.c_str(), std::ifstream::binary);
    assert(mIOFile.good());
    mRawBuffer.clear();
    mRawBuffer.expand(RawBufferSize);
    mSWIO.Stop();
  }

  //_____________________________________
  size_t loadInput(PayLoadCont& buffer)
  {
    /// assure the buffers are large enough
    static_assert(RawBufferMargin > MaxGBTPacketBytes * 100 &&
                    RawBufferSize > 3 * RawBufferMargin,
                  "raw buffer size is too small");

    if (!mIOFile) {
      return 0;
    }
    if (buffer.getUnusedSize() > RawBufferMargin) { // bytes read but not used yet are enough
      return 0;
    }
    mSWIO.Start(false);
    auto readFromFile = [this](uint8_t* ptr, int n) {
      mIOFile.read(reinterpret_cast<char*>(ptr), n);
      return mIOFile.gcount(); // fread( ptr, sizeof(uint8_t), n, mIOFile);
    };
    auto nread = buffer.append(readFromFile);
    mSWIO.Stop();
    return nread;
  }

  // get statics of FEE with sequential idSW
  const GBTLinkDecodingStat* getGBTLinkDecodingStatSW(uint16_t idSW, int ruLink) const
  {
    if (mRUEntry[idSW] < 0 || ruLink >= RUDecodeData::MaxLinksPerRU || mRUDecodeVec[mRUEntry[idSW]].links[ruLink] < 0) {
      return nullptr;
    } else {
      return &getGBTLink(mRUDecodeVec[mRUEntry[idSW]].links[ruLink])->statistics;
    }
  }

  // get statics of FEE with given HW id
  const GBTLinkDecodingStat* getGBTLinkDecodingStatHW(uint16_t idHW, int ruLink) const
  {
    int idsw = mMAP.FEEId2RUSW(idHW);
    assert(idsw != 0xffff);
    return getGBTLinkDecodingStatSW(idsw, ruLink);
  }

  // aliases for BWD compatibility
  const GBTLinkDecodingStat* getRUDecodingStatSW(uint16_t idSW, int ruLink = 0) const { return getGBTLinkDecodingStatSW(idSW, ruLink); }
  const GBTLinkDecodingStat* getRUDecodingStatHW(uint16_t idHW, int ruLink = 0) const { return getGBTLinkDecodingStatHW(idHW, ruLink); }

  // get global decoding statistics
  const RawDecodingStat& getDecodingStat() const { return mDecodingStat; }

  void setVerbosity(int v) { mVerbose = v; }
  int getVerbosity() const { return mVerbose; }

  Mapping& getMapping() { return mMAP; }

  // get currently processed RU container
  const RUDecodeData* getCurrRUDecodeData() const { return mCurRUDecodeID < 0 ? nullptr : &mRUDecodeVec[mCurRUDecodeID]; }

  PayLoadCont& getRawBuffer() { return mRawBuffer; }

  // number of links seen in the data
  int getNLinks() const { return mNLinks; }

  // number of RUs seen in the data
  int getNRUs() const { return mNRUs; }

  // get vector of RU decode containers for RUs seen in the data
  const std::array<RUDecodeData, Mapping::getNRUs()>& getRUDecodeVec() const { return mRUDecodeVec; }

  const std::array<int, Mapping::getNRUs()>& getRUEntries() const { return mRUEntry; }

  // get RU decode container for RU with given SW ID
  const RUDecodeData* getRUDecode(int ruSW) const
  {
    return mRUEntry[ruSW] < 0 ? nullptr : &mRUDecodeVec[mRUEntry[ruSW]];
  }

  // get RU decode container for RU with given SW ID, if does not exist, create it
  RUDecodeData& getCreateRUDecode(int ruSW)
  {
    assert(ruSW < mMAP.getNRUs());
    if (mRUEntry[ruSW] < 0) {
      mRUEntry[ruSW] = mNRUs++;
      mRUDecodeVec[mRUEntry[ruSW]].ruInfo = mMAP.getRUInfoSW(ruSW); // info on the stave/RU
      mRUDecodeVec[mRUEntry[ruSW]].chipsData.resize(mMAP.getNChipsOnRUType(mMAP.getRUInfoSW(ruSW)->ruType));
      LOG(info) << "Defining container for RU " << ruSW << " at slot " << mRUEntry[ruSW];
    }
    return mRUDecodeVec[mRUEntry[ruSW]];
  }

  // create new gbt link
  int addGBTLink()
  {
    int sz = mGBTLinks.size();
    mGBTLinks.emplace_back();
    return sz;
  }

  // get the link
  GBTLink* getGBTLink(int i) { return i < 0 ? nullptr : &mGBTLinks[i]; }
  const GBTLink* getGBTLink(int i) const { return i < 0 ? nullptr : &mGBTLinks[i]; }

 private:
  std::ifstream mIOFile;
  Coder mCoder;
  Mapping mMAP;
  int mVerbose = 0;        //! verbosity level
  int mCurRUDecodeID = -1; //! index of currently processed RUDecode container

  PayLoadCont mRawBuffer; //! buffer for binary raw data file IO

  std::array<RUDecodeData, Mapping::getNRUs()> mRUDecodeVec;        // decoding buffers for all active RUs
  std::array<int, Mapping::getNRUs()> mRUEntry;                     //! entry of the RU with given SW ID in the mRUDecodeVec
  std::vector<GBTLink> mGBTLinks;
  int mNRUs = 0;                                                    //! total number of RUs seen
  int mNLinks = 0;                                                  //! total number of GBT links seen

  //! min number of triggers to cache per link (keep this > N pages per CRU superpage)
  int mMinTriggersToCache = NCRUPagesPerSuperpage + 10;
  int mMinTriggersCached = 0; //! actual minimum (among different links) number of triggers to cache

  // statistics
  RawDecodingStat mDecodingStat; //! global decoding statistics

  TStopwatch mSWIO; //! timer for IO operations
  TStopwatch mSWCache; //! timer for caching operations

  static constexpr int RawBufferMargin = 5000000;                      // keep uploaded at least this amount
  static constexpr int RawBufferSize = 10000000 + 2 * RawBufferMargin; // size in MB
  bool mPadding128 = true;                                             // is payload padded to 128 bits
  bool mImposeMaxPage = true;                                          // standard CRU data comes in 8KB pages
  // number of bytes the GBT word, including optional padding to 128 bits
  int mGBTWordSize = mPadding128 ? o2::itsmft::GBTPaddedWordLength : o2::itsmft::GBTWordLength;

  ClassDefOverride(RawPixelReader, 1);
};

template <class Mapping>
constexpr int RawPixelReader<Mapping>::RawBufferMargin;

template <class Mapping>
constexpr int RawPixelReader<Mapping>::RawBufferSize;

} // namespace itsmft
} // namespace o2

#endif /* ALICEO2_ITS_RAWPIXELREADER_H */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file PixelData.h
/// \brief Transient data classes for single pixel and set of pixels from current chip
#ifndef ALICEO2_ITSMFT_PIXELDATA_H
#define ALICEO2_ITSMFT_PIXELDATA_H

#include "DataFormatsITSMFT/Digit.h"
#include "CommonDataFormat/InteractionRecord.h"
#include "ITSMFTReconstruction/DecodingStat.h"

#include <string>
#include <vector>
#include <utility>
#include <cstdint>

namespace o2
{
namespace itsmft
{

///< single pixel datum, with possibility to set a flag of pixel being masked out
class PixelData
{

 public:
  PixelData(const Digit* dig) : mRow(dig->getRow()), mCol(dig->getColumn()) {}
  PixelData(uint16_t r = 0, uint16_t c = 0) : mRow(r), mCol(c) {}
  uint16_t getRow() const { return mRow & RowMask; }
  uint16_t getCol() const { return mCol; }
  bool isMasked() const { return mRow & MaskBit; }
  void setMask() { mRow |= MaskBit; }
  void unsetMask() { mRow &= RowMask; }

  /// for faster access when the pixel is guaranteed to not be masked
  uint16_t getRowDirect() const { return mRow; }

  bool operator==(const PixelData& dt) const
  {
    ///< check if one pixel is equal to another
    return (getCol() == dt.getCol()) && (getRow() == dt.getRow());
  }

  bool operator>(const PixelData& dt) const
  {
    ///< check if one pixel is greater than another (first column then row)
    if (getCol() == dt.getCol()) {
      return getRow() > dt.getRow();
    }
    return getCol() > dt.getCol();
  }

  bool operator<(const PixelData& dt) const
  {
    ///< check if one pixel is lesser than another (first column then row)
    if (getCol() == dt.getCol()) {
      return getRow() < dt.getRow();
    }
    return getCol() < dt.getCol();
  }

  bool isNeighbour(const PixelData& dt, int maxDist) const
  {
    ///< check if one pixel is in proximity of another
    return (std::abs(static_cast<int>(getCol()) - static_cast<int>(dt.getCol())) <= maxDist &&
            std::abs(static_cast<int>(getRow()) - static_cast<int>(dt.getRow())) <= maxDist);
  }

  int compare(const PixelData& dt) const
  {
    ///< compare to pixels (first column then row)
    return operator==(dt) ? 0 : (operator>(dt) ? 1 : -1);
  }

  static constexpr uint32_t DummyROF = 0xffffffff;
  static constexpr uint32_t DummyChipID = 0xffff;

 private:
  void sanityCheck() const;
  static constexpr int RowMask = 0x7FFF; ///< 32768 rows are supported
  static constexpr int MaskBit = 0x8000; ///< 16-th bit is used to flag masked pixel
  uint16_t mRow = 0;                    ///< pixel row
  uint16_t mCol = 0;                    ///< pixel column

  ClassDefNV(PixelData, 1);
};

///< Transient data for single chip fired pixeld
///< Assumes that the digits data is sorted in chip/col/row
class ChipPixelData
{

 public:
  // total number of raw data bytes to save in case of error and number of bytes (if any) after problematic one
  static constexpr size_t MAXDATAERRBYTES = 16, MAXDATAERRBYTES_AFTER = 2;
  ChipPixelData() = default;
  ~ChipPixelData() = default;
  uint8_t getROFlags() const { return mROFlags; }
  uint16_t getChipID() const { return mChipID; }
  uint32_t getROFrame() const { return mROFrame; }
  uint32_t getStartID() const { return mStartID; }
  uint32_t getFirstUnmasked() const { return mFirstUnmasked; }
  uint32_t getTrigger() const { return mTrigger; }
  const o2::InteractionRecord& getInteractionRecord() const { return mInteractionRecord; }
  void setInteractionRecord(const o2::InteractionRecord& r) { mInteractionRecord = r; }
  const std::vector<PixelData>& getData() const { return mPixels; }
  std::vector<PixelData>& getData() { return (std::vector<PixelData>&)mPixels; }

  void setROFlags(uint8_t f = 0) { mROFlags = f; }
  void setChipID(uint16_t id) { mChipID = id; }
  void setROFrame(uint32_t r) { mROFrame = r; }
  void setStartID(uint32_t id) { mStartID = id; }
  void setFirstUnmasked(uint32_t n) { mFirstUnmasked = n; }
  void setTrigger(uint32_t t) { mTrigger = t; }

  void setError(ChipStat::DecErrors i) { mErrors |= 0x1 << i; }
  void addErrorInfo(uint64_t b) { mErrorInfo |= b; }
  void setErrorFlags(uint32_t f) { mErrors |= f; }
  bool isErrorSet(ChipStat::DecErrors i) const { return mErrors & (0x1 << i); }
  bool isErrorSet() const { return mErrors != 0; }
  auto getErrorFlags() const { return mErrors; }
  auto getErrorInfo() const { return mErrorInfo; }
  auto getNBytesInRawBuff() const { return int(mErrorInfo >> 32) & 0xff; }
  void setNBytesInRawBuff(int n) { mErrorInfo |= (uint64_t(n & 0xff)) << 32; }
  auto& getRawErrBuff() { return mRawBuff; }
  auto& getRawErrBuff() const { return mRawBuff; }
  std::string getErrorDetails(int pos) const;

  void resetChipID()
  {
    mChipID = -1;
  }

  void clear()
  {
    resetChipID();
    mPixels.clear();
    mROFlags = 0;
    mFirstUnmasked = 0;
    mErrors = 0;
    mErrorInfo = 0;
  }

  void swap(ChipPixelData& other)
  {
    // swap content of two objects
    std::swap(mROFlags, other.mROFlags);
    std::swap(mChipID, other.mChipID);
    std::swap(mROFrame, other.mROFrame);
    std::swap(mFirstUnmasked, other.mFirstUnmasked); // strictly speaking, not needed
    std::swap(mStartID, other.mStartID);             // strictly speaking, not needed
    std::swap(mTrigger, other.mTrigger);
    std::swap(mErrors, other.mErrors);
    std::swap(mInteractionRecord, other.mInteractionRecord);
    mPixels.swap(other.mPixels);
  }

  void maskFiredInSample(const ChipPixelData& sample)
  {
    ///< mask in the current data pixels fired in provided sample
    const auto& pixelsS = sample.getData();
    uint32_t nC = mPixels.size();
    if (!nC) {
      return;
    }
    uint32_t nS = pixelsS.size();
    if (!nS) {
      return;
    }
    uint32_t itC = 0, itS = 0;
    while (itC < nC && itS < nS) {
      auto& pix0 = mPixels[itC];
      const auto& pixC = pixelsS[itS];
      if (pix0 == pixC) { // same
        pix0.setMask();
        if (mFirstUnmasked == itC++) { // mFirstUnmasked should flag 1st unmasked pixel entry
          mFirstUnmasked = itC;
        }
        itS++;
      } else if (pix0 < pixC) {
        itC++;
      } else {
        itS++;
      }
    }
  }

  void maskFiredInSample(const ChipPixelData& sample, int maxDist)
  {
    ///< mask in the current data pixels (or their neighbours) fired in provided sample
    const auto& pixelsS = sample.getData();
    int nC = mPixels.size();
    if (!nC) {
      return;
    }
    int nS = pixelsS.size();
    if (!nS) {
      return;
    }
    for (int itC = 0, itS = 0; itC < nC; itC++) {
      auto& pix0 = mPixels[itC];

      // seek to itS which is inferior than itC - maxDist
      auto mincol = pix0.getCol() > maxDist ? pix0.getCol() - maxDist : 0;
      auto minrow = pix0.getRowDirect() > maxDist ? pix0.getRowDirect() - maxDist : 0;
      if (itS == nS) { // in case itS lool below reached the end
        itS--;
      }
      while ((pixelsS[itS].getCol() > mincol || pixelsS[itS].getRow() > minrow) && itS > 0) {
        itS--;
      }
      for (; itS < nS; itS++) {
        const auto& pixC = pixelsS[itS];

        auto drow = static_cast<int>(pixC.getRow()) - static_cast<int>(pix0.getRowDirect());
        auto dcol = static_cast<int>(pixC.getCol()) - static_cast<int>(pix0.getCol());

        if (dcol > maxDist || (dcol == maxDist && drow > maxDist)) {
          break; // all higher itS will not match to this itC also
        }
        if (dcol < -maxDist || (drow > maxDist || drow < -maxDist)) {
          continue;
        } else {
          pix0.setMask();
          if (int(mFirstUnmasked) == itC) { // mFirstUnmasked should flag 1st unmasked pixel entry
            mFirstUnmasked = itC + 1;
          }
          break;
        }
      }
    }
  }

  void print() const;

 private:
  uint8_t mROFlags = 0;                            // readout flags from the chip trailer
  uint16_t mChipID = 0;                            // chip id within the detector
  uint32_t mROFrame = 0;                           // readout frame ID
  uint32_t mFirstUnmasked = 0;                     // first unmasked entry in the mPixels
  uint32_t mStartID = 0;                           // entry of the 1st pixel data in the whole detector data, for MCtruth access
  uint32_t mTrigger = 0;                           // trigger pattern
  uint32_t mErrors = 0;                            // errors set during decoding
  uint64_t mErrorInfo = 0;                         // optional extra info on the error
  std::array<uint8_t, MAXDATAERRBYTES> mRawBuff{}; // buffer for raw data showing an error
  o2::InteractionRecord mInteractionRecord = {};   // interaction record
  std::vector<PixelData> mPixels;                  // vector of pixeld

  ClassDefNV(ChipPixelData, 1);
};
} // namespace itsmft
} // namespace o2

#endif //ALICEO2_ITSMFT_PIXELDATA_H
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Clusterer.h
/// \brief Definition of the ITS cluster finder
#ifndef ALICEO2_ITS_CLUSTERER_H
#define ALICEO2_ITS_CLUSTERER_H

#define _PERFORM_TIMING_

// uncomment this to not allow diagonal clusters, e.g. like |* |
//                                                          | *|
#define _ALLOW_DIAGONAL_ALPIDE_CLUSTERS_

#include <utility>
#include <vector>
#include <cstring>
#include <memory>
#include <gsl/span>
#include "ITSMFTBase/SegmentationAlpide.h"
#include "DataFormatsITSMFT/CompCluster.h"
#include "DataFormatsITSMFT/ROFRecord.h"
#include "ITSMFTReconstruction/PixelReader.h"
#include "ITSMFTReconstruction/PixelData.h"
#include "ITSMFTReconstruction/LookUp.h"
#include "SimulationDataFormat/MCCompLabel.h"
#include "CommonConstants/LHCConstants.h"
#include "Rtypes.h"

#ifdef _PERFORM_TIMING_
#include <TStopwatch.h>
#endif

class TTree;

namespace o2
{
class MCCompLabel;
namespace dataformats
{
template <typename T>
class ConstMCTruthContainerView;
template <typename T>
class MCTruthContainer;
}

namespace itsmft
{

using CompClusCont = std::vector<CompClusterExt>;
using PatternCont = std::vector<unsigned char>;
using ROFRecCont = std::vector<ROFRecord>;

//template <class CompClusCont, class PatternCont, class ROFRecCont> // container types (PMR or std::vectors)

class Clusterer
{
  using PixelReader = o2::itsmft::PixelReader;
  using PixelData = o2::itsmft::PixelData;
  using ChipPixelData = o2::itsmft::ChipPixelData;
  using CompCluster = o2::itsmft::CompCluster;
  using CompClusterExt = o2::itsmft::CompClusterExt;
  using Label = o2::MCCompLabel;
  using MCTruth = o2::dataformats::MCTruthContainer<o2::MCCompLabel>;
  using ConstMCTruth = o2::dataformats::ConstMCTruthContainerView<o2::MCCompLabel>;

 public:
  static constexpr int MaxLabels = 10;
  static constexpr int MaxHugeClusWarn = 5; // max number of warnings for HugeCluster

  struct BBox {
    uint16_t chipID = 0xffff;
    uint16_t rowMin = 0xffff;
    uint16_t colMin = 0xffff;
    uint16_t rowMax = 0;
    uint16_t colMax = 0;
    BBox(uint16_t c) : chipID(c) {}
    bool isInside(uint16_t row, uint16_t col) const { return row >= rowMin && row <= rowMax && col >= colMin && col <= colMax; }
    auto rowSpan() const { return rowMax - rowMin + 1; }
    auto colSpan() const { return colMax - colMin + 1; }
    bool isAcceptableSize() const { return colMax - colMin < o2::itsmft::ClusterPattern::MaxColSpan && rowMax - rowMin < o2::itsmft::ClusterPattern::MaxRowSpan; }
    void clear()
    {
      rowMin = colMin = 0xffff;
      rowMax = colMax = 0;
    }
    void adjust(uint16_t row, uint16_t col)
    {
      if (row < rowMin) {
        rowMin = row;
      }
      if (row > rowMax) {
        rowMax = row;
      }
      if (col < colMin) {
        colMin = col;
      }
      if (col > colMax) {
        colMax = col;
      }
    }
  };

  //=========================================================
  /// methods and transient data used within a thread
  struct ThreadStat {
    uint16_t firstChip = 0;
    uint16_t nChips = 0;
    uint32_t firstClus = 0;
    uint32_t firstPatt = 0;
    uint32_t nClus = 0;
    uint32_t nPatt = 0;
    ThreadStat() = default;
  };

  struct ClustererThread {

    Clusterer* parent = nullptr; // parent clusterer
    // buffers for entries in preClusterIndices in 2 columns, to avoid boundary checks, we reserve
    // extra elements in the beginning and the end
    int column1[SegmentationAlpide::NRows + 2];
    int column2[SegmentationAlpide::NRows + 2];
    int* curr = nullptr; // pointer on the 1st row of currently processed columnsX
    int* prev = nullptr; // pointer on the 1st row of previously processed columnsX
    // pixels[].first is the index of the next pixel of the same precluster in the pixels
    // pixels[].second is the index of the referred pixel in the ChipPixelData (element of mChips)
    std::vector<std::pair<int, uint32_t>> pixels;
    std::vector<int> preClusterHeads; // index of precluster head in the pixels
    std::vector<int> preClusterIndices;
    uint16_t currCol = 0xffff;                                      ///< Column being processed
    bool noLeftCol = true;                                          ///< flag that there is no column on the left to check
    std::array<Label, MaxLabels> labelsBuff;                        //! temporary buffer for building cluster labels
    std::vector<PixelData> pixArrBuff;                              //! temporary buffer for pattern calc.
    //
    /// temporary storage for the thread output
    CompClusCont compClusters;
    PatternCont patterns;
    MCTruth labels;
    std::vector<ThreadStat> stats; // statistics for each thread results, used at merging
    ///
    ///< reset column buffer, for the performance reasons we use memset
    void resetColumn(int* buff) { std::memset(buff, -1, sizeof(int) * SegmentationAlpide::NRows); }

    ///< swap current and previous column buffers
    void swapColumnBuffers() { std::swap(prev, curr); }

    ///< add cluster at row (entry ip in the ChipPixeData) to the precluster with given index
    void expandPreCluster(uint32_t ip, uint16_t row, int preClusIndex)
    {
      auto& firstIndex = preClusterHeads[preClusterIndices[preClusIndex]];
      pixels.emplace_back(firstIndex, ip);
      firstIndex = pixels.size() - 1;
      curr[row] = preClusIndex;
    }

    ///< add new precluster at given row of current column for the fired pixel with index ip in the ChipPixelData
    void addNewPrecluster(uint32_t ip, uint16_t row)
    {
      preClusterHeads.push_back(pixels.size());
      // new head does not point yet (-1) on other pixels, store just the entry of the pixel in the ChipPixelData
      pixels.emplace_back(-1, ip);
      int lastIndex = preClusterIndices.size();
      preClusterIndices.push_back(lastIndex);
      curr[row] = lastIndex; // store index of the new precluster in the current column buffer
    }

    void fetchMCLabels(int digID, const ConstMCTruth* labelsDig, int& nfilled);
    void initChip(const ChipPixelData* curChipData, uint32_t first);
    void updateChip(const ChipPixelData* curChipData, uint32_t ip);
    void finishChip(ChipPixelData* curChipData, CompClusCont* compClus, PatternCont* patterns,
                    const ConstMCTruth* labelsDig, MCTruth* labelsClus);
    void finishChipSingleHitFast(uint32_t hit, ChipPixelData* curChipData, CompClusCont* compClusPtr,
                                 PatternCont* patternsPtr, const ConstMCTruth* labelsDigPtr, MCTruth* labelsClusPTr);
    void process(uint16_t chip, uint16_t nChips, CompClusCont* compClusPtr, PatternCont* patternsPtr,
                 const ConstMCTruth* labelsDigPtr, MCTruth* labelsClPtr, const ROFRecord& rofPtr);

    ClustererThread(Clusterer* par = nullptr) : parent(par), curr(column2 + 1), prev(column1 + 1)
    {
      std::fill(std::begin(column1), std::end(column1), -1);
      std::fill(std::begin(column2), std::end(column2), -1);
    }
  };
  //=========================================================

  Clusterer();
  ~Clusterer() = default;

  Clusterer(const Clusterer&) = delete;
  Clusterer& operator=(const Clusterer&) = delete;

  void process(int nThreads, PixelReader& r, CompClusCont* compClus, PatternCont* patterns, ROFRecCont* vecROFRec, MCTruth* labelsCl = nullptr);

  template <typename VCLUS, typename VPAT>
  static void streamCluster(const std::vector<PixelData>& pixbuf, const std::array<Label, MaxLabels>* lblBuff, const BBox& bbox, const LookUp& pattIdConverter,
                            VCLUS* compClusPtr, VPAT* patternsPtr, MCTruth* labelsClusPtr, int nlab, bool isHuge = false);

  bool isContinuousReadOut() const { return mContinuousReadout; }
  void setContinuousReadOut(bool v) { mContinuousReadout = v; }

  int getMaxBCSeparationToMask() const { return mMaxBCSeparationToMask; }
  void setMaxBCSeparationToMask(int n) { mMaxBCSeparationToMask = n; }

  int getMaxRowColDiffToMask() const { return mMaxRowColDiffToMask; }
  void setMaxRowColDiffToMask(int v) { mMaxRowColDiffToMask = v; }

  void print() const;
  void clear();

  void setNChips(int n)
  {
    mChips.resize(n);
    mChipsOld.resize(n);
  }

  ///< load the dictionary of cluster topologies
  void loadDictionary(const std::string& fileName) { mPattIdConverter.loadDictionary(fileName); }
  void setDictionary(const TopologyDictionary* dict) { mPattIdConverter.setDictionary(dict); }

  TStopwatch& getTimer() { return mTimer; } // cannot be const
  TStopwatch& getTimerMerge() { return mTimerMerge; } // cannot be const

 private:

  void flushClusters(CompClusCont* compClus, MCTruth* labels);

  // clusterization options
  bool mContinuousReadout = true;    ///< flag continuous readout

  ///< mask continuosly fired pixels in frames separated by less than this amount of BCs (fired from hit in prev. ROF)
  int mMaxBCSeparationToMask = 6000. / o2::constants::lhc::LHCBunchSpacingNS + 10;
  int mMaxRowColDiffToMask = 0; ///< provide their difference in col/row is <= than this
  int mNHugeClus = 0;           ///< number of encountered huge clusters

  std::vector<std::unique_ptr<ClustererThread>> mThreads; // buffers for threads
  std::vector<ChipPixelData> mChips;                      // currently processed ROF's chips data
  std::vector<ChipPixelData> mChipsOld;                   // previously processed ROF's chips data (for masking)
  std::vector<ChipPixelData*> mFiredChipsPtr;             // pointers on the fired chips data in the decoder cache

  LookUp mPattIdConverter; //! Convert the cluster topology to the corresponding entry in the dictionary.

  TStopwatch mTimer;
  TStopwatch mTimerMerge;
};

template <typename VCLUS, typename VPAT>
void Clusterer::streamCluster(const std::vector<PixelData>& pixbuf, const std::array<Label, MaxLabels>* lblBuff, const Clusterer::BBox& bbox, const LookUp& pattIdConverter,
                              VCLUS* compClusPtr, VPAT* patternsPtr, MCTruth* labelsClusPtr, int nlab, bool isHuge)
{
  if (labelsClusPtr && lblBuff) { // MC labels were requested
    auto cnt = compClusPtr->size();
    for (int i = nlab; i--;) {
      labelsClusPtr->addElement(cnt, (*lblBuff)[i]);
    }
  }
  auto colSpanW = bbox.colSpan();
  auto rowSpanW = bbox.rowSpan();
  // add to compact clusters, which must be always filled
  std::array<unsigned char, ClusterPattern::MaxPatternBytes> patt{};
  for (const auto& pix : pixbuf) {
    uint32_t ir = pix.getRowDirect() - bbox.rowMin, ic = pix.getCol() - bbox.colMin;
    int nbits = ir * colSpanW + ic;
    patt[nbits >> 3] |= (0x1 << (7 - (nbits % 8)));
  }
  uint16_t pattID = (isHuge || pattIdConverter.size() == 0) ? CompCluster::InvalidPatternID : pattIdConverter.findGroupID(rowSpanW, colSpanW, patt.data());
  uint16_t row = bbox.rowMin, col = bbox.colMin;
  if (pattID == CompCluster::InvalidPatternID || pattIdConverter.isGroup(pattID)) {
    if (pattID != CompCluster::InvalidPatternID) {
      //For groupped topologies, the reference pixel is the COG pixel
      float xCOG = 0., zCOG = 0.;
      ClusterPattern::getCOG(rowSpanW, colSpanW, patt.data(), xCOG, zCOG);
      row += round(xCOG);
      col += round(zCOG);
    }
    if (patternsPtr) {
      patternsPtr->emplace_back((unsigned char)rowSpanW);
      patternsPtr->emplace_back((unsigned char)colSpanW);
      int nBytes = rowSpanW * colSpanW / 8;
      if (((rowSpanW * colSpanW) % 8) != 0) {
        nBytes++;
      }
      patternsPtr->insert(patternsPtr->end(), std::begin(patt), std::begin(patt) + nBytes);
    }
  }
  compClusPtr->emplace_back(row, col, pattID, bbox.chipID);
}

} // namespace itsmft
} // namespace o2
#endif /* ALICEO2_ITS_CLUSTERER_H */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file ClustererParam.h
/// \brief Definition of the ITS/MFT clusterer settings

#ifndef ALICEO2_ITSMFTCLUSTERERPARAM_H_
#define ALICEO2_ITSMFTCLUSTERERPARAM_H_

#include "DetectorsCommonDataFormats/DetID.h"
#include "CommonUtils/ConfigurableParam.h"
#include "CommonUtils/ConfigurableParamHelper.h"
#include <string_view>
#include <string>

namespace o2
{
namespace itsmft
{
template <int N>
struct ClustererParam : public o2::conf::ConfigurableParamHelper<ClustererParam<N>> {
  static_assert(N == o2::detectors::DetID::ITS || N == o2::detectors::DetID::MFT, "only DetID::ITS or DetID:: MFT are allowed");

  static constexpr std::string_view getParamName()
  {
    return N == o2::detectors::DetID::ITS ? ParamName[0] : ParamName[1];
  }

  int maxRowColDiffToMask = DEFRowColDiffToMask(); ///< pixel may be masked as overflow if such a neighbour in prev frame was fired
  int maxBCDiffToMaskBias = 10;                    ///< mask if 2 ROFs differ by <= StrobeLength + Bias BCs, use value <0 to disable masking

  O2ParamDef(ClustererParam, getParamName().data());

 private:
  static constexpr int DEFRowColDiffToMask()
  {
    // default neighbourhood definition
    return N == o2::detectors::DetID::ITS ? 1 : 1; // ITS and MFT will suppress also closest neigbours
  }
  static constexpr std::string_view ParamName[2] = {"ITSClustererParam", "MFTClustererParam"};
};

template <int N>
ClustererParam<N> ClustererParam<N>::sInstance;

} // namespace itsmft

namespace framework
{
template <typename T>
struct is_messageable;
template <>
struct is_messageable<o2::itsmft::ClustererParam<o2::detectors::DetID::ITS>> : std::true_type {
};
template <typename T>
struct is_messageable;
template <>
struct is_messageable<o2::itsmft::ClustererParam<o2::detectors::DetID::MFT>> : std::true_type {
};
} // namespace framework

} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file BuildTopologyDictionary.h
/// \brief Definition of the BuildTopologyDictionary class.
///
/// \author Luca Barioglio, University and INFN of Torino
///
/// Short BuildTopologyDictionary descritpion
///
/// This class is used to build the dictionary of topologies, storing the information
/// concerning topologies with their own entry and groups of rare topologies
///

#ifndef ALICEO2_ITSMFT_BUILDTOPOLOGYDICTIONARY_H
#define ALICEO2_ITSMFT_BUILDTOPOLOGYDICTIONARY_H
#include <algorithm>
#include <map>
#include "ITSMFTBase/SegmentationAlpide.h"
#include "DataFormatsITSMFT/ClusterTopology.h"
#include "DataFormatsITSMFT/TopologyDictionary.h"

namespace o2
{
namespace itsmft
{
struct TopologyInfo {
  int mSizeX = 0;
  int mSizeZ = 0;
  float mCOGx = 0.f;
  float mCOGz = 0.f;
  float mXmean = 0.f;
  float mXsigma2 = 0.f;
  float mZmean = 0.f;
  float mZsigma2 = 0.f;
  int mNpixels = 0;
  ClusterPattern mPattern; ///< Bitmask of pixels. For groups the biggest bounding box for the group is taken, with all
                           ///the bits set to 1.
};

// transient structure to accumulate topology statistics
struct TopoStat {
  ClusterTopology topology;
  unsigned long countsTotal = 0;    // counts for this topology
  unsigned long countsWithBias = 0; // counts with assigned dX,dY provided
  TopoStat() = default;
};

class BuildTopologyDictionary
{
 public:
  BuildTopologyDictionary();
  static constexpr float IgnoreVal = 999.;
  void accountTopology(const ClusterTopology& cluster, float dX = IgnoreVal, float dZ = IgnoreVal);
  void setNCommon(unsigned int nCommon); // set number of common topologies
  void setThreshold(double thr);
  void setThresholdCumulative(double cumulative); // Considering the integral
  void groupRareTopologies();
  friend std::ostream& operator<<(std::ostream& os, const BuildTopologyDictionary& BD);
  void printDictionary(const std::string& fname);
  void printDictionaryBinary(const std::string& fname);
  void saveDictionaryRoot(const std::string& fname);

  int getTotClusters() const { return mTotClusters; }
  int getNotInGroups() const { return mNCommonTopologies; }
  TopologyDictionary getDictionary() const { return mDictionary; }

 private:
  TopologyDictionary mDictionary;                                          ///< Dictionary of topologies
  std::map<unsigned long, TopoStat> mTopologyMap;                          //! Temporary map of type <hash,TopStat>
  std::vector<std::pair<unsigned long, unsigned long>> mTopologyFrequency; //! <freq,hash>, needed to define threshold
  int mTotClusters;
  int mNCommonTopologies;
  double mFrequencyThreshold;

  std::unordered_map<long unsigned, TopologyInfo> mMapInfo;

  ClassDefNV(BuildTopologyDictionary, 4);
};
} // namespace itsmft
} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file LookUp.h
/// \brief Definition of the LookUp class.
///
/// \author Luca Barioglio, University and INFN of Torino
///
/// Short LookUp descritpion
///
/// This class is for the association of the cluster topology with the corresponding
/// entry in the dictionary
///

#ifndef ALICEO2_ITSMFT_LOOKUP_H
#define ALICEO2_ITSMFT_LOOKUP_H
#include <array>
#include "DataFormatsITSMFT/ClusterTopology.h"
#include "DataFormatsITSMFT/TopologyDictionary.h"

namespace o2
{
namespace itsmft
{
class LookUp
{
 public:
  LookUp();
  LookUp(std::string fileName);
  static int groupFinder(int nRow, int nCol);
  int findGroupID(int nRow, int nCol, const unsigned char patt[ClusterPattern::MaxPatternBytes]) const;
  int getTopologiesOverThreshold() const { return mTopologiesOverThreshold; }
  void loadDictionary(std::string fileName);
  void setDictionary(const TopologyDictionary* dict);
  bool isGroup(int id) const { return mDictionary.isGroup(id); }
  int size() const { return mDictionary.getSize(); }
  auto getPattern(int id) const { return mDictionary.getPattern(id); }
  auto getDictionaty() const { return mDictionary; }

 private:
  TopologyDictionary mDictionary;
  int mTopologiesOverThreshold;

  ClassDefNV(LookUp, 3);
};
} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file TopologyFastSimulation.h
/// \brief Definition of the TopologyFastSimulation class.
///
/// \author Luca Barioglio, University and INFN of Torino
///
/// Short TopologyFastSimulation descritpion
///
/// This class is used for the generation of a distribution of topologies according to
/// to the frequencies of the entries in the dictionary
///

#ifndef ALICEO2_ITSMFT_TOPOLOGYFASTSIMULATION_H
#define ALICEO2_ITSMFT_TOPOLOGYFASTSIMULATION_H
#include <random>
#include "DataFormatsITSMFT/TopologyDictionary.h"

namespace o2
{
namespace itsmft
{
class TopologyFastSimulation
{
 public:
  TopologyFastSimulation(std::string fileName, unsigned seed = 0xdeadbeef);
  int getRandom();

 private:
  TopologyDictionary mDictionary;
  std::vector<double> mFreqArray;
  std::mt19937 mGenerator;
  std::uniform_real_distribution<double> mDistribution;

  ClassDefNV(TopologyFastSimulation, 1);
};
} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_CHIPMAPPINGITS_H
#define ALICEO2_CHIPMAPPINGITS_H

// \file ChipMappingITS.h
// \brief ITS chip <-> module mapping

#include <Rtypes.h>
#include <array>
#include <cstdlib>
#include <cstdint>
#include <string>
#include "Headers/DataHeader.h"
#include "ITSMFTReconstruction/RUInfo.h"
#include "DetectorsCommonDataFormats/DetID.h"

namespace o2
{
namespace itsmft
{

#define _OVERRIDE_RUID_HACK_

class ChipMappingITS
{
 public:
  ///< these public methods must be defined in the mapping class for raw data encoding/decoding
  ChipMappingITS();
  ~ChipMappingITS() = default;

  static constexpr std::string_view getName() { return "ITS"; }
  static constexpr o2::header::DataOrigin getOrigin() { return o2::header::gDataOriginITS; }
  static constexpr o2::detectors::DetID::ID getDetID() { return o2::detectors::DetID::ITS; }

  const std::vector<uint8_t>& getCableHWFirstChip(int s) const { return mCableHWFirstChip[s]; }

  static constexpr std::int16_t getRUDetectorField() { return 0x0; }

  ///< total number of RUs
  static constexpr int getNRUs() { return NStavesSB[IB] + NStavesSB[MB] + NStavesSB[OB]; }

  ///< total number of chips
  static constexpr int getNChips() { return NChipsSB[IB] + NChipsSB[MB] + NChipsSB[OB]; }

  ///< number of chips per barrel
  static constexpr int getNChips(int b) { return NChipsSB[b]; }

  ///< number of staves on layer
  static constexpr int getNStavesOnLr(int l) { return NStavesOnLr[l]; }

  ///<  first staves of layer
  static constexpr int getFirstStavesOnLr(int l) { return FirstStaveOnLr[l]; }

  ///< numbes of chips per layer
  static constexpr int getNChipsPerLr(int l) { return NStavesOnLr[l] * NChipsPerStaveSB[RUTypeLr[l]]; }

  ///< compose FEEid for given stave (ru) relative to layer and link, see documentation in the constructor
  uint16_t composeFEEId(uint16_t lr, uint16_t ruOnLr, uint16_t link) const { return (lr << 12) + (link << 8) + (ruOnLr); }

  ///< decompose FEEid to layer, stave (ru) relative to layer, link, see documentation in the constructor
  void expandFEEId(uint16_t feeID, uint16_t& lr, uint16_t& ruOnLr, uint16_t& link) const
  {
    lr = feeID >> 12;
    ruOnLr = feeID & 0x3f;
    link = (feeID >> 8) & 0x3;
#ifdef _OVERRIDE_RUID_HACK_
    ruOnLr %= NStavesOnLr[lr];
#endif
  }

  ///< impose user defined FEEId -> ruSW (staveID) conversion, to be used only for forced decoding of corrupted data
  void imposeFEEId2RUSW(uint16_t feeID, uint16_t ruSW);

  ///< modify linkID field in FEEId
  uint16_t modifyLinkInFEEId(uint16_t feeID, uint16_t linkID) const
  {
    feeID &= ~(0x3 << 8);
    feeID |= (0x3 & linkID) << 8;
    return feeID;
  }

  ///< expand SW chip ID to SW (continuous) id's for layer, stave, substave etc.
  void expandChipInfoSW(int idSW, int& lay, int& sta, int& ssta, int& mod, int& chipInMod) const;

  ///< expand SW chip ID to HW  id's for layer, stave, substave, module, chipOnModule
  void expandChipInfoHW(int idSW, int& lay, int& sta, int& ssta, int& mod, int& chipInMod) const;

  ///< convert global SW chip ID to name in HW conventions
  std::string getChipNameHW(int idSW) const;

  void print() const;

  /// < extract information about the chip properties on the stave of given type for the chip
  /// < with sequential ID SWID within the stave
  const ChipOnRUInfo* getChipOnRUInfo(int staveType, int chOnRUSW) const
  {
    return &mChipsInfo[mChipInfoEntrySB[staveType] + chOnRUSW];
  }

  ///< extract information about the chip with SW ID
  void getChipInfoSW(int chipSW, ChipInfo& chInfo) const
  {
    chInfo.id = chipSW;
    if (chipSW > NChipsSB[IB] + NChipsSB[MB] - 1) { // OB
      chipSW -= NChipsSB[IB] + NChipsSB[MB];
      chInfo.ruType = OB;
      auto dvRU = std::div(chipSW, NChipsPerStaveSB[OB]);
      chInfo.ru = NStavesSB[IB] + NStavesSB[MB] + dvRU.quot; // RU ID == stave ID
      chInfo.chOnRU = getChipOnRUInfo(OB, dvRU.rem);
    } else if (chipSW > NChipsSB[IB] - 1) { // MB
      chipSW -= NChipsSB[IB];
      chInfo.ruType = MB;
      auto dvRU = std::div(chipSW, NChipsPerStaveSB[MB]);
      chInfo.ru = NStavesSB[IB] + dvRU.quot; // RU ID == stave ID
      chInfo.chOnRU = getChipOnRUInfo(MB, dvRU.rem);
    } else { // IB
      chInfo.ruType = IB;
      auto dvRU = std::div(chipSW, NChipsPerStaveSB[IB]);
      chInfo.ru = dvRU.quot; // RU ID == stave ID = module ID
      chInfo.chOnRU = getChipOnRUInfo(IB, dvRU.rem);
    }
  }

  ///< get chip global SW ID from chipID on module, cable SW ID and stave (RU) info
  uint16_t getGlobalChipID(uint16_t chOnModuleHW, int cableHW, const RUInfo& ruInfo) const
  {
    return ruInfo.firstChipIDSW + mCableHWFirstChip[ruInfo.ruType][cableHW] + chipModuleIDHW2SW(ruInfo.ruType, chOnModuleHW);
  }

  ///< get SW id of the RU from RU HW id
  uint8_t FEEId2RUSW(uint16_t hw) const
  {
#ifdef _OVERRIDE_RUID_HACK_
    uint16_t lr, ruOnLr, link;
    expandFEEId(hw, lr, ruOnLr, link);
    hw = composeFEEId(lr, ruOnLr, link);
#endif
    return mFEEId2RUSW[hw];
  }

  ///< get FEEId of the RU (software id of the RU), read via given link
  uint16_t RUSW2FEEId(uint16_t sw, uint16_t linkID = 0) const
  {
    uint16_t feeID = mStavesInfo[sw].idHW; // this is valid for link 0 only
    return linkID ? modifyLinkInFEEId(feeID, linkID) : feeID;
  }

  ///< get layer of the RU (from the software id of the RU)
  uint16_t RUSW2Layer(uint16_t sw) const { return mStavesInfo[sw].layer; }

  ///< get layer of the RU (from the software id of the RU)
  uint16_t RUSW2RUType(uint16_t sw) const { return mStavesInfo[sw].ruType; }

  ///< get info on sw RU
  const RUInfo* getRUInfoSW(int ruSW) const { return &mStavesInfo[ruSW]; }

  ///< get info on sw RU
  const RUInfo* getRUInfoFEEId(int feeID) const { return &mStavesInfo[FEEId2RUSW(feeID)]; }

  ///< get number of chips served by single cable on given RU type
  uint8_t getGBTHeaderRUType(int ruType, int cableHW) { return GBTHeaderFlagSB[ruType] + (cableHW & 0x1f); }

  ///< convert HW cable ID to its position on the ActiveLanes word in the GBT.header for given RU type
  uint8_t cableHW2Pos(uint8_t ruType, uint8_t hwid) const { return mCableHW2Pos[ruType][hwid]; }

  ///< convert HW cable ID to SW ID for given RU type (see ChipOnRUInfo.cableSW explanation)
  uint8_t cableHW2SW(uint8_t ruType, uint8_t hwid) const { return mCableHW2SW[ruType][hwid]; }

  ///< convert cable iterator ID to the position on the ActiveLanes word in the GBT.header for given RU type; MFT lanes position compatible
  uint8_t cablePos(uint8_t ruType, uint8_t id) const { return mCablePos[ruType][id]; }

  ///< get number of chips served by single cable on given RU type
  int getNChipsPerCable(int ruType) { return NChipsPerCableSB[ruType]; }

  ///< get number cables on the RU served by a given RU type
  int getNCablesOnRUType(int ruType) const { return NCablesPerStaveSB[ruType]; }

  ///< get pattern of lanes on the RU served by a given RU type
  int getCablesOnRUType(int ruType) const { return mCablesOnStaveSB[ruType]; }

  ///< get number of chips served by RU of given type (i.e. RU type for ITS)
  int getNChipsOnRUType(int ruType) const { return NChipsPerStaveSB[ruType]; }

  ///< get RU type from the sequential ID of the RU
  int getRUType(int ruID) const
  {
    ///< get the RU type corresponding to RU with secuential number ruID
    if (ruID > NStavesSB[IB] + NStavesSB[MB] - 1) {
      return OB;
    }
    if (ruID > NStavesSB[IB] - 1) {
      return MB;
    }
    return IB;
  }

  ///< convert HW id of chip in the module to SW ID (sequential ID on the module)
  int chipModuleIDHW2SW(int ruType, int hwIDinMod) const
  {
    return ruType == IB ? hwIDinMod : ChipOBModHW2SW[hwIDinMod];
  }

  ///< convert SW id of chip in the module to HW ID
  int chipModuleIDSW2HW(int ruType, int swIDinMod) const
  {
    return ruType == IB ? swIDinMod : ChipOBModSW2HW[swIDinMod];
  }

  ///< convert layer ID and RU sequential ID on Layer to absolute RU IDSW
  int getRUIDSW(int lr, int ruOnLr) const
  {
    int sid = 0;
    for (int i = 0; i < NLayers; i++) {
      if (i >= lr) {
        break;
      }
      sid += NStavesOnLr[i];
    }
    return sid + ruOnLr;
  }

  static constexpr int getLayer(int chipSW)
  {
    int i = 0;
    do {
      if (chipSW < FirstChipsOnLr[i]) {
        break;
      }
    } while (++i < NLayers);
    return i;
  }

  static constexpr int getNChipsOnLayer(int lr) { return NChipsOnLr[lr]; }
  static constexpr int getFirstChipsOnLayer(int lr) { return FirstChipsOnLr[lr]; }

  // sub-barrel types, their number, N layers, Max N GBT Links per RU
  static constexpr int IB = 0, MB = 1, OB = 2, NSubB = 3, NLayers = 7, NLinks = 3;

 private:
  static constexpr std::array<uint8_t, NSubB> GBTHeaderFlagSB = {0x1 << 5, 0x1 << 6, 0x1 << 6}; // prefixes for data GBT header byte

  ///< N chips per cable of each sub-barrel
  static constexpr std::array<int, NSubB> NChipsPerCableSB = {1, 7, 7};

  ///< N modules along the stave (or halfstave..)
  static constexpr std::array<int, NSubB> NModulesAlongStaveSB = {9, 4, 7};

  ///< N chips per module of each sub-barrel
  static constexpr std::array<int, NSubB> NChipsPerModuleSB = {9, 14, 14};

  ///< N cables per module of each sub-barrel
  static constexpr std::array<int, NSubB> NCablesPerModule = {9, 2, 2}; // NChipsPerModuleSB[]/NChipsPerCableSB[]

  ///< N modules per stage of each sub-barrel
  static constexpr std::array<int, NSubB> NModulesPerStaveSB = {1, 8, 14};

  ///< number of staves per layer
  static constexpr std::array<int, NLayers> NStavesOnLr = {12, 16, 20, 24, 30, 42, 48};

  ///< number of staves per layer
  static constexpr std::array<int, NLayers> FirstStaveOnLr = {0, 12, 28, 48, 72, 102, 144};

  ///< number of chips per layer
  static constexpr std::array<int, NLayers> NChipsOnLr = {108, 144, 180, 2688, 3360, 8232, 144};

  ///< 1st chipID on layer
  static constexpr std::array<int, NLayers> FirstChipsOnLr = {0, 108, 252, 432, 3120, 6480, 9408};

  ///< RU types for each layer
  static constexpr std::array<uint8_t, NLayers> RUTypeLr = {IB, IB, IB, MB, MB, OB, OB};

  ///< number of staves per sub-barrel
  static constexpr std::array<int, NSubB> NStavesSB = {NStavesOnLr[0] + NStavesOnLr[1] + NStavesOnLr[2],
                                                       NStavesOnLr[3] + NStavesOnLr[4],
                                                       NStavesOnLr[5] + NStavesOnLr[6]};
  ///< number of chips per stave of sub-barrel
  static constexpr std::array<int, NSubB> NChipsPerStaveSB = {NModulesPerStaveSB[IB] * NChipsPerModuleSB[IB],
                                                              NModulesPerStaveSB[MB] * NChipsPerModuleSB[MB],
                                                              NModulesPerStaveSB[OB] * NChipsPerModuleSB[OB]};

  ///< number of cables per stave of sub-barrel
  static constexpr std::array<int, NSubB> NCablesPerStaveSB = {NCablesPerModule[IB] * NModulesPerStaveSB[IB],
                                                               NCablesPerModule[MB] * NModulesPerStaveSB[MB],
                                                               NCablesPerModule[OB] * NModulesPerStaveSB[OB]};

  ///< number of chips per sub-barrel
  static constexpr std::array<int, NSubB> NChipsSB = {NChipsPerStaveSB[IB] * NStavesSB[IB],
                                                      NChipsPerStaveSB[MB] * NStavesSB[MB],
                                                      NChipsPerStaveSB[OB] * NStavesSB[OB]};

  static constexpr int NChips = NChipsSB[IB] + NChipsSB[MB] + NChipsSB[OB];

  ///< mapping from SW chips ID within the module to HW ID
  /*
    SW/HW correspondence
     13/14|12/13|11/12|10/11| 9/10| 8/ 9| 7/ 8
    ----- ----- ----- ----- ----- ----- -----
     0/ 0| 1/ 1| 2/ 2| 3/ 3| 4/ 4| 5/ 5| 6/ 6
   */
  // SW ID -> HW ID within the module
  static constexpr std::uint8_t ChipOBModSW2HW[14] = {0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14};
  // HW ID -> SW ID within the module
  static constexpr std::uint8_t ChipOBModHW2SW[15] = {0, 1, 2, 3, 4, 5, 6, 255, 7, 8, 9, 10, 11, 12, 13};

  /// info per stave
  std::array<RUInfo, NStavesSB[IB] + NStavesSB[MB] + NStavesSB[OB]> mStavesInfo;
  std::vector<uint8_t> mFEEId2RUSW; // HW RU ID -> SW ID conversion

  // info on chips info within the stave
  std::array<ChipOnRUInfo, NChipsPerStaveSB[IB] + NChipsPerStaveSB[MB] + NChipsPerStaveSB[OB]> mChipsInfo;
  int mChipInfoEntrySB[NSubB] = {0};

  std::vector<uint8_t> mCableHW2SW[NSubB];       ///< table of cables HW to SW conversion for each RU type
  std::vector<uint8_t> mCableHW2Pos[NSubB];      ///< table of cables positions in the ActiveLanes mask for each RU type (HW numbering)
  std::vector<uint8_t> mCablePos[NSubB];         ///< table of cables positions in the ActiveLanes mask for each RU type (sequential numbering)
  std::vector<uint8_t> mCableHWFirstChip[NSubB]; ///< 1st chip of module (relative to the 1st chip of the stave) served by each cable

  std::array<int, NSubB> mCablesOnStaveSB = {0}; ///< pattern of cables per stave of sub-barrel

  ClassDefNV(ChipMappingITS, 1);
};
} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_MFT_CHIPMAPPING_H
#define ALICEO2_MFT_CHIPMAPPING_H

// \file ChipMappingMFT.h
// \brief MFT chip <-> module mapping

#include <Rtypes.h>
#include <array>
#include <FairLogger.h>
#include "Headers/DataHeader.h"
#include "ITSMFTReconstruction/RUInfo.h"
#include "DetectorsCommonDataFormats/DetID.h"

namespace o2
{
namespace itsmft
{

struct MFTChipMappingData {
  UShort_t module = 0;         // global module ID
  UChar_t chipOnModule = 0;    // chip within the module
  UChar_t cable = 0;           // cable in the connector
  UChar_t chipOnRU = 0;        // chip within the RU (SW)
  UShort_t globalChipSWID = 0; // global software chip ID
  UShort_t localChipSWID = 0;  // local software chip ID
  UShort_t localChipHWID = 0;  // local hardware chip ID
  UChar_t connector = 0;       // cable connector in a zone
  UChar_t zone = 0;            // read-out zone id
  UChar_t ruOnLayer = 0;       // read-out-unit index on layer
  UChar_t ruType = 0;          // read-out-unit type
  UChar_t ruSWID = 0;          // read-out-unit hardware ID
  UChar_t ruHWID = 0;          // read-out-unit software ID
  UChar_t layer = 0;           // MFT layer
  UChar_t disk = 0;            // MFT disk
  UChar_t half = 0;            // MFT half
  ClassDefNV(MFTChipMappingData, 1);
};

struct MFTModuleMappingData {
  UChar_t layer = 0;        // layer id
  UChar_t nChips = 0;       // number of chips
  UShort_t firstChipID = 0; // global id of 1st chip
  UChar_t connector = 0;    // cable connector in a zone
  UChar_t zone = 0;         // read-out zone id
  UChar_t disk = 0;         // disk id
  UChar_t half = 0;         // half id
  ClassDefNV(MFTModuleMappingData, 1);
};

class ChipMappingMFT
{
 public:
  ChipMappingMFT();
  ~ChipMappingMFT() = default;

  static constexpr std::string_view getName() { return "MFT"; }
  static constexpr o2::header::DataOrigin getOrigin() { return o2::header::gDataOriginMFT; }
  static constexpr o2::detectors::DetID::ID getDetID() { return o2::detectors::DetID::MFT; }

  // RS placeholder for methods to implement ----------->

  ///< total number of RUs
  static constexpr Int_t getNRUs() { return NRUs; }

  ///< get FEEId of the RU (software id of the RU), read via given link
  uint8_t FEEId2RUSW(uint16_t hw) const { return mFEEId2RUSW[hw & 0xff]; }

  ///< get HW id of the RU (software id of the RU)
  uint16_t RUSW2FEEId(uint16_t sw, uint16_t linkID = 0) const { return ((linkID << 8) + mRUInfo[sw].idHW); }

  ///< compose FEEid for given stave (ru) relative to layer and link, see documentation in the constructor
  uint16_t composeFEEId(uint16_t layer, uint16_t ruOnLayer, uint16_t link) const
  {
    // only one link is used
    // ruOnLayer is 0, 1, 2, 3 for half = 0
    //              4, 5, 6, 7            1
    auto dhalf = std::div(ruOnLayer, 4);
    uint16_t half = dhalf.quot;
    uint16_t zone = dhalf.rem;
    auto ddisk = std::div(layer, 2);
    uint16_t disk = ddisk.quot;
    uint16_t plane = layer % 2;
    return (link << 8) + (half << 6) + (disk << 3) + (plane << 2) + zone;
  }

  ///< decompose FEEid to layer, stave (ru) relative to layer, link, see documentation in the constructor
  void expandFEEId(uint16_t feeID, uint16_t& layer, uint16_t& ruOnLayer, uint16_t& link) const
  {
    link = feeID >> 8;
    uint16_t half = (feeID >> 6) & 0x1;
    uint16_t disk = (feeID >> 3) & 0x7;
    uint16_t plane = (feeID >> 2) & 0x1;
    uint16_t zone = feeID & 0x3;
    layer = 2 * disk + plane;
    ruOnLayer = 4 * half + zone;
  }

  ///< decompose FEEid to face, disk, half
  void expandFEEIdFaceDiskHalf(uint16_t feeID, uint16_t& face, uint16_t& disk, uint16_t& half) const
  {
    half = (feeID >> 6) & 0x1;
    disk = (feeID >> 3) & 0x7;
    face = (feeID >> 2) & 0x1;
  }

  ///< get info on sw RU
  const RUInfo* getRUInfoFEEId(Int_t feeID) const { return &mRUInfo[FEEId2RUSW(feeID)]; }

  ///< get number of chips served by single cable on given RU type
  uint8_t getGBTHeaderRUType(Int_t ruType, Int_t cableHW)
  {
    return ((0x1 << 7) + (cableHW & 0x1f));
  }

  ///< convert HW cable ID to its position on the ActiveLanes word in the GBT.header for given RU type
  uint8_t cableHW2Pos(uint8_t ruType, uint8_t hwid) const { return mCableHW2Pos[ruType][hwid]; }

  ///< convert HW cable ID to SW ID for give RU type
  uint8_t cableHW2SW(uint8_t ruType, uint8_t hwid) const { return mCableHW2SW[ruType][hwid]; }

  ///< convert cable iterator ID to its position on the ActiveLanes word in the GBT.header for given RU type
  uint8_t cablePos(uint8_t ruType, uint8_t id) const { return mCablePos[ruType][id]; }

  ///< get chip global SW ID from chipID on module, cable SW ID and stave (RU) info
  uint16_t getGlobalChipID(uint16_t chOnModuleHW, int cableHW, const RUInfo& ruInfo) const
  {
    auto chipOnRU = cableHW2SW(ruInfo.ruType, cableHW);
    return mRUGlobalChipID[(int)(ruInfo.idSW)].at((int)(chipOnRU));
  }

  ///< convert HW id of chip in the module to SW ID (sequential ID on the module)
  int chipModuleIDHW2SW(int ruType, int hwIDinMod) const
  {
    return (8 - hwIDinMod);
  }

  ///< convert SW id of chip in the module to HW ID
  int chipModuleIDSW2HW(int ruType, int swIDinMod) const
  {
    return (8 - swIDinMod);
  }

  static constexpr Int_t getNChips() { return NChips; }

  static constexpr Int_t getNModules() { return NModules; }

  Int_t chipID2Module(Int_t chipID, Int_t& chipOnModule) const
  {
    chipOnModule = ChipMappingData[chipID].chipOnModule;
    return ChipMappingData[chipID].module;
  }

  Int_t chipID2Module(Int_t chipID) const
  {
    return ChipMappingData[chipID].module;
  }

  Int_t getNChipsInModule(Int_t modID) const
  {
    return ModuleMappingData[modID].nChips;
  }

  Int_t module2ChipID(Int_t modID, Int_t chipOnModule) const
  {
    return ModuleMappingData[modID].firstChipID + chipOnModule;
  }

  Int_t module2Layer(Int_t modID) const
  {
    return ModuleMappingData[modID].layer;
  }

  Int_t chip2Layer(Int_t chipID) const
  {
    return ModuleMappingData[ChipMappingData[chipID].module].layer;
  }

  ///< impose user defined FEEId -> ruSW (staveID) conversion, to be used only for forced decoding of corrupted data
  void imposeFEEId2RUSW(uint16_t, uint16_t) {}

  ///< extract information about the chip with SW ID
  void getChipInfoSW(Int_t chipSW, ChipInfo& chInfo) const
  {
    // ladder (MFT) = module (ITS)
    UShort_t ladder = ChipMappingData[chipSW].module;
    UChar_t layer = ModuleMappingData[ladder].layer;
    UChar_t zone = ModuleMappingData[ladder].zone;
    UChar_t half = ModuleMappingData[ladder].half;

    chInfo.ruType = ZoneRUType[zone][layer / 2];

    // count RU SW per half layers
    //chInfo.ru = NLayers * (NZonesPerLayer / 2) * half + (NZonesPerLayer / 2) * layer + zone;

    // count RU SW per full layers
    chInfo.ru = NZonesPerLayer * layer + (NZonesPerLayer / 2) * half + zone;

    chInfo.id = ChipMappingData[chipSW].chipOnRU;
    chInfo.chOnRU = getChipOnRUInfo(chInfo.ruType, chInfo.id);
  }

  ///< get number of chips served by RU of given type (i.e. RU type for ITS)
  Int_t getNChipsOnRUType(Int_t ruType) const { return NChipsOnRUType[ruType]; }

  /// < extract information about the chip properties on the stave of given type for the chip
  /// < with sequential ID SWID within the stave
  const ChipOnRUInfo* getChipOnRUInfo(Int_t ruType, Int_t chipOnRU) const
  {
    return &mChipsInfo[mChipInfoEntryRU[ruType] + chipOnRU];
  }

  static constexpr std::int16_t getRUDetectorField() { return 0x0; }

  uint32_t getCablesOnRUType(Int_t ruType) const
  {
    uint32_t pattern = 0;
    for (Int_t i = 0; i < NRUCables; i++) {
      pattern |= (0x1 << mCableHW2Pos[ruType][i]);
    }
    return pattern;
  }

  ///< get info on sw RU
  const RUInfo* getRUInfoSW(int ruSW) const { return &mRUInfo[ruSW]; }

  ///< convert layer ID and RU sequential ID on Layer to absolute RU IDSW
  int getRUIDSW(int layer, int ruOnLayer) const
  {
    int sid = 0;
    for (int i = 0; i < NLayers; i++) {
      if (i >= layer) {
        break;
      }
      sid += NZonesPerLayer;
    }
    return sid + ruOnLayer;
  }

  const int getNZonesPerLayer() const { return NZonesPerLayer; }
  const int getNLayers() const { return NLayers; }

  ///< convert zone number [0...8] and layer number [0...10] to RU type
  int getRUType(int zone, int layer) const { return ZoneRUType[zone % 4][layer / 2]; }

  static constexpr int NChips = 936, NLayers = 10, NZonesPerLayer = 2 * 4, NRUTypes = 13;

  const std::array<MFTChipMappingData, NChips>& getChipMappingData() const { return ChipMappingData; }

  void print() const;

  ///< LayerID of each MFT chip
  static constexpr std::array<int, NChips> ChipID2Layer{
    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4,
    4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
    6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
    7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 8, 8, 8,
    8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,
    9, 9, 9, 9, 9, 9};

  static constexpr std::array<int, 280> mLadderIDGeoToRO{
    0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 1, 2, 3, 4, 15,
    16, 17, 18, 19, 20, 21, 22, 23, 5, 24, 30, 31, 32, 33, 34,
    35, 36, 37, 38, 25, 26, 27, 28, 39, 40, 41, 42, 43, 44, 45,
    46, 47, 29, 48, 52, 53, 66, 67, 54, 55, 56, 68, 69, 57, 58,
    49, 50, 59, 60, 70, 71, 61, 62, 63, 72, 73, 64, 65, 51, 74,
    75, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 76, 77, 78,
    79, 80, 81, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 82,
    83, 106, 107, 114, 115, 132, 133, 116, 117, 118, 119, 120, 134, 135, 121,
    122, 108, 109, 110, 111, 123, 124, 136, 137, 125, 126, 127, 128, 129, 138,
    139, 130, 131, 112, 113, 140, 146, 147, 148, 149, 150, 151, 152, 153, 154,
    141, 142, 143, 144, 155, 156, 157, 158, 159, 160, 161, 162, 163, 145, 164,
    170, 171, 172, 173, 174, 175, 176, 177, 178, 165, 166, 167, 168, 179, 180,
    181, 182, 183, 184, 185, 186, 187, 169, 188, 192, 193, 206, 207, 194, 195,
    196, 208, 209, 197, 198, 189, 190, 199, 200, 210, 211, 201, 202, 203, 212,
    213, 204, 205, 191, 214, 215, 224, 225, 226, 227, 228, 229, 230, 231, 232,
    233, 234, 216, 217, 218, 219, 220, 221, 235, 236, 237, 238, 239, 240, 241,
    242, 243, 244, 245, 222, 223, 246, 247, 254, 255, 272, 273, 256, 257, 258,
    259, 260, 274, 275, 261, 262, 248, 249, 250, 251, 263, 264, 276, 277, 265,
    266, 267, 268, 269, 278, 279, 270, 271, 252, 253};

  static constexpr std::array<int, NChips> mChipIDGeoToRO{
    0, 1, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
    25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 2,
    3, 4, 5, 6, 7, 8, 9, 39, 40, 41, 42, 43, 44, 45, 46,
    47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,
    62, 63, 64, 65, 10, 11, 66, 67, 78, 79, 80, 81, 82, 83, 84,
    85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
    100, 101, 102, 103, 104, 68, 69, 70, 71, 72, 73, 74, 75, 105, 106,
    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,
    122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 76, 77, 132, 133, 140,
    141, 142, 143, 144, 145, 182, 183, 184, 185, 186, 187, 188, 189, 146, 147,
    148, 149, 150, 151, 152, 153, 154, 190, 191, 192, 193, 194, 195, 196, 197,
    155, 156, 157, 158, 159, 160, 134, 135, 136, 137, 161, 162, 163, 164, 165,
    166, 198, 199, 200, 201, 202, 203, 204, 205, 167, 168, 169, 170, 171, 172,
    173, 174, 175, 206, 207, 208, 209, 210, 211, 212, 213, 176, 177, 178, 179,
    180, 181, 138, 139, 214, 215, 216, 217, 218, 219, 244, 245, 246, 247, 248,
    249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263,
    264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278,
    279, 280, 281, 282, 283, 284, 285, 286, 287, 220, 221, 222, 223, 224, 225,
    226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 288, 289, 290,
    291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305,
    306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320,
    321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 238, 239, 240, 241,
    242, 243, 332, 333, 334, 335, 336, 337, 356, 357, 358, 359, 360, 361, 362,
    363, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 364, 365, 366, 367,
    368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382,
    383, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 384, 385, 386, 387,
    388, 389, 390, 391, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348,
    349, 392, 393, 394, 395, 396, 397, 398, 399, 448, 449, 450, 451, 452, 453,
    454, 455, 456, 457, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410,
    411, 412, 413, 414, 415, 416, 417, 418, 419, 458, 459, 460, 461, 462, 463,
    464, 465, 466, 467, 420, 421, 422, 423, 424, 425, 426, 427, 350, 351, 352,
    353, 354, 355, 468, 469, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489,
    490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504,
    505, 506, 470, 471, 472, 473, 474, 475, 476, 477, 507, 508, 509, 510, 511,
    512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526,
    527, 528, 529, 530, 531, 532, 533, 478, 479, 534, 535, 546, 547, 548, 549,
    550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560, 561, 562, 563, 564,
    565, 566, 567, 568, 569, 570, 571, 572, 536, 537, 538, 539, 540, 541, 542,
    543, 573, 574, 575, 576, 577, 578, 579, 580, 581, 582, 583, 584, 585, 586,
    587, 588, 589, 590, 591, 592, 593, 594, 595, 596, 597, 598, 599, 544, 545,
    600, 601, 608, 609, 610, 611, 612, 613, 650, 651, 652, 653, 654, 655, 656,
    657, 614, 615, 616, 617, 618, 619, 620, 621, 622, 658, 659, 660, 661, 662,
    663, 664, 665, 623, 624, 625, 626, 627, 628, 602, 603, 604, 605, 629, 630,
    631, 632, 633, 634, 666, 667, 668, 669, 670, 671, 672, 673, 635, 636, 637,
    638, 639, 640, 641, 642, 643, 674, 675, 676, 677, 678, 679, 680, 681, 644,
    645, 646, 647, 648, 649, 606, 607, 682, 683, 684, 685, 686, 687, 712, 713,
    714, 715, 716, 717, 718, 719, 720, 721, 722, 723, 724, 725, 726, 727, 728,
    729, 730, 731, 732, 733, 734, 735, 736, 737, 738, 739, 740, 741, 742, 743,
    744, 745, 746, 747, 748, 749, 750, 751, 752, 753, 754, 755, 688, 689, 690,
    691, 692, 693, 694, 695, 696, 697, 698, 699, 700, 701, 702, 703, 704, 705,
    756, 757, 758, 759, 760, 761, 762, 763, 764, 765, 766, 767, 768, 769, 770,
    771, 772, 773, 774, 775, 776, 777, 778, 779, 780, 781, 782, 783, 784, 785,
    786, 787, 788, 789, 790, 791, 792, 793, 794, 795, 796, 797, 798, 799, 706,
    707, 708, 709, 710, 711, 800, 801, 802, 803, 804, 805, 824, 825, 826, 827,
    828, 829, 830, 831, 896, 897, 898, 899, 900, 901, 902, 903, 904, 905, 832,
    833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847,
    848, 849, 850, 851, 906, 907, 908, 909, 910, 911, 912, 913, 914, 915, 852,
    853, 854, 855, 856, 857, 858, 859, 806, 807, 808, 809, 810, 811, 812, 813,
    814, 815, 816, 817, 860, 861, 862, 863, 864, 865, 866, 867, 916, 917, 918,
    919, 920, 921, 922, 923, 924, 925, 868, 869, 870, 871, 872, 873, 874, 875,
    876, 877, 878, 879, 880, 881, 882, 883, 884, 885, 886, 887, 926, 927, 928,
    929, 930, 931, 932, 933, 934, 935, 888, 889, 890, 891, 892, 893, 894, 895,
    818, 819, 820, 821, 822, 823};

 private:
  Int_t invalid() const;
  static constexpr Int_t NRUs = NLayers * NZonesPerLayer;
  static constexpr Int_t NModules = 280;
  static constexpr Int_t NChipsInfo = 7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 + 16 + 17 + 18 + 19 + 14;
  static constexpr Int_t NChipsPerCable = 1;
  static constexpr Int_t NLinks = 1;
  static constexpr Int_t NConnectors = 5;
  static constexpr Int_t NMaxChipsPerLadder = 5;
  static constexpr Int_t NRUCables = 25;

  static constexpr Int_t ZoneLadderIDmin[NZonesPerLayer / 2][NLayers]{
    {0, 21, 0, 21, 0, 23, 0, 28, 0, 29},
    {3, 18, 3, 18, 3, 20, 4, 24, 5, 25},
    {6, 15, 6, 15, 6, 17, 8, 20, 9, 21},
    {9, 12, 9, 12, 9, 13, 12, 16, 13, 17}};
  static constexpr Int_t ZoneLadderIDmax[NZonesPerLayer / 2][NLayers]{
    {2, 23, 2, 23, 2, 25, 3, 31, 4, 33},
    {5, 20, 5, 20, 5, 22, 7, 27, 8, 28},
    {8, 17, 8, 17, 8, 19, 11, 23, 12, 24},
    {11, 14, 11, 14, 12, 16, 15, 19, 16, 20}};

  static constexpr Int_t ZoneRUType[NZonesPerLayer / 2][NLayers / 2]{
    {1, 1, 1, 7, 11},
    {2, 2, 4, 8, 9},
    {2, 2, 3, 8, 10},
    {0, 0, 5, 6, 12}};

  static constexpr Int_t ChipConnectorCable[NConnectors][NMaxChipsPerLadder]{
    {5, 6, 7, 24, 23},
    {0, 1, 2, 3, 4},
    {17, 16, 15, 14, 13},
    {22, 21, 20, 19, 18},
    {12, 11, 10, 9, 8}};

  static const std::array<MFTChipMappingData, NChips> ChipMappingData;
  static const std::array<MFTModuleMappingData, NModules> ModuleMappingData;

  ///< number of chips per zone (RU)
  static constexpr std::array<int, NRUTypes> NChipsOnRUType{7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 14};

  // info on chips info within the zone (RU)
  std::array<ChipOnRUInfo, NChipsInfo> mChipsInfo;
  Int_t mChipInfoEntryRU[NRUTypes];

  /// info per zone (RU)
  std::array<RUInfo, NRUs> mRUInfo;
  std::vector<uint8_t> mFEEId2RUSW; // HW RU ID -> SW ID conversion

  std::vector<uint8_t> mCableHW2SW[NRUs];       ///< table of cables HW to SW conversion for each RU type
  std::vector<uint8_t> mCableHW2Pos[NRUs];      ///< table of cables positions in the ActiveLanes mask for each RU type
  std::vector<uint8_t> mCablePos[NRUs];         ///< reverse table of cables positions in the ActiveLanes mask for each RU type
  std::vector<uint8_t> mCableHWFirstChip[NRUs]; ///< 1st chip of module (relative to the 1st chip of the stave) served by each cable

  std::array<std::vector<uint16_t>, NRUs> mRUGlobalChipID;

  ClassDefNV(ChipMappingMFT, 1)
};
} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_ITSMFT_ALPIDE_CODER_H
#define ALICEO2_ITSMFT_ALPIDE_CODER_H
#include <Rtypes.h>
#include <cstdio>
#include <cstdint>
#include <vector>
#include <string>
#include <cstdint>
#include "Framework/Logger.h"
#include "PayLoadCont.h"
#include <map>
#include <fmt/format.h>

#include "ITSMFTReconstruction/PixelData.h"
#include "ITSMFTReconstruction/DecodingStat.h"
#include "DataFormatsITSMFT/NoiseMap.h"

#define ALPIDE_DECODING_STAT

/// \file AlpideCoder.h
/// \brief class for the ALPIDE data decoding/encoding
/// \author Ruben Shahoyan, ruben.shahoyan@cern.ch

namespace o2
{
namespace itsmft
{

/// Decoder / Encoder of ALPIDE payload stream.
/// All decoding methods are static. Only a few encoding methods are non-static but can be made so
/// if needed (will require to make the encoding buffers external to this class)

class AlpideCoder
{

 public:
  struct HitsRecord { // single record for hits (i.e. DATASHORT or DATALONG)
    HitsRecord() = default;
    ~HitsRecord() = default;
    HitsRecord(uint8_t r, uint8_t dc, uint16_t adr, uint8_t hmap) : region(r), dcolumn(dc), address(adr), hitmap(hmap) {}
    uint8_t region = 0;   // region ID
    uint8_t dcolumn = 0;  // double column ID
    uint16_t address = 0; // address in double column
    uint8_t hitmap = 0;   // hitmap for extra hits

    ClassDefNV(HitsRecord, 1); // TODO remove
  };

  struct PixLink { // single pixel on the selected row, referring eventually to the next pixel on the same row
    PixLink(short r = 0, short c = 0, int next = -1) : row(r), col(c), nextInRow(next) {}
    short row = 0;
    short col = 0;
    int nextInRow = -1; // index of the next pixel (link) on the same row

    ClassDefNV(PixLink, 1); // TODO remove
  };
  //
  static constexpr uint32_t ExpectChipHeader = 0x1 << 0;
  static constexpr uint32_t ExpectChipTrailer = 0x1 << 1;
  static constexpr uint32_t ExpectChipEmpty = 0x1 << 2;
  static constexpr uint32_t ExpectRegion = 0x1 << 3;
  static constexpr uint32_t ExpectData = 0x1 << 4;
  static constexpr uint32_t ExpectBUSY = 0x1 << 5;
  static constexpr int NRows = 512;
  static constexpr int RowMask = NRows - 1;
  static constexpr int NCols = 1024;
  static constexpr int NRegions = 32;
  static constexpr int NDColInReg = NCols / NRegions / 2;
  static constexpr int HitMapSize = 7;

  // masks for records components
  static constexpr uint32_t MaskEncoder = 0x3c00;                 // encoder (double column) ID takes 4 bit max (0:15)
  static constexpr uint32_t MaskPixID = 0x3ff;                    // pixel ID within encoder (double column) takes 10 bit max (0:1023)
  static constexpr uint32_t MaskDColID = MaskEncoder | MaskPixID; // mask for encoder + dcolumn combination
  static constexpr uint32_t MaskRegion = 0x1f;                    // region ID takes 5 bits max (0:31)
  static constexpr uint32_t MaskChipID = 0x0f;                    // chip id in module takes 4 bit max
  static constexpr uint32_t MaskROFlags = 0x0f;                   // RO flags in chip trailer takes 4 bit max
  static constexpr uint8_t MaskErrBusyViolation = 0x1 << 3;
  static constexpr uint8_t MaskErrDataOverrun = 0x3 << 2;
  static constexpr uint8_t MaskErrFatal = 0x7 << 1;
  static constexpr uint32_t MaskTimeStamp = 0xff;                 // Time stamps as BUNCH_COUNTER[10:3] bits
  static constexpr uint32_t MaskReserved = 0xff;                  // mask for reserved byte
  static constexpr uint32_t MaskHitMap = 0x7f;                    // mask for hit map: at most 7 hits in bits (0:6)
  //
  // flags for data records
  static constexpr uint32_t REGION = 0xc0;      // flag for region
  static constexpr uint32_t CHIPHEADER = 0xa0;  // flag for chip header
  static constexpr uint32_t CHIPTRAILER = 0xb0; // flag for chip trailer
  static constexpr uint32_t CHIPEMPTY = 0xe0;   // flag for empty chip
  static constexpr uint32_t DATALONG = 0x0000;  // flag for DATALONG
  static constexpr uint32_t DATASHORT = 0x4000; // flag for DATASHORT
  static constexpr uint32_t BUSYOFF = 0xf0;     // flag for BUSY_OFF
  static constexpr uint32_t BUSYON = 0xf1;      // flag for BUSY_ON

  // true if corresponds to DATALONG or DATASHORT: highest bit must be 0
  static bool isData(uint16_t v) { return (v & (0x1 << 15)) == 0; }
  static bool isData(uint8_t v) { return (v & (0x1 << 7)) == 0; }

  static constexpr int Error = -1;     // flag for decoding error
  static constexpr int EOFFlag = -100; // flag for EOF in reading

  AlpideCoder() = default;
  ~AlpideCoder() = default;

  static bool isEmptyChip(uint8_t b) { return (b & CHIPEMPTY) == CHIPEMPTY; }

  static void setNoisyPixels(const NoiseMap* noise) { mNoisyPixels = noise; }

  /// decode alpide data for the next non-empty chip from the buffer
  template <class T, typename CG>
  static int decodeChip(ChipPixelData& chipData, T& buffer, CG cidGetter)
  {
    // read record for single non-empty chip, updating on change module and cycle.
    // return number of records filled (>0), EOFFlag or Error
    //
    bool needSorting = false; // if DColumns order is wrong, do explicit reordering
    auto roErrHandler = [&chipData](uint8_t roErr) {
#ifdef ALPIDE_DECODING_STAT
      if (roErr == MaskErrBusyViolation) {
        chipData.setError(ChipStat::BusyViolation);
      } else if (roErr == MaskErrDataOverrun) {
        chipData.setError(ChipStat::DataOverrun);
      } else if (roErr == MaskErrFatal) {
        chipData.setError(ChipStat::Fatal);
      }
#endif
    };

    uint8_t dataC = 0, timestamp = 0;
    uint16_t dataS = 0, region = 0;
#ifdef ALPIDE_DECODING_STAT
    uint16_t rowPrev = 0xffff;
#endif
    //
    int nRightCHits = 0;               // counter for the hits in the right column of the current double column
    std::uint16_t rightColHits[NRows]; // buffer for the accumulation of hits in the right column
    std::uint16_t colDPrev = 0xffff;   // previously processed double column (to dected change of the double column)

    uint32_t expectInp = ExpectChipHeader | ExpectChipEmpty; // data must always start with chip header or chip empty flag

    chipData.clear();
    LOG(debug) << "NewEntry";
    while (buffer.next(dataC)) {
      //
      LOGP(debug, "dataC: {:#x} expect {:#b}", int(dataC), int(expectInp));
      // ---------- chip info ?
      uint8_t dataCM = dataC & (~MaskChipID);
      //
      if ((expectInp & ExpectChipEmpty) && dataCM == CHIPEMPTY) { // empty chip was expected
        chipData.setChipID(cidGetter(dataC & MaskChipID));        // here we set the global chip ID
        if (!buffer.next(timestamp)) {
#ifdef ALPIDE_DECODING_STAT
          chipData.setError(ChipStat::TruncatedChipEmpty);
#endif
          return unexpectedEOF("CHIP_EMPTY:Timestamp"); // abandon cable data
        }
        chipData.resetChipID();
        expectInp = ExpectChipHeader | ExpectChipEmpty;
        continue;
      }

      if ((expectInp & ExpectChipHeader) && dataCM == CHIPHEADER) { // chip header was expected
        chipData.setChipID(cidGetter(dataC & MaskChipID));          // here we set the global chip ID
        if (!buffer.next(timestamp)) {
#ifdef ALPIDE_DECODING_STAT
          chipData.setError(ChipStat::TruncatedChipHeader);
#endif
          return unexpectedEOF("CHIP_HEADER"); // abandon cable data
        }
        expectInp = ExpectRegion; // now expect region info
        continue;
      }

      // region info ?
      if ((expectInp & ExpectRegion) && (dataC & REGION) == REGION) { // chip header was seen, or hit data read
        region = dataC & MaskRegion;
        expectInp = ExpectData;
        continue;
      }

      if ((expectInp & ExpectChipTrailer) && dataCM == CHIPTRAILER) { // chip trailer was expected
        chipData.setROFlags(dataC & MaskROFlags);
#ifdef ALPIDE_DECODING_STAT
        uint8_t roErr = dataC & MaskROFlags;
        if (roErr) {
          roErrHandler(roErr);
        }
#endif
        // in case there are entries in the "right" columns buffer, add them to the container
        if (nRightCHits) {
          colDPrev++;
          for (int ihr = 0; ihr < nRightCHits; ihr++) {
            addHit(chipData, rightColHits[ihr], colDPrev);
          }
        }

        if (!chipData.getData().size() && !chipData.isErrorSet()) {
#ifdef ALPIDE_DECODING_STAT
          chipData.setError(ChipStat::TrailerAfterHeader);
#endif
          return unexpectedEOF("Trailer after header"); // abandon cable data
        }
        break;
      }

      // hit info ?
      if ((expectInp & ExpectData)) {
        if (isData(dataC)) { // region header was seen, expect data
                             // note that here we are checking on the byte rather than the short, need complete to ushort
          dataS = dataC << 8;
          if (!buffer.next(dataC)) {
#ifdef ALPIDE_DECODING_STAT
            chipData.setError(ChipStat::TruncatedRegion);
#endif
            return unexpectedEOF("CHIPDATA"); // abandon cable data
          }
          dataS |= dataC;
          LOGP(debug, "dataC: {:#x} dataS: {:#x} expect {:#b} in ExpectData", int(dataC), int(dataS), int(expectInp));

          // we are decoding the pixel addres, if this is a DATALONG, we will fetch the mask later
          uint16_t dColID = (dataS & MaskEncoder) >> 10;
          uint16_t pixID = dataS & MaskPixID;

          // convert data to usual row/pixel format
          uint16_t row = pixID >> 1;
          // abs id of left column in double column
          uint16_t colD = (region * NDColInReg + dColID) << 1; // TODO consider <<4 instead of *NDColInReg?
          bool rightC = (row & 0x1) ? !(pixID & 0x1) : (pixID & 0x1); // true for right column / lalse for left
          // if we start new double column, transfer the hits accumulated in the right column buffer of prev. double column
          if (colD != colDPrev) {
            if (colD < colDPrev && colDPrev != 0xffff) {
#ifdef ALPIDE_DECODING_STAT
              chipData.setError(ChipStat::WrongDColOrder); // abandon cable data
#endif
              return unexpectedEOF("Wrong column order"); // abandon cable data
              needSorting = true;                         // effectively disabled
            }
            colDPrev++;
            for (int ihr = 0; ihr < nRightCHits; ihr++) {
              addHit(chipData, rightColHits[ihr], colDPrev);
            }
            colDPrev = colD;
            nRightCHits = 0; // reset the buffer
#ifdef ALPIDE_DECODING_STAT
            rowPrev = 0xffff;
          }
          // this is a special test to exclude repeated data of the same pixel fired
          else if (row == rowPrev) { // same row/column fired repeatedly, hope this check is temporary
            chipData.setError(ChipStat::RepeatingPixel);
            chipData.addErrorInfo((uint64_t(colD + rightC) << 16) | uint64_t(row));
            if ((dataS & (~MaskDColID)) == DATALONG) { // skip pattern w/o decoding
              uint8_t hitsPattern = 0;
              if (!buffer.next(hitsPattern)) {
                chipData.setError(ChipStat::TruncatedLondData);
                return unexpectedEOF("CHIP_DATA_LONG:Pattern"); // abandon cable data
              }
              if (hitsPattern & (~MaskHitMap)) {
                chipData.setError(ChipStat::WrongDataLongPattern);
                return unexpectedEOF("CHIP_DATA_LONG:Pattern"); // abandon cable data
              }
              LOGP(debug, "hitsPattern: {:#b} expect {:#b}", int(hitsPattern), int(expectInp));
            }
            expectInp = ExpectChipTrailer | ExpectData | ExpectRegion;
            continue; // end of DATA(SHORT or LONG) processing
          } else {
            rowPrev = row;
#endif
          }

          // we want to have hits sorted in column/row, so the hits in right column of given double column
          // are first collected in the temporary buffer
          // real columnt id is col = colD + 1;
          if (rightC) {
            rightColHits[nRightCHits++] = row; // col = colD+1
          } else {
            addHit(chipData, row, colD); // col = colD, left column hits are added directly to the container
          }

          if ((dataS & (~MaskDColID)) == DATALONG) { // multiple hits ?
            uint8_t hitsPattern = 0;
            if (!buffer.next(hitsPattern)) {
#ifdef ALPIDE_DECODING_STAT
              chipData.setError(ChipStat::TruncatedLondData);
#endif
              return unexpectedEOF("CHIP_DATA_LONG:Pattern"); // abandon cable data
            }
            LOGP(debug, "hitsPattern: {:#b} expect {:#b}", int(hitsPattern), int(expectInp));
            if (hitsPattern & (~MaskHitMap)) {
#ifdef ALPIDE_DECODING_STAT
              chipData.setError(ChipStat::WrongDataLongPattern);
#endif
              return unexpectedEOF("CHIP_DATA_LONG:Pattern"); // abandon cable data
            }
            for (int ip = 0; ip < HitMapSize; ip++) {
              if (hitsPattern & (0x1 << ip)) {
                uint16_t addr = pixID + ip + 1, rowE = addr >> 1;
                if (addr & ~MaskPixID) {
#ifdef ALPIDE_DECODING_STAT
                  chipData.setError(ChipStat::WrongRow);
#endif
                  return unexpectedEOF(fmt::format("Non-existing encoder {} decoded, DataLong was {:x}", pixID, dataS)); // abandon cable data
                }
                rightC = ((rowE & 0x1) ? !(addr & 0x1) : (addr & 0x1)); // true for right column / lalse for left
                // the real columnt is int colE = colD + rightC;
                if (rightC) { // same as above
                  rightColHits[nRightCHits++] = rowE;
                } else {
                  addHit(chipData, rowE, colD + rightC); // left column hits are added directly to the container
                }
              }
            }
          }
        } else if (ChipStat::getAPENonCritical(dataC) >= 0) { // check for recoverable APE, if on: continue with ExpectChipTrailer | ExpectData | ExpectRegion expectation
#ifdef ALPIDE_DECODING_STAT
          chipData.setError(ChipStat::DecErrors(ChipStat::getAPENonCritical(dataC)));
#endif
        } else {
#ifdef ALPIDE_DECODING_STAT
          chipData.setError(ChipStat::NoDataFound);
#endif
          return unexpectedEOF(fmt::format("Expected DataShort or DataLong mask, got {:x}", dataS)); // abandon cable data
        }
        expectInp = ExpectChipTrailer | ExpectData | ExpectRegion;
        continue; // end of DATA(SHORT or LONG) processing
      }

      if (dataC == BUSYON) {
#ifdef ALPIDE_DECODING_STAT
        chipData.setError(ChipStat::BusyOn);
#endif
        continue;
      }
      if (dataC == BUSYOFF) {
#ifdef ALPIDE_DECODING_STAT
        chipData.setError(ChipStat::BusyOff);
#endif
        continue;
      }

      if (!dataC) {
        if (expectInp == (ExpectChipHeader | ExpectChipEmpty)) {
          continue;
        }
        chipData.setError(ChipStat::TruncatedBuffer);
        return unexpectedEOF("Abandon on 0-padding"); // abandon cable data
      }

      // in case of BUSY VIOLATION the Trailer may come directly after the Header
      if ((expectInp & ExpectRegion) && (dataCM == CHIPTRAILER) && (dataC & MaskROFlags)) {
        expectInp = ExpectChipHeader | ExpectChipEmpty;
        chipData.setROFlags(dataC & MaskROFlags);
        roErrHandler(dataC & MaskROFlags);
        break;
      }

      // check for APE errors, see https://alice.its.cern.ch/jira/browse/O2-1717?focusedCommentId=274714&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-274714
      bool fatalAPE = false;
      auto codeAPE = ChipStat::getAPECode(dataC, fatalAPE);
      if (codeAPE >= 0) {
#ifdef ALPIDE_DECODING_STAT
        chipData.setError(ChipStat::DecErrors(codeAPE));
#endif
        if (fatalAPE) {
          return unexpectedEOF(fmt::format("APE error {:#02x} [expectation = {:#02x}]", int(dataC), int(expectInp))); // abandon cable data
        } else {
          LOGP(error, "Code should not have entered here, APE: {:#02x}, expectation: {:#02x}", codeAPE, int(expectInp));
          return unexpectedEOF(fmt::format("APE error {:#02x} [expectation = {:#02x}]", int(dataC), int(expectInp))); // abandon cable data
        }
      }
#ifdef ALPIDE_DECODING_STAT
      chipData.setError(ChipStat::UnknownWord);
      // fill the error buffer with a few bytes of wrong data
      const uint8_t* begPtr = buffer.data();
      const uint8_t* endPtr = buffer.getEnd();
      const uint8_t* curPtr = buffer.getPtr();
      size_t offsBack = std::min(ChipPixelData::MAXDATAERRBYTES - ChipPixelData::MAXDATAERRBYTES_AFTER, size_t(curPtr - begPtr));
      size_t offsAfter = std::min(ChipPixelData::MAXDATAERRBYTES_AFTER, size_t(endPtr - curPtr));
      std::memcpy(chipData.getRawErrBuff().data(), curPtr - offsBack, offsBack + offsAfter);
      chipData.setNBytesInRawBuff(offsBack + offsAfter);
#endif
      return unexpectedEOF(fmt::format("Unknown word 0x{:x} [expectation = 0x{:x}]", int(dataC), int(expectInp))); // abandon cable data
    }

    if (needSorting && chipData.getData().size()) { // d.columns were in a wrong order, need to sort the data, RS: effectively disabled
      LOGP(error, "This code path should have been disabled");
      auto& pixData = chipData.getData();
      std::sort(pixData.begin(), pixData.end(),
                [](PixelData& a, PixelData& b) { return a.getCol() < b.getCol() || (a.getCol() == b.getCol() && a.getRowDirect() < b.getRowDirect()); });
      // if the columns ordering was wrong, detection of same pixel fired twice might have failed, make sure there are no duplicates
      auto currPix = pixData.begin(), prevPix = currPix++;
      while (currPix != pixData.end()) {
        if (prevPix->getCol() == currPix->getCol() && prevPix->getRowDirect() == currPix->getRowDirect()) {
          currPix = pixData.erase(prevPix);
        }
        prevPix = currPix++;
      }
    }
    return chipData.getData().size();
  }

  /// check if the byte corresponds to chip_header or chip_empty flag
  static bool isChipHeaderOrEmpty(uint8_t v)
  {
    v &= (~MaskChipID);
    return (v == CHIPEMPTY) || (v == CHIPHEADER);
  }
  // methods to use for data encoding

  static uint8_t bc2TimeStamp(int bc) { return (bc >> 3) & MaskTimeStamp; }
  static uint16_t timeStamp2BC(uint8_t ts) { return uint16_t(ts) << 3; }

  int encodeChip(PayLoadCont& buffer, const o2::itsmft::ChipPixelData& chipData,
                 uint16_t chipInModule, uint16_t bc, uint16_t roflags = 0);

  // Add empty record for the chip with chipID within its module for the bc
  void addEmptyChip(PayLoadCont& buffer, int chipInMod, int bc)
  {
    buffer.addFast(makeChipEmpty(chipInMod, bc));
  }
  //
  void print() const;
  void reset();

 private:
  /// Output a non-noisy fired pixel
  static void addHit(ChipPixelData& chipData, short row, short col)
  {
    if (mNoisyPixels) {
      auto chipID = chipData.getChipID();
      if (mNoisyPixels->isNoisy(chipID, row, col)) {
        return;
      }
    }
    LOGP(debug, "Add hit#{} at r:{}/c:{} of chip:{}", chipData.getData().size(), row, col, chipData.getChipID());
    chipData.getData().emplace_back(row, col);
  }

  ///< add pixed to compressed matrix, the data must be provided sorted in row/col, no check is done
  void addPixel(short row, short col)
  {
    int last = mPix2Encode.size();
    mPix2Encode.emplace_back(row, col);
    if (last && row == mPix2Encode[last - 1].row) { // extend current row
      mPix2Encode[last - 1].nextInRow = last;       // refer to new link in the same row
    } else {                                        // create new row
      mFirstInRow.push_back(last);
    }
  }

  ///< prepare chip header: 1010<chip id[3:0]><BUNCH COUNTER FOR FRAME[10:3] >
  static uint16_t makeChipHeader(short chipID, short bc)
  {
    uint16_t v = CHIPHEADER | (MaskChipID & chipID);
    v = (v << 8) | bc2TimeStamp(bc);
    return v;
  }

  ///< prepare chip trailer: 1011<readout flags[3:0]>
  static uint8_t makeChipTrailer(short roflags)
  {
    uint8_t v = CHIPTRAILER | (MaskROFlags & roflags);
    return v;
  }

  ///< prepare chip empty marker: 1110<chip id[3:0]><BUNCH COUNTER FOR FRAME[10:3] >
  static uint16_t makeChipEmpty(short chipID, short bc)
  {
    uint16_t v = CHIPEMPTY | (MaskChipID & chipID);
    v = (v << 8) | bc2TimeStamp(bc);
    return v;
  }

  ///< packs the address of region
  static uint8_t makeRegion(short reg)
  {
    uint8_t v = REGION | (reg & MaskRegion);
    return v;
  }

  ///< packs the address for data short
  static uint16_t makeDataShort(short encoder, short address)
  {
    uint16_t v = DATASHORT | (MaskEncoder & (encoder << 10)) | (address & MaskPixID);
    return v;
  }

  // packs the address for data long
  static uint16_t makeDataLong(short encoder, short address)
  {
    uint16_t v = DATALONG | (MaskEncoder & (encoder << 10)) | (address & MaskPixID);
    return v;
  }

  // ENCODING: converting hitmap to raw data
  int procDoubleCol(PayLoadCont& buffer, short reg, short dcol);

  ///< process region (16 double columns)
  int procRegion(PayLoadCont& buffer, short reg)
  {
    int nfound = 0;
    for (int idc = 0; idc < NDColInReg; idc++) {
      nfound += procDoubleCol(buffer, reg, idc);
    }
    return nfound;
  }

  void resetMap();

  ///< error message on unexpected EOF
  static int unexpectedEOF(const std::string& message)
  {
    LOG(debug) << message;
    return Error;
  }

  // =====================================================================
  //

  static const NoiseMap* mNoisyPixels;

  // cluster map used for the ENCODING only
  std::vector<int> mFirstInRow;     //! entry of 1st pixel of each non-empty row in the mPix2Encode
  std::vector<PixLink> mPix2Encode; //! pool of links: fired pixel + index of the next one in the row
  //
  ClassDefNV(AlpideCoder, 3);
};

} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_ITSMFT_GBTWORD_H
#define ALICEO2_ITSMFT_GBTWORD_H

// \file GBTWord.h
// \brief Classes for creation/interpretation of ITS/MFT GBT data

#include <Rtypes.h>
#include <cstdint>

namespace o2
{
namespace itsmft
{

constexpr uint64_t LANESMask = (0x1 << 28) - 1; // at most 28 lanes

/// GBT payload header flag
constexpr uint8_t GBTFlagDataHeader = 0xe0;
/// GBT payload trailer flag
constexpr uint8_t GBTFlagDataTrailer = 0xf0;
/// GBT trigger status word flag
constexpr uint8_t GBTFlagTrigger = 0xe8;
/// GBT diagnostic status word flag
constexpr uint8_t GBTFlagDiagnostic = 0xe4;
/// GBT calibration status word flag
constexpr uint8_t GBTFlagCalibration = 0xf8;

// GBT header flag in the RDH
constexpr uint8_t GBTFlagRDH = 0x00;
// GBT header flag for the ITS IB: 001 bbbbb with bbbbb -> Lane Number (0-8)
constexpr uint8_t GBTFlagDataIB = 0x20;
// GBT header flag for the ITS OB: 010 bb ccc with bb -> Connector Number (00,01,10,11), ccc -> Lane Number (0-6)
constexpr uint8_t GBTFlagDataOB = 0x40;
// GBT header flag for the MFT
constexpr uint8_t GBTFlagDataMFT = 0x80;
// GBT header flag for the ITS IB idagnostic : 101 bbbbb with bbbbb -> Lane Number (0-8)
constexpr uint8_t GBTFlagDiagnosticIB = 0xa0;
// GBT header flag for the ITS OB diagnostic word: 110 bb ccc with bb -> Connector Number (00,01,10,11), ccc -> Lane Number (0-6)
constexpr uint8_t GBTFlagDiagnosticOB = 0x60;

// GBT header flag for the ITS Status word : 111 bbbbb with bbbbb -> Lane Number
constexpr uint8_t GBTFlagStatus = 0xe0;

constexpr int GBTWordLength = 10;       // lentgh in bytes
constexpr int GBTPaddedWordLength = 16; // lentgh in bytes with padding

struct GBTWord {
  /// GBT word of 80 bits, bits 72:79 are reserver for GBT Header flag, the rest depends on specifications
  union {
    // RS: packing will be needed only if some of the members cross 64 bit boundary
    struct /*__attribute__((packed))*/ {
      uint64_t activeLanes : 28; /// 0:27   Bit map of lanes active and eligible for readout
      uint64_t na0hn : 36;       /// 28:71  reserved
      uint64_t na1hn : 8;        /// 28:71  reserved
      uint64_t id : 8;           /// 72:79  0xe0; Header Status Word (HSW) identifier
    };                           // HEADER NEW

    struct /*__attribute__((packed))*/ {
      uint64_t packetIdx : 16;    ///  0:15  Index of Data Packet within trigger
      uint64_t activeLanesL : 28; /// 16:43  Bit map of lanes active and eligible for readout
      uint64_t na0h : 20;         /// 44:64  reserved
      uint64_t na1h : 8;          /// 64:71  reserved
      //      uint64_t id : 8;           /// 72:79  0xe0; Header Status Word (HSW) identifier
    }; // HEADER Legacy

    struct /*__attribute__((packed))*/ {
      uint64_t lanesStops : 28;         ///  0:27  Bit map of “Valid Lane stops received”, 1 bit per lane, NOT USED
      uint64_t lanesTimeout : 28;       /// 28:55  Bit map of “Lane timeouts received”, 1 bit per lane, NOT USED
      uint64_t na1t : 8;                /// 56:63  reserved
      uint64_t packetDone : 1;          /// 64     = 1 when current trigger packets transmission done
      uint64_t transmissionTimeout : 1; /// 65     = 1 if timeout while waiting for data on lanes
      uint64_t packetOverflow : 1;      /// 66     = 1 if max number of packets reached
      uint64_t laneStartsViolation : 1; /// 67     = 1 if at least 1 lane (eligible for readout) had a “start violation”
      uint64_t laneTimeouts : 1;        /// 68     = 1 if at least 1 lane (eligible for readout) had a “start violation”
      uint64_t na2t : 3;                /// 69:71  reserved
      //  uint8_t  id : 8;                /// = 0xf0; Trailer Status Word (TSW) identifier
    }; // TRAILER

    struct /*__attribute__((packed))*/ {
      uint64_t triggerType : 12; /// 0:11   12 lowest bits of trigger type received from CTP
      uint64_t internal : 1;     /// 12     Used in Continuous Mode for internally generated trigger
      uint64_t noData : 1;       /// 13     No data expected (too close to previous trigger or error)
      uint64_t continuation : 1; /// 14     following data is continuation of the trigger from the previous CRU page
      uint64_t na1tr : 1;        /// 15     reserved
      uint64_t bc : 12;          /// 16:27  HB or internal trigger BC count or trigger BC from CTP
      uint64_t na2tr : 4;        /// 28:31  reserved
      uint64_t orbit : 32;       /// 32:63  Last received HB Orbit or trigger orbit count/ Orbit as received from CTP
      uint64_t na3tr : 6;        /// 64:71  reserved
      //  uint8_t  id : 8;                /// = 0xc0; Trigger Status Word (TSW) identifier
    }; // TRIGGER

    struct /*__attribute__((packed))*/ {
      uint64_t na0diag : 64; ///
      //      uint64_t id : 8;           /// 72:79  0xe4; diagnostic word identifier
    }; // HEADER Legacy

    struct __attribute__((packed)) {
      uint64_t calibUserField : 48; /// 0:47   user field
      uint64_t calibCounter : 24;   /// 48:71  elf-incrementing counter of
      //  uint64_t id : 8;            /// 72:79  0xf8; Calibration Status Word (HSW) identifier
    }; /// Calibration Data Word

    struct {
      uint64_t diagnosticData : 64; /// 0:63   Error specific diagnostic data
      uint64_t laneErrorID : 8;     /// 64:71  Identifier of the specific error condition
      //      uint64_t id : 8;           /// 72:79  0xe0;  Status Word (HSW) identifier
    }; // HEADER Legacy

    uint8_t data8[16]; // 80 bits GBT word + optional padding to 128 bits
    uint64_t data64[2] = {0};
  };

  GBTWord() = default;

  /// check if the GBT Header corresponds to GBT payload header
  bool isDataHeader() const { return id == GBTFlagDataHeader; }

  /// check if the GBT Header corresponds to GBT payload trailer
  bool isDataTrailer() const { return id == GBTFlagDataTrailer; }

  /// check if the GBT Header corresponds to GBT trigger word
  bool isTriggerWord() const { return id == GBTFlagTrigger; }

  /// check if the GBT Header corresponds to Diagnostic data
  bool isDiagnosticWord() const { return id == GBTFlagDiagnostic; }

  /// check if the GBT Header corresponds to Calibration word
  bool isCalibrationWord() const { return id == GBTFlagCalibration; }

  /// check if the GBT Header corresponds to ITS IB data (header is combined with lanes info)
  bool isDataIB() const { return (id & 0xe0) == GBTFlagDataIB; }

  /// check if the GBT Header corresponds to ITS IB diagnostics data (header is combined with lanes info)
  bool isCableDiagnosticIB() const { return (id & 0xe0) == GBTFlagDiagnosticIB; }

  /// check if the GBT Header corresponds to ITS OB data (header is combined with lanes/connector info)
  bool isDataOB() const { return (id & 0xe0) == GBTFlagDataOB; }

  /// check if the GBT Header corresponds to MFT data (header is combined with cable number)
  bool isDataMFT() const { return (id & 0xe0) == GBTFlagDataMFT; }

  /// check if the GBT Header corresponds to ITS OB diagnostics data (header is combined with lanes info)
  bool isCableDiagnosticOB() const { return (id & 0xe0) == GBTFlagDiagnosticIB; }

  /// check if the GBT Header corresponds to ITS IB or OB data (header is combined with lanes/connector info)
  bool isData() const { return isDataIB() || isDataOB() || isDataMFT(); }

  bool isCableDiagnostic() const { return isCableDiagnosticIB() || isCableDiagnosticIB(); }

  bool isStatus() const { return (id & 0xe0) == GBTFlagStatus; }

  const uint64_t* getW64() const { return data64; }
  const uint8_t* getW8() const { return data8; }

  uint8_t getHeader() const { return id; }

  void printX(bool padded = true) const;
  void printB(bool padded = true) const;

  ClassDefNV(GBTWord, 1);
};

struct GBTDataHeader : public GBTWord {
  /// Definition of ITS/MFT GBT Header: 80 bits long word
  /// In CRU data it must be the 1st word of the payload
  ///
  /// bits  0 : 27, Active lanes pattern
  /// bits 28 : 71, not used
  /// bits 72 : 79, header/trailer indicator

  GBTDataHeader() { id = GBTFlagDataHeader; }
  GBTDataHeader(uint32_t lanes)
  {
    id = GBTFlagDataHeader;
    activeLanes = lanes;
  }
  ClassDefNV(GBTDataHeader, 1);
};

struct GBTDataHeaderL : public GBTWord { // legacy version
  /// Definition of ITS/MFT GBT Header: 80 bits long word
  /// In CRU data it must be the 1st word of the payload
  ///
  /// bits  0 : 15, Index of GBT packet within trigger
  /// bits 16 : 43, Active lanes pattern
  /// bits 44 : 71, not used
  /// bits 72 : 79, header/trailer indicator

  GBTDataHeaderL() { id = GBTFlagDataHeader; }
  GBTDataHeaderL(int packetID, uint32_t lanes)
  {
    id = GBTFlagDataHeader;
    activeLanesL = lanes;
    packetIdx = packetID;
  }
  ClassDefNV(GBTDataHeaderL, 1);
};

struct GBTDataTrailer : public GBTWord {
  /// Definition of ITS/MFT GBT trailer: 80 bits long word
  /// In CRU data it must be the last word of the payload
  ///
  /// bits  0 : 27, Lanes stops received   // not used at the moment
  /// bits 28 : 55, Lane timeouts received // not used at the moment
  /// bits 56 : 63, not used
  /// bits 64 : 71, State of GBT_Packet:
  ///               4: lane_timeouts,  if at least 1 lane timed out
  ///               3: lane_starts_violation,  if at least 1 lane had a start violation
  ///               2: packet_overflow, if max number of packets reached
  ///               1: transmission_timeout, if timeout of transmission (lanes)
  ///               0: packet_done, if Packet finished
  enum PacketStates : int {
    PacketDone = 0,                              // Packet finished
    TransmissionTimeout = 1,                     // if timeout of transmission (lanes)
    PacketOverflow = 2,                          // if max number of packets reached
    LaneStartsViolation = 3,                     // if at least 1 lane had a start violation
    LaneTimeouts = 4,                            // if at least 1 lane timed out
    NStatesDefined,                              // total number of states defined
    MaxStateCombinations = 0x1 << NStatesDefined // number of possible combinations
  };

  GBTDataTrailer() { id = GBTFlagDataTrailer; }
  GBTDataTrailer(int lanesStop, int lanesTimeOut, bool done, bool transmTO, bool overflow, bool laneStViol, bool laneTO)
  {
    lanesStops = lanesStop;
    lanesTimeout = lanesTimeOut;
    packetDone = done;
    transmissionTimeout = transmTO;
    packetOverflow = overflow;
    laneStartsViolation = laneStViol;
    laneTimeouts = laneTO;
    id = GBTFlagDataTrailer;
  }

  uint8_t getPacketState() const { return data8[8]; }

  void setByte(uint8_t v, int which) = delete;

  ClassDefNV(GBTDataTrailer, 1);
};

struct GBTTrigger : public GBTWord {
  /// Definition of ITS/MFT Trigger status word
  /// Precedes the single trigger (continuous or triggered) data block
  ///
  /// bits  0 : 11, Trigger Type, 12 lowest bits of trigger type received from CTP for HB or 0
  /// bit  12       Internal Trigger, Used in Continuous Mode for internally generated trigger
  /// bits 13       No data expected (too close to previous trigger or error)
  /// bits 14       reserved
  /// bits 15       reserved
  /// bits 16:27    Trigger BC, HB or internal trigger BC count
  /// bits 28:31    reserved
  /// bits 32:63    Trigger Orbit, Last received HB Orbit + internal trigger orbit count
  /// bits 64:71    reserved
  /// bits 72:79    ID = 0xc0; Trigger Status Word (TrgSW) identifier

  GBTTrigger() { id = GBTFlagTrigger; }
  void setByte(uint8_t v, int which) = delete;

  ClassDefNV(GBTTrigger, 1);
};

struct GBTData : public GBTWord {
  /// Definition of ITS/MFT GBT paiload: 80 bits long word (can be padded to 128b) shipping
  /// Alpide data and having GBTHeader at positions 72:79
 public:
  /// extract lane of the IB as lowest 5 bits (ATTENTION: no check if this is really an IB header)
  static int getLaneIB(uint8_t v) { return v & 0x1f; }
  /// extract connector/lane of the OB as lowest 2/3 bits (ATTENTION: no check if this is really an OB header)
  static int getConnectorOB(uint8_t v) { return (v & 0x18) >> 3; } // lane only
  static int getLaneOB(uint8_t v) { return v & 0x7; }              // connector only
  static int getLaneOB(uint8_t v, int& connector)
  { // separately lane and connector
    connector = getConnectorOB(v);
    return getLaneOB(v);
  }
  static int getCableID(uint8_t v) { return v & 0x1f; } // combined connector and lane

  /// extract lane of the IB as lowest 5 bits (ATTENTION: no check if this is really an IB header)
  int getLaneIB() const { return getLaneIB(id); }
  /// extract connector/lane of the OB as lowest 2/3 bits (ATTENTION: no check if this is really an OB header)
  int getConnectorOB() const { return getConnectorOB(id); }                // lane only
  int getLaneOB() const { return getLaneOB(id); }                          // connector only
  int getLaneOB(int& connector) const { return getLaneOB(id, connector); } // separately lane and connector
  int getCableID() const { return getCableID(id); }                        // combined connector and lane

  ClassDefNV(GBTData, 1);
};

struct GBTDiagnostic : public GBTWord {
  /// Definition of GBT diagnostic word
  /// In CRU data it must be the only word after the RDH with stop
  ///
  /// bits  0 : 71, reserved
  /// bits 72 : 79, diagnostic flag

  GBTDiagnostic() { id = GBTFlagDiagnostic; }
  ClassDefNV(GBTDiagnostic, 1);
};

struct GBTCableDiagnostic : public GBTWord {
  /// Definition of cable diagnostic word
  ///
  /// bits  0 : 64, Error specific diagnostic data
  /// bits 63 : 71, Identifier of the specific error condition
  /// bits 72 : 79, IB or OB diagnostic flag + cable id

  GBTCableDiagnostic(bool ib = true, int lane = 0) { id = (ib ? GBTFlagDiagnosticIB : GBTFlagDiagnosticOB) | (lane & 0x1f); }
  int getCableID() const { return id & 0x1f; } // combined connector and lane
  bool isIB() const { return (id & 0xe0) == GBTFlagDiagnosticIB; }
  bool isOB() const { return (id & 0xe0) == GBTFlagDiagnosticOB; }
  ClassDefNV(GBTCableDiagnostic, 1);
};

struct GBTCableStatus : public GBTWord { // not sure this is correct, FIXME
  /// Definition of cable status word
  ///
  /// bits 72 : 79, Status flag + cable id

  GBTCableStatus(int lane = 0) { id = GBTFlagStatus | (lane & 0x1f); }
  int getCableID() const { return id & 0x1f; } // combined connector and lane
  ClassDefNV(GBTCableStatus, 1);
};

struct GBTCalibration : public GBTWord { // calibration data word
  /// bits  0 : 47, user-written tagging fields
  /// bits 48 : 71, self-incrementing counter of CDW words
  /// bits 72 : 79, calibration indicator

  GBTCalibration() { id = GBTFlagCalibration; }
  GBTCalibration(uint64_t userData, uint16_t counter = 0)
  {
    id = GBTFlagCalibration;
    calibUserField = userData & ((0x1UL << 48) - 1);
    calibCounter = counter & ((0x1 << 24) - 1);
  }
  ClassDefNV(GBTCalibration, 1);
};

} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_ITSMFT_PAYLOADCONT_H
#define ALICEO2_ITSMFT_PAYLOADCONT_H

#include <cstring>
#include <vector>
#include <functional>
#include <Rtypes.h>

/// \file PayLoadCont.h
/// \brief Declaration of class for continuos buffer of ALPIDE data
/// \author ruben.shahoyan@cern.ch

namespace o2
{
namespace itsmft
{

class PayLoadCont
{
  // continous buffer for the payload, just a preallocated vector with current position and end pointer.
  // Big endian is used.

 public:
  static constexpr size_t MinCapacity = 16;

  ///< allocate buffer
  PayLoadCont() = default;
  PayLoadCont(size_t sz) { expand(sz); }
  ~PayLoadCont() = default;

  PayLoadCont(const PayLoadCont& src);

  PayLoadCont& operator=(const PayLoadCont& src);

  const uint8_t* data() const { return mBuffer.data(); }

  ///< increase the buffer size
  void expand(size_t sz);

  bool isEmpty() const { return mPtr >= mEnd; }

  ///< make buffer empty w/o deallocating it
  void clear()
  {
    mPtr = mBuffer.data();
    mEnd = mPtr;
  }

  ///< get unused size
  size_t getUnusedSize() const { return mEnd > mPtr ? mEnd - mPtr : 0; }

  ///< get filled size
  size_t getSize() const { return mEnd - mBuffer.data(); }

  ///< get offset of the current ptr from the head
  size_t getOffset() const { return mPtr - mBuffer.data(); }

  ///< booked capacity
  size_t getCapacity() const { return mBuffer.size(); }

  ///< number of bytes still can accept w/o expanding the buffer
  size_t getFreeCapacity() const { return mBuffer.size() - getSize(); }

  ///< make sure buffer may accept at least n bytes
  void ensureFreeCapacity(size_t n)
  {
    if (getFreeCapacity() < n) {
      expand(getCapacity() + 2 * n);
    }
  }

  ///< fill n bytes with given symbol w/o checking for the size
  void fillFast(const uint8_t c, size_t n)
  {
    std::memset(mEnd, c, n);
    mEnd += n;
  }

  ///< add n bytes to the buffer w/o checking for the size
  void addFast(const uint8_t* ptr, size_t n)
  {
    std::memcpy(mEnd, ptr, n);
    mEnd += n;
  }

  ///< add new byte to the buffer w/o checking for the size
  void addFast(uint8_t val) { *mEnd++ = val; }

  ///< add new short to the buffer w/o checking for the size
  void addFast(uint16_t val)
  {
    *mEnd++ = val >> 8;
    *mEnd++ = 0xff & val;
  }

  ///< erase n bytes w/o checking for the underflow
  void eraseFast(size_t n) { mEnd -= n; }

  ///< erase n bytes
  void erase(size_t n)
  {
    if (n > getSize()) {
      clear();
    } else {
      eraseFast(n);
    }
  }

  ///< fill n bytes with given symbol
  void fill(const uint8_t c, size_t n)
  {
    ensureFreeCapacity(n);
    fillFast(c, n);
  }

  ///< add n bytes to the buffer, expand if needed. no check for overlap
  void add(const uint8_t* ptr, size_t n)
  {
    ensureFreeCapacity(n);
    addFast(ptr, n);
  }

  ///< add new byte to the buffer
  void add(uint8_t val)
  {
    ensureFreeCapacity(sizeof(val));
    addFast(val);
  }

  ///< add new short to the buffer
  void add(uint16_t val)
  {
    ensureFreeCapacity(sizeof(val));
    addFast(val);
  }

  ///< shrink buffer to requested size, no check on over/under flow
  void shrinkToSize(size_t sz)
  {
    mEnd = mPtr + sz;
  }

  ///< direct const access to value at a given slot, w/o checking for overflow
  uint8_t operator[](size_t i) const { return mBuffer[i]; }

  ///< direct access to value at a given slot, w/o checking for overflow
  uint8_t& operator[](size_t i) { return mBuffer[i]; }

  ///< read current character value from buffer w/o stepping forward
  bool current(uint8_t& v) const
  {
    if (mPtr < mEnd) {
      v = *mPtr;
      return true;
    }
    return false;
  }

  ///< read character value from buffer
  bool next(uint8_t& v)
  {
    if (mPtr < mEnd) {
      v = *mPtr++;
      return true;
    }
    return false;
  }

  ///< read short value from buffer
  bool next(uint16_t& v)
  {
    if (mPtr < mEnd - (sizeof(uint16_t) - 1)) {
      v = (*mPtr++) << 8;
      v |= (*mPtr++);
      return true;
    }
    return false;
  }

  ///< move current pointer to the head
  void rewind() { mPtr = mBuffer.data(); }

  ///< move all data between the mPtr and mEnd to the head of the buffer
  void moveUnusedToHead()
  {
    auto left = getUnusedSize();
    if (left < getOffset()) {
      std::memcpy(mBuffer.data(), mPtr, left); // there is no overlap
    } else {
      std::memmove(mBuffer.data(), mPtr, left); // there is an overlap
    }
    mPtr = mBuffer.data();
    mEnd = mPtr + left;
  }

  ///< move unused data to the head and upload new chunk of data
  // (attemtint to use all free capacity) using the method provided via getNext
  size_t append(std::function<size_t(uint8_t*, size_t)> getNext)
  {
    moveUnusedToHead();
    auto nRead = getNext(mEnd, getFreeCapacity());
    mEnd += nRead;
    return nRead;
  }

  /// direct write access
  uint8_t* getPtr() { return mPtr; }
  void setPtr(uint8_t* ptr) { mPtr = ptr; }

  uint8_t* getEnd() { return mEnd; }
  void setEnd(uint8_t* ptr) { mEnd = ptr; }

 private:
  std::vector<uint8_t> mBuffer; //! continuons data buffer
  uint8_t* mPtr = nullptr;      ///! pointer on the position in the buffer
  uint8_t* mEnd = nullptr;      ///! pointer on the last+1 valid entry in the buffer

  ClassDefNV(PayLoadCont, 1);
};
} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_ITSMFT_PAYLOADSG_H
#define ALICEO2_ITSMFT_PAYLOADSG_H

#include <cstdint>
#include <vector>
#include <Rtypes.h>

/// \file PayLoadSG.h
/// \brief Declaration of class for scatter-gather buffer
/// \author ruben.shahoyan@cern.ch

namespace o2
{
namespace itsmft
{

class PayLoadSG
{
  // scatter-gather buffer for the payload: base pointer + vector of references for pieces to collect
 public:
  using DataType = unsigned char;

  PayLoadSG() = default;
  ~PayLoadSG() = default;

  ///< add n bytes to the buffer
  void add(const DataType* ptr, size_t n)
  {
    if (n) {
      mBuffer.emplace_back(ptr, n);
    }
  }

  ///< read current character value from buffer w/o stepping forward
  bool current(char& v)
  {
    if (mCurrentPieceID < mBuffer.size()) {
      const auto& piece = mBuffer[mCurrentPieceID];
      if (mCurrentEntryInPiece < piece.size) {
        v = piece.data[mCurrentEntryInPiece];
        return true;
      } else {
        nextPiece();
        return current(v);
      }
    }
    return false;
  }

  ///< read character value from buffer
  bool next(char& v)
  {
    if (mCurrentPieceID < mBuffer.size()) {
      const auto& piece = mBuffer[mCurrentPieceID];
      if (mCurrentEntryInPiece < piece.size) {
        v = piece.data[mCurrentEntryInPiece++];
        return true;
      } else {
        nextPiece();
        return next(v);
      }
    }
    return false;
  }

  ///< read short value from buffer
  bool next(uint16_t& v)
  {
    char b0, b1;
    if (next(b0) && next(b1)) {
      v = (b0 << 8) | b1;
      return true;
    }
    return false;
  }

  ///< move current pointer to the head
  void rewind()
  {
    mCurrentPieceID = mCurrentEntryInPiece = 0;
  }

  ///< make buffer empty
  void clear()
  {
    mBuffer.clear();
    mCurrentPieceID = mCurrentEntryInPiece = 0;
  }

  struct SGPiece {
    const DataType* data = nullptr; // data of the piece
    uint32_t size = 0;              // size of the piece
    SGPiece() = default;
    SGPiece(const DataType* st, int n) : data(st), size(n) {}
  };

  void setDone() { mCurrentPieceID = mBuffer.size(); }

  size_t& currentPieceID() { return mCurrentPieceID; }
  size_t currentPieceID() const { return mCurrentPieceID; }

  size_t& currentEntryInPiece() { return mCurrentEntryInPiece; }
  size_t currentEntryInPiece() const { return mCurrentEntryInPiece; }

  const SGPiece* currentPiece() const { return mCurrentPieceID < mBuffer.size() ? &mBuffer[mCurrentPieceID] : nullptr; }

  const SGPiece* nextPiece()
  {
    // move to the next piece
    mCurrentEntryInPiece = 0;
    mCurrentPieceID++;
    return currentPiece();
  }

  const SGPiece* getPiece(int i) const { return &mBuffer[i]; }

  size_t getNPieces() const { return mBuffer.size(); }

 private:
  std::vector<SGPiece> mBuffer;   // list of pieces to fetch
  size_t mCurrentPieceID = 0;     // current piece
  size_t mCurrentEntryInPiece = 0; // offset within current piece

  ClassDefNV(PayLoadSG, 1);
};
} // namespace itsmft
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file DecodingStat.h
/// \brief Alpide Chip and GBT link decoding statistics

#ifndef _ALICEO2_DECODINGSTAT_H_
#define _ALICEO2_DECODINGSTAT_H_

#include <string>
#include <array>
#include <Rtypes.h>
#include "ITSMFTReconstruction/GBTWord.h"

namespace o2
{
namespace itsmft
{
class ChipPixelData;

struct ChipStat {
  enum ActionOnError : int {
    ErrActNone = 0x0,      // do nothing
    ErrActPropagate = 0x1, // propagate to decoded data
    ErrActDump = 0x2       // produce raw data dump
  };

  enum DecErrors : int {
    BusyViolation,                // Busy violation
    DataOverrun,                  // Data overrun
    Fatal,                        // Fatal (?)
    BusyOn,                       // Busy On
    BusyOff,                      // Busy Off
    TruncatedChipEmpty,           // Data was truncated after ChipEmpty
    TruncatedChipHeader,          // Data was truncated after ChipHeader
    TruncatedRegion,              // Data was truncated after Region record
    TruncatedLondData,            // Data was truncated in the LongData record
    WrongDataLongPattern,         // LongData pattern has highest bit set
    NoDataFound,                  // Region is not followed by Short or Long data
    UnknownWord,                  // Unknown word was seen
    RepeatingPixel,               // Same pixel fired more than once
    WrongRow,                     // Non-existing row decoded
    APE_STRIP,                    // lane data stripped for this chip event (behaviour changed with RU FW v1.16.0, for general APE behaviour see  https://alice.its.cern.ch/jira/browse/O2-1717)
    APE_RESERVED_F3,              // reserved F3
    APE_DET_TIMEOUT,              // detector timeout (FATAL)
    APE_OOT_START,                // 8b10b OOT (FATAL, start)
    APE_PROTOCOL_ERROR,           // event protocol error marker (FATAL, start)
    APE_LANE_FIFO_OVERFLOW_ERROR, // lane FIFO overflow error (FATAL)
    APE_FSM_ERROR,                // FSM error (FATAL, SEU error, reached an unknown state)
    APE_OCCUPANCY_RATE_LIMIT,     // pending detector events limit (FATAL)
    APE_OCCUPANCY_RATE_LIMIT_2,   // pending detector events limit in packager(FATAL)
    APE_LANE_PROTOCOL_ERROR,      // lane protocol error
    APE_RESERVED_FC,              // reserved FC
    APE_ERROR_NON_CRITICAL_BYTE,  // Error in non critical byte
    APE_OOT_NON_CRITICAL,         // OOT non-critical
    WrongDColOrder,               // DColumns non increasing
    InterleavedChipData,          // Chip data interleaved on the cable
    TruncatedBuffer,              // truncated buffer, 0 padding
    TrailerAfterHeader,           // trailer seen after header w/o FE of FD set
    NErrorsDefined
  };

  static constexpr std::array<std::string_view, NErrorsDefined> ErrNames = {
    "BusyViolation flag ON",                        // BusyViolation
    "DataOverrun flag ON",                          // DataOverrun
    "Fatal flag ON",                                // Fatal
    "BusyON",                                       // BusyOn
    "BusyOFF",                                      // BusyOff
    "Data truncated after ChipEmpty",               // TruncatedChipEmpty
    "Data truncated after ChipHeader",              // TruncatedChipHeader
    "Data truncated after Region",                  // TruncatedRegion
    "Data truncated after LongData",                // TruncatedLondData
    "LongData pattern has highest bit set",         // WrongDataLongPattern
    "Region is not followed by Short or Long data", // NoDataFound
    "Unknown word",                                 // UnknownWord
    "Same pixel fired multiple times",              // RepeatingPixel
    "Non-existing row decoded",                     // WrongRow
    "APE_STRIP",                                    // lane data stripped for this chip event (behaviour changed with RU FW v1.16.0, for general APE behaviour see  https://alice.its.cern.ch/jira/browse/O2-1717)
    "APE_RESERVED_F3",                              // reserved F3
    "APE_DET_TIMEOUT",                              // detector timeout (FATAL)
    "APE_OOT_START",                                // 8b10b OOT (FATAL, start)
    "APE_PROTOCOL_ERROR",                           // event event protocol error marker (FATAL, start)
    "APE_LANE_FIFO_OVERFLOW_ERROR",                 // lane FIFO overflow error (FATAL)
    "APE_FSM_ERROR",                                // FSM error (FATAL, SEU error, reached an unknown state)
    "APE_OCCUPANCY_RATE_LIMIT",                     // pending detector events limit (FATAL)
    "APE_OCCUPANCY_RATE_LIMIT_2",                   // pending detector events limit in packager(FATAL)
    "APE_LANE_PROTOCOL_ERROR",                      // lane protocol error
    "APE_RESERVED_FC",                              // reserved
    "APE_ERROR_IN_NON_CRITICAL_BYTE",               // Error in non critical byte
    "APE_OOT_NON_CRITICAL",                         // OOT non-critical
    "DColumns non-increasing",                      // DColumns non increasing
    "Chip data interleaved on the cable",           // Chip data interleaved on the cable
    "TruncatedBuffer",                              // truncated buffer, 0 padding
    "TrailerAfterHeader"                            // trailer seen after header w/o FE of FD set
  };

  static constexpr std::array<uint32_t, NErrorsDefined> ErrActions = {
    ErrActPropagate | ErrActDump, // Busy violation
    ErrActPropagate | ErrActDump, // Data overrun
    ErrActPropagate | ErrActDump, // Fatal (?)
    ErrActNone,                   // Busy On
    ErrActNone,                   // Busy Off
    ErrActPropagate | ErrActDump, // Data was truncated after ChipEmpty
    ErrActPropagate | ErrActDump, // Data was truncated after ChipHeader
    ErrActPropagate | ErrActDump, // Data was truncated after Region record
    ErrActPropagate | ErrActDump, // Data was truncated in the LongData record
    ErrActPropagate | ErrActDump, // LongData pattern has highest bit set
    ErrActPropagate | ErrActDump, // Region is not followed by Short or Long data
    ErrActPropagate | ErrActDump, // Unknown word was seen
    ErrActPropagate,              // Same pixel fired more than once
    ErrActPropagate | ErrActDump, // Non-existing row decoded
    ErrActPropagate | ErrActDump, // lane data stripped for this chip event (behaviour changed with RU FW v1.16.0, for general APE behaviour see  https://alice.its.cern.ch/jira/browse/O2-1717)
    ErrActPropagate | ErrActDump, // reserved F3
    ErrActPropagate | ErrActDump, // detector timeout (FATAL)
    ErrActPropagate | ErrActDump, // 8b10b OOT (FATAL, start)
    ErrActPropagate | ErrActDump, // event protocol error marker (FATAL, start)
    ErrActPropagate | ErrActDump, // lane FIFO overflow error (FATAL)
    ErrActPropagate | ErrActDump, // FSM error (FATAL, SEU error, reached an unknown state)
    ErrActPropagate | ErrActDump, // pending detector events limit (FATAL)
    ErrActPropagate | ErrActDump, // pending detector events limit in packager(FATAL)
    ErrActPropagate | ErrActDump, // lane protocol error
    ErrActPropagate | ErrActDump, // reserved FC
    ErrActPropagate | ErrActDump, // Error in non critical byte
    ErrActPropagate | ErrActDump, // OOT non-critical
    ErrActPropagate | ErrActDump, // DColumns non increasing
    ErrActPropagate | ErrActDump, // Chip data interleaved on the cable
    ErrActPropagate | ErrActDump, // Truncated buffer while something was expected
    ErrActPropagate | ErrActDump  // trailer seen after header w/o FE of FD set
  };
  uint16_t feeID = -1;
  size_t nHits = 0;
  std::array<uint32_t, NErrorsDefined> errorCounts = {};
  ChipStat() = default;
  ChipStat(uint16_t _feeID) : feeID(_feeID) {}

  void clear()
  {
    memset(errorCounts.data(), 0, sizeof(uint32_t) * errorCounts.size());
    nHits = 0;
  }

  static int getAPENonCritical(uint8_t c)
  {
    if (c == 0xfd || c == 0xfe) {
      return APE_STRIP + c - 0xf2;
    }
    return -1;
  }

  // return APE DecErrors code or -1 if not APE error, set fatal flag if needd
  static int getAPECode(uint8_t c, bool& ft)
  {
    if (c < 0xf2 || c > 0xfe) {
      ft = false;
      return -1;
    }
    ft = c >= 0xf2 && c <= 0xfe;
    return APE_STRIP + c - 0xf2;
  }
  uint32_t getNErrors() const;
  uint32_t addErrors(uint32_t mask, uint16_t chID, int verbosity);
  uint32_t addErrors(const ChipPixelData& d, int verbosity);
  void print(bool skipNoErr = true, const std::string& pref = "FEEID") const;

  ClassDefNV(ChipStat, 1);
};

struct ChipError {
  uint32_t id = -1;
  uint32_t nerrors = 0;
  uint32_t errors = 0;

  int16_t getChipID() const { return int16_t(id & 0xffff); }
  uint16_t getFEEID() const { return uint16_t(id >> 16); }
  static uint32_t composeID(uint16_t feeID, int16_t chipID) { return uint32_t(feeID) << 16 | uint16_t(chipID); }
  ClassDefNV(ChipError, 1);
};

/// Statistics for per-link decoding
struct GBTLinkDecodingStat {
  /// counters for format checks

  enum DecErrors : int {
    ErrNoRDHAtStart,             // page does not start with RDH
    ErrPageNotStopped,           // RDH is stopped, but the time is not matching the ~stop packet
    ErrStopPageNotEmpty,         // Page with RDH.stop is not empty
    ErrPageCounterDiscontinuity, // RDH page counters for the same RU/trigger are not continuous
    ErrRDHvsGBTHPageCnt,         // RDH and GBT header page counters are not consistent
    ErrMissingGBTTrigger,        // GBT trigger word was expected but not found
    ErrMissingGBTHeader,         // GBT payload header was expected but not found
    ErrMissingGBTTrailer,        // GBT payload trailer was expected but not found
    ErrNonZeroPageAfterStop,     // all lanes were stopped but the page counter in not 0
    ErrUnstoppedLanes,           // end of FEE data reached while not all lanes received stop
    ErrDataForStoppedLane,       // data was received for stopped lane
    ErrNoDataForActiveLane,      // no data was seen for lane (which was not in timeout)
    ErrIBChipLaneMismatch,       // chipID (on module) was different from the lane ID on the IB stave
    ErrCableDataHeadWrong,       // cable data does not start with chip header or empty chip
    ErrInvalidActiveLanes,       // active lanes pattern conflicts with expected for given RU type
    ErrPacketCounterJump,        // jump in RDH.packetCounter
    ErrPacketDoneMissing,        // packet done is missing in the trailer while CRU page is not over
    ErrMissingDiagnosticWord,    // missing diagnostic word after RDH with stop
    ErrGBTWordNotRecognized,     // GBT word not recognized
    ErrWrongeCableID,            // Invalid cable ID
    NErrorsDefined
  };
  static constexpr std::array<std::string_view, NErrorsDefined> ErrNames = {
    "Page data not start with expected RDH",                             // ErrNoRDHAtStart
    "RDH is stopped, but the time is not matching the stop packet",      // ErrPageNotStopped
    "Page with RDH.stop does not contain diagnostic word only",          // ErrStopPageNotEmpty
    "RDH page counters for the same RU/trigger are not continuous",      // ErrPageCounterDiscontinuity
    "RDH and GBT header page counters are not consistent",               // ErrRDHvsGBTHPageCnt
    "GBT trigger word was expected but not found",                       // ErrMissingGBTTrigger
    "GBT payload header was expected but not found",                     // ErrMissingGBTHeader
    "GBT payload trailer was expected but not found",                    // ErrMissingGBTTrailer
    "All lanes were stopped but the page counter in not 0",              // ErrNonZeroPageAfterStop
    "End of FEE data reached while not all lanes received stop",         // ErrUnstoppedLanes
    "Data was received for stopped lane",                                // ErrDataForStoppedLane
    "No data was seen for lane (which was not in timeout)",              // ErrNoDataForActiveLane
    "ChipID (on module) was different from the lane ID on the IB stave", // ErrIBChipLaneMismatch
    "Cable data does not start with chip header or empty chip",          // ErrCableDataHeadWrong
    "Active lanes pattern conflicts with expected for given RU type",    // ErrInvalidActiveLanes
    "Jump in RDH_packetCounter",                                         // ErrPacketCounterJump
    "Packet done is missing in the trailer while CRU page is not over",  // ErrPacketDoneMissing
    "Missing diagnostic GBT word after RDH with stop",                   // ErrMissingDiagnosticWord
    "GBT word not recognized",                                           // ErrGBTWordNotRecognized
    "Wrong cable ID"                                                     // ErrWrongeCableID
  };

  uint16_t feeID = 0; // FeeID
  // Note: packet here is meant as a group of CRU pages belonging to the same trigger
  uint32_t nPackets = 0;                                                        // total number of packets (RDH pages)
  uint32_t nTriggers = 0;                                                       // total number of triggers (ROFs)
  std::array<uint32_t, NErrorsDefined> errorCounts = {};                        // error counters
  std::array<uint32_t, GBTDataTrailer::MaxStateCombinations> packetStates = {}; // packet status from the trailer

  void clear()
  {
    nPackets = 0;
    nTriggers = 0;
    errorCounts.fill(0);
    packetStates.fill(0);
  }

  void print(bool skipNoErr = true) const;

  ClassDefNV(GBTLinkDecodingStat, 3);
};

} // namespace itsmft
} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_RUINFO_H
#define ALICEO2_RUINFO_H

// \file RUInfo.h
// \brief Transient structures for ITS and MFT HW -> SW mapping

#include <Rtypes.h>
#include <cstdint>
#include <string>

namespace o2
{
namespace itsmft
{

struct RUInfo {
  ///< provides details of the RU (e.g.stave)
  const std::uint16_t DUMMY16 = 0xffff;
  const std::uint8_t DUMMY8 = 0xff;
  uint16_t idSW = DUMMY16;         // software ID
  uint16_t idHW = DUMMY16;         // hardware ID
  uint16_t firstChipIDSW = 0xffff; // SW ID of the 1st chip of the module served by this RU
  uint8_t layer = DUMMY8;          // layer
  uint8_t ruType = DUMMY8;         // RU type (=subbarel)
  uint8_t nCables = DUMMY8;        // by how many cables it is served
};

struct ChipOnRUInfo {
  ///< provides details on chip location and HW labeling within the RU (stave)
  const std::uint8_t DUMMY8 = 0xff;
  std::uint8_t id = DUMMY8;             // chip ID within the stave (RU)
  std::uint8_t moduleSW = DUMMY8;       // sequential ID of the chip's module on stave
  std::uint8_t moduleHW = DUMMY8;       // HW ID of the chip's module on stave
  std::uint8_t chipOnModuleSW = DUMMY8; // sequential ID of the chip on the module
  std::uint8_t chipOnModuleHW = DUMMY8; // sequential ID of the chip on the module
  std::uint8_t cableSW = DUMMY8;        // order in which data of the cable is queried at decoding (to have chips SW IDs sorted)
  std::uint8_t cableHW = DUMMY8;        // cable HW ID
  std::uint8_t cableHWPos = DUMMY8;     // position of the bit of this cable in the activeLanes
  std::uint8_t chipOnCable = DUMMY8;    // chip within the cable (0 = master)

  std::string asString() const;
  void print() const;
};

struct ChipInfo {
  const std::uint16_t DUMMY16 = 0xffff;
  const std::uint8_t DUMMY8 = 0xff;
  const ChipOnRUInfo* chOnRU = nullptr; // pointer on chip detailed info within the stave

  std::uint16_t user = DUMMY16; // reserved for the user ?
  std::uint16_t id = DUMMY16;
  std::uint16_t ru = DUMMY16;     // RU sequential id
  std::uint16_t ruType = DUMMY16; // RU (or subBarrel) type

  std::string asString() const;
  void print() const;
};
} // namespace itsmft
} // namespace o2

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class o2::dataformats::EvIndex with content:

#line 1 "G__O2CommonDataFormat dictionary payload"

#ifndef ZDC_FASTSIM_ONNX
  #define ZDC_FASTSIM_ONNX 1
#endif
#ifndef ENABLE_UPGRADES
  #define ENABLE_UPGRADES 1
#endif
#ifndef FMT_LOCALE
  #define FMT_LOCALE 1
#endif
#ifndef FMT_SHARED
  #define FMT_SHARED 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_COMMON_TIMESTAMP_H
#define ALICEO2_COMMON_TIMESTAMP_H

#include "GPUCommonRtypes.h"
#include "GPUCommonDef.h"

namespace o2
{
namespace dataformats
{
// A minimal TimeStamp class for simulation in the spirit of FairTimeStamp
// but without having FairLinks attached
template <typename T>
class TimeStamp
{
 public:
  GPUhdDefault() TimeStamp() CON_DEFAULT;
  GPUhdDefault() ~TimeStamp() CON_DEFAULT;
  GPUdi() TimeStamp(T time) { mTimeStamp = time; }
  GPUdi() T getTimeStamp() const { return mTimeStamp; }
  GPUdi() void setTimeStamp(T t) { mTimeStamp = t; }
  GPUdi() bool operator==(const TimeStamp<T>& t) const { return mTimeStamp == t.mTimeStamp; }

 private:
  T mTimeStamp = 0;
  ClassDefNV(TimeStamp, 1);
};

template <typename T, typename E>
class TimeStampWithError : public TimeStamp<T>
{
 public:
  GPUdDefault() TimeStampWithError() = default;
  GPUd() TimeStampWithError(T t, E te) : TimeStamp<T>(t), mTimeStampError(te) {}
  GPUdi() E getTimeStampError() const { return mTimeStampError; }
  GPUdi() void setTimeStampError(E te) { mTimeStampError = te; }

 private:
  E mTimeStampError = 0;
  ClassDefNV(TimeStampWithError, 1);
};

#ifndef GPUCA_GPUCODE
template <typename T>
std::ostream& operator<<(std::ostream& os, const TimeStamp<T>& t)
{
  // stream itself
  os << t.getTimeStamp();
  return os;
}

template <typename T, typename E>
std::ostream& operator<<(std::ostream& os, const TimeStampWithError<T, E>& t)
{
  // stream itself
  os << t.getTimeStamp() << " +/- " << t.getTimeStampError();
  return os;
}
#endif
} // namespace dataformats
} // namespace o2

#endif /* ALICEO2_COMMON_TIMESTAMP_H */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file EvIndex.h
/// \brief Class to store event ID and index in the event for objects like track, cluster...
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_EVINDEX_H
#define ALICEO2_EVINDEX_H

#include <Rtypes.h>

namespace o2
{
namespace dataformats
{
// Composed Label to encode object origin in the tree or other segmented input

template <typename E = int, typename I = int>
class EvIndex
{
 public:
  EvIndex(E ev, I idx) { set(ev, idx); }
  EvIndex(const EvIndex<E, I>& src) = default;
  EvIndex() = default;
  ~EvIndex() = default;
  void set(E ev, I idx)
  {
    mEvent = ev;
    mIndex = idx;
  }
  E getEvent() const { return mEvent; }
  I getIndex() const { return mIndex; }
  void setEvent(E ev) { mEvent = ev; }
  void setIndex(I ind) { mIndex = ind; }
  void shiftEvent(E inc) { mEvent += inc; }
  void shiftIndex(I inc) { mIndex += inc; }

 private:
  E mEvent{}; ///< ID of event or chunk or message containing referred object
  I mIndex{}; ///< index in the event

  ClassDefNV(EvIndex, 1);
};
} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file RangeReference.h
/// \brief Class to refer to the 1st entry and N elements of some group in the continuous container
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_RANGEREFERENCE_H
#define ALICEO2_RANGEREFERENCE_H

#include "GPUCommonRtypes.h"
#include "GPUCommonDef.h"

namespace o2
{
namespace dataformats
{
// Composed range reference

template <typename FirstEntry = int, typename NElem = int>
class RangeReference
{
 public:
  GPUd() RangeReference(FirstEntry ent, NElem n) { set(ent, n); }
  GPUdDefault() RangeReference(const RangeReference<FirstEntry, NElem>& src) = default;
  GPUdDefault() RangeReference() = default;
  GPUdDefault() ~RangeReference() = default;
  GPUd() void set(FirstEntry ent, NElem n)
  {
    mFirstEntry = ent;
    mEntries = n;
  }
  GPUd() void clear() { set(0, 0); }
  GPUd() FirstEntry getFirstEntry() const { return mFirstEntry; }
  GPUd() FirstEntry getEntriesBound() const { return mFirstEntry + mEntries; }
  GPUd() NElem getEntries() const { return mEntries; }
  GPUd() void setFirstEntry(FirstEntry ent) { mFirstEntry = ent; }
  GPUd() void setEntries(NElem n) { mEntries = n; }
  GPUd() void changeEntriesBy(NElem inc) { mEntries += inc; }
  GPUd() bool operator==(const RangeReference& other) const
  {
    return mFirstEntry == other.mFirstEntry && mEntries == other.mEntries;
  }

 private:
  FirstEntry mFirstEntry; ///< 1st entry of the group
  NElem mEntries = 0;     ///< number of entries

  ClassDefNV(RangeReference, 1);
};

// Compact (32bit long) range reference
template <int NBitsN>
class RangeRefComp
{
  using Base = unsigned int;

 private:
  static constexpr int NBitsTotal = sizeof(Base) * 8;
  static constexpr Base MaskN = ((0x1 << NBitsN) - 1);
  static constexpr Base MaskR = (~Base(0)) & (~MaskN);
  Base mData = 0; ///< packed 1st entry reference + N entries
  GPUd() void sanityCheck()
  {
    static_assert(NBitsN < NBitsTotal, "NBitsN too large");
  }

 public:
  GPUd() RangeRefComp(int ent, int n) { set(ent, n); }
  GPUdDefault() RangeRefComp() = default;
  GPUdDefault() RangeRefComp(const RangeRefComp& src) = default;
  GPUhd() void set(int ent, int n)
  {
    mData = (Base(ent) << NBitsN) + (Base(n) & MaskN);
  }
  GPUd() static constexpr Base getMaxFirstEntry() { return MaskR >> NBitsN; }
  GPUd() static constexpr Base getMaxEntries() { return MaskN; }
  GPUhd() int getFirstEntry() const { return mData >> NBitsN; }
  GPUhd() int getEntries() const { return mData & ((0x1 << NBitsN) - 1); }
  GPUhd() int getEntriesBound() const { return getFirstEntry() + getEntries(); }
  GPUhd() void setFirstEntry(int ent) { mData = (Base(ent) << NBitsN) | (mData & MaskN); }
  GPUhd() void setEntries(int n) { mData = (mData & MaskR) | (Base(n) & MaskN); }
  GPUhd() void changeEntriesBy(int inc) { setEntries(getEntries() + inc); }
  GPUhd() bool operator==(const RangeRefComp& other) const
  {
    return mData == other.mData;
  }

  ClassDefNV(RangeRefComp, 1);
};

} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// @brief  Interaction record encoding BC, orbit, time

#ifndef ALICEO2_INTERACTIONRECORD_H
#define ALICEO2_INTERACTIONRECORD_H

#include "GPUCommonRtypes.h"
#ifndef GPUCA_ALIGPUCODE
#include <iosfwd>
#include <cstdint>
#endif
#include <cmath>
#include "CommonConstants/LHCConstants.h"

namespace o2
{
struct InteractionRecord {
  // information about bunch crossing and orbit
  static constexpr uint16_t DummyBC = 0xffff;
  static constexpr uint32_t DummyOrbit = 0xffffffff;
  static constexpr double DummyTime = DummyBC * o2::constants::lhc::LHCBunchSpacingNS + DummyOrbit * o2::constants::lhc::LHCOrbitNS;

  uint16_t bc = DummyBC;       ///< bunch crossing ID of interaction
  uint32_t orbit = DummyOrbit; ///< LHC orbit

  InteractionRecord() = default;

  InteractionRecord(double tNS)
  {
    setFromNS(tNS);
  }

  InteractionRecord(uint16_t b, uint32_t orb) : bc(b), orbit(orb)
  {
  }

  InteractionRecord(const InteractionRecord& src) = default;

  void clear()
  {
    bc = 0xffff;
    orbit = 0xffffffff;
  }

  bool isDummy() const
  {
    return bc > o2::constants::lhc::LHCMaxBunches;
  }

  void setFromNS(double ns)
  {
    bc = ns2bc(ns, orbit);
  }

  static double bc2ns(int bc, unsigned int orbit)
  {
    return bc * o2::constants::lhc::LHCBunchSpacingNS + orbit * o2::constants::lhc::LHCOrbitNS;
  }

  static int ns2bc(double ns, unsigned int& orb)
  {
    orb = ns > 0 ? ns / o2::constants::lhc::LHCOrbitNS : 0;
    ns -= orb * o2::constants::lhc::LHCOrbitNS;
    return std::round(ns / o2::constants::lhc::LHCBunchSpacingNS);
  }

  double bc2ns() const
  {
    return bc2ns(bc, orbit);
  }

  bool operator==(const InteractionRecord& other) const
  {
    return (bc == other.bc) && (orbit == other.orbit);
  }

  bool operator!=(const InteractionRecord& other) const
  {
    return (bc != other.bc) || (orbit != other.orbit);
  }

  int64_t differenceInBC(const InteractionRecord& other) const
  {
    // return difference in bunch-crossings
    int64_t diffBC = int(bc) - other.bc;
    if (orbit != other.orbit) {
      diffBC += (int64_t(orbit) - other.orbit) * o2::constants::lhc::LHCMaxBunches;
    }
    return diffBC;
  }

  float differenceInBCNS(const InteractionRecord& other) const
  {
    // return difference in bunch-crossings in ns
    return differenceInBC(other) * o2::constants::lhc::LHCBunchSpacingNS;
  }

  float differenceInBCMUS(const InteractionRecord& other) const
  {
    // return difference in bunch-crossings in ms
    return differenceInBC(other) * o2::constants::lhc::LHCBunchSpacingMUS;
  }

  int64_t toLong() const
  {
    // return as single long number
    return (int64_t(orbit) * o2::constants::lhc::LHCMaxBunches) + bc;
  }

  void setFromLong(int64_t l)
  {
    // set from long BC counter
    bc = l % o2::constants::lhc::LHCMaxBunches;
    orbit = l / o2::constants::lhc::LHCMaxBunches;
  }

  static InteractionRecord long2IR(int64_t l)
  {
    // set from long BC counter
    return {uint16_t(l % o2::constants::lhc::LHCMaxBunches), uint32_t(l / o2::constants::lhc::LHCMaxBunches)};
  }

  bool operator>(const InteractionRecord& other) const
  {
    return (orbit == other.orbit) ? (bc > other.bc) : (orbit > other.orbit);
  }

  bool operator>=(const InteractionRecord& other) const
  {
    return !((*this) < other);
  }

  bool operator<(const InteractionRecord& other) const
  {
    return (orbit == other.orbit) ? (bc < other.bc) : (orbit < other.orbit);
  }

  bool operator<=(const InteractionRecord& other) const
  {
    return !((*this) > other);
  }

  InteractionRecord operator--()
  {
    // prefix decrement operator, no check for orbit wrap
    if (!bc--) {
      orbit--;
      bc = o2::constants::lhc::LHCMaxBunches - 1;
    }
    return InteractionRecord(*this);
  }

  InteractionRecord operator--(int)
  {
    // postfix decrement operator, no check for orbit wrap
    InteractionRecord tmp(*this);
    if (!bc--) {
      orbit--;
      bc = o2::constants::lhc::LHCMaxBunches - 1;
    }
    return tmp;
  }

  InteractionRecord operator++()
  {
    // prefix increment operator,no check for orbit wrap
    if ((++bc) == o2::constants::lhc::LHCMaxBunches) {
      orbit++;
      bc = 0;
    }
    return InteractionRecord(*this);
  }

  InteractionRecord operator++(int)
  {
    // postfix increment operator, no check for orbit wrap
    InteractionRecord tmp(*this);
    if ((++bc) == o2::constants::lhc::LHCMaxBunches) {
      orbit++;
      bc = 0;
    }
    return tmp;
  }

  InteractionRecord& operator+=(int64_t dbc)
  {
    // bc self-addition operator, no check for orbit wrap
    auto l = toLong() + dbc;
    bc = l % o2::constants::lhc::LHCMaxBunches;
    orbit = l / o2::constants::lhc::LHCMaxBunches;
    return *this;
  }

  InteractionRecord& operator-=(int64_t dbc)
  {
    // bc self-subtraction operator, no check for orbit wrap
    return operator+=(-dbc);
  }

  InteractionRecord& operator+=(const InteractionRecord& add)
  {
    // InteractionRecord self-addition operator, no check for orbit wrap
    auto l = this->toLong() + add.toLong();
    bc = l % o2::constants::lhc::LHCMaxBunches;
    orbit = l / o2::constants::lhc::LHCMaxBunches;
    return *this;
  }

  InteractionRecord& operator-=(const InteractionRecord& add)
  {
    // InteractionRecord self-subtraction operator, no check for orbit wrap
    auto l = this->toLong() - add.toLong();
    bc = l % o2::constants::lhc::LHCMaxBunches;
    orbit = l / o2::constants::lhc::LHCMaxBunches;
    return *this;
  }

  InteractionRecord operator+(int64_t dbc) const
  {
    // bc addition operator, no check for orbit wrap
    auto l = toLong() + dbc;
    return InteractionRecord(l % o2::constants::lhc::LHCMaxBunches, l / o2::constants::lhc::LHCMaxBunches);
  }

  InteractionRecord operator-(int64_t dbc) const
  {
    // bc subtraction operator, no check for orbit wrap
    auto l = toLong() - dbc;
    return InteractionRecord(l % o2::constants::lhc::LHCMaxBunches, l / o2::constants::lhc::LHCMaxBunches);
  }

  InteractionRecord operator+(const InteractionRecord& add) const
  {
    // InteractionRecord addition operator, no check for orbit wrap
    auto l = this->toLong() + add.toLong();
    return InteractionRecord(l % o2::constants::lhc::LHCMaxBunches, l / o2::constants::lhc::LHCMaxBunches);
  }

  InteractionRecord operator-(const InteractionRecord& add) const
  {
    // InteractionRecord subtraction operator, no check for orbit wrap
    auto l = this->toLong() - add.toLong();
    return InteractionRecord(l % o2::constants::lhc::LHCMaxBunches, l / o2::constants::lhc::LHCMaxBunches);
  }

#ifndef GPUCA_ALIGPUCODE
  void print() const;
  std::string asString() const;
  friend std::ostream& operator<<(std::ostream& stream, InteractionRecord const& ir);
#endif
  ClassDefNV(InteractionRecord, 3);
};

struct InteractionTimeRecord : public InteractionRecord {
  double timeInBCNS = 0.; ///< time in NANOSECONDS relative to orbit/bc

  InteractionTimeRecord() = default;

  /// create from the interaction record and time in the bunch (in ns)
  InteractionTimeRecord(const InteractionRecord& ir, double t_in_bc) : InteractionRecord(ir), timeInBCNS(t_in_bc)
  {
  }

  /// create from the abs. (since orbit=0/bc=0) time in NS
  InteractionTimeRecord(double tNS) : InteractionRecord(tNS)
  {
    timeInBCNS = tNS - bc2ns();
  }

  /// set the from the abs. (since orbit=0/bc=0) time in NS
  void setFromNS(double tNS)
  {
    InteractionRecord::setFromNS(tNS);
    timeInBCNS = tNS - bc2ns();
  }

  void clear()
  {
    InteractionRecord::clear();
    timeInBCNS = 0.;
  }

  double getTimeOffsetWrtBC() const
  {
    return timeInBCNS;
  }

  /// get time in ns from orbit=0/bc=0
  double getTimeNS() const
  {
    return timeInBCNS + bc2ns();
  }

  bool operator==(const InteractionTimeRecord& other) const
  {
    return this->InteractionRecord::operator==(other) && (timeInBCNS == other.timeInBCNS);
  }

  bool operator!=(const InteractionTimeRecord& other) const
  {
    return this->InteractionRecord::operator!=(other) || (timeInBCNS != other.timeInBCNS);
  }

  bool operator>(const InteractionTimeRecord& other) const
  {
    return (this->InteractionRecord::operator>(other)) || (this->InteractionRecord::operator==(other) && (timeInBCNS > other.timeInBCNS));
  }

  bool operator>=(const InteractionTimeRecord& other) const
  {
    return !((*this) < other);
  }

  bool operator<(const InteractionTimeRecord& other) const
  {
    return (this->InteractionRecord::operator<(other)) || (this->InteractionRecord::operator==(other) && (timeInBCNS < other.timeInBCNS));
  }

  bool operator<=(const InteractionTimeRecord& other) const
  {
    return !((*this) > other);
  }

#ifndef GPUCA_ALIGPUCODE
  void print() const;
  std::string asString() const;
  friend std::ostream& operator<<(std::ostream& stream, InteractionTimeRecord const& ir);
#endif

  ClassDefNV(InteractionTimeRecord, 1);
};
} // namespace o2

namespace std
{
// defining std::hash for InteractionRecord to be used with std containers
template <>
struct hash<o2::InteractionRecord> {
 public:
  size_t operator()(const o2::InteractionRecord& ir) const
  {
    return ir.toLong();
  }
};
} // namespace std

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file IRFrame.h
/// \brief Class to delimit start and end IR of certain time period
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_IRFRAME_H
#define ALICEO2_IRFRAME_H

#include "MathUtils/Primitive2D.h"
#include "CommonDataFormat/InteractionRecord.h"

namespace o2
{
namespace dataformats
{

// Bracket of 2 IRs.
// We could just alias it to the bracket specialization, but this would create
// problems with fwd.declaration
struct IRFrame : public o2::math_utils::detail::Bracket<o2::InteractionRecord> {
  using o2::math_utils::detail::Bracket<o2::InteractionRecord>::Bracket;

  uint64_t info = 0;

  ClassDefNV(IRFrame, 2);
};

} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// @brief pattern of filled (interacting) bunches

#ifndef ALICEO2_BUNCHFILLING_H
#define ALICEO2_BUNCHFILLING_H

#include "CommonConstants/LHCConstants.h"
#include <Rtypes.h>
#include <bitset>
#include <string>
#include <array>

namespace o2
{
class BunchFilling
{
 public:
  using Pattern = std::bitset<o2::constants::lhc::LHCMaxBunches>;

  BunchFilling() = default;
  BunchFilling(const std::string& beamA, const std::string& beamC);
  BunchFilling(const std::string& interactingBC);

  // this is a pattern creator similar to Run1/2 AliTriggerBCMask
  // The string has the following syntax:
  // "25L 25(2H2LH 3(23HL))"
  //  - H/h -> 1  L/l -> 0
  //  - spaces, new lines are white characters
  static Pattern createPattern(const std::string& p);

  // create pattern string from filled bucket
  static std::string buckets2PatternString(const std::vector<int>& buckets, int ibeam);

  // get interacting bunches pattern (B)
  const auto& getBCPattern() const { return mPattern; }

  // get pattern or clockwise (0, A) and anticlockwise (1, C) beams at P2
  const auto& getBeamPattern(int beam) const { return mBeamAC[beam]; }

  // get pattern of interacting BCs (-1) or beams filled BCs at P2 (0,1)
  const auto& getPattern(int dir = -1) const { return dir < 0 ? getBCPattern() : getBeamPattern(dir); }

  // create pattern from filled bucket
  void buckets2BeamPattern(const std::vector<int>& buckets, int ibeam);

  // get number of interacting bunches (-1) and number of filled bunches for clockwise (0, A) and anticlockwise (1, C) beams
  int getNBunches(int dir = -1) const { return dir < 0 ? mPattern.count() : mBeamAC[dir].count(); }

  // test interacting bunch
  bool testInteractingBC(int bcID) const { return mPattern[bcID]; }

  // test bean bunch
  bool testBeamBunch(int bcID, int dir) const { return mBeamAC[dir][bcID]; }

  // test interacting (-1) or clockwise (0, A) and anticlockwise (1, C) beams bunch
  bool testBC(int bcID, int dir = -1) const { return dir < 0 ? testInteractingBC(bcID) : testBeamBunch(bcID, dir); }

  // BC setters, dir=-1 is for interacting bunches pattern, 0, 1 for clockwise (C) and anticlockwise (A) beams
  void setBC(int bcID, bool active = true, int dir = -1);
  void setBCTrain(int nBC, int bcSpacing, int firstBC, int dir = -1);
  void setBCTrains(int nTrains, int trainSpacingInBC, int nBC, int bcSpacing, int firstBC, int dir = -1);

  // new format for setting bunches pattern, see createPattern comments
  void setBCFilling(const std::string& patt, int dir = -1);

  void setInteractingBCsFromBeams() { mPattern = getBeamPattern(0) & getBeamPattern(1); }

  int getFirstFilledBC(int dir = -1) const;
  int getLastFilledBC(int dir = -1) const;

  // print pattern of bunches, dir=0,1: for C,A beams, dir=-1: for interacting BCs, otherwise: all
  void print(int dir = -2, bool filledOnly = true, int bcPerLine = 20) const;

  // get vector with filled BCs
  std::vector<int> getFilledBCs(int dir = -1) const;

  // set BC filling a la TPC TDR, 12 50ns trains of 48 BCs
  // but instead of uniform train spacing we add 96empty BCs after each train
  void setDefault()
  {
    //    setBCTrains(12, 96, 48, 2, 0); // obsolete way of setting the trains
    setBCFilling("12(48(HL) 96L)", 0);
    setBCFilling("12(48(HL) 96L)", 1);
    setInteractingBCsFromBeams();
  }

  // merge this bunch filling with other
  void mergeWith(o2::BunchFilling const& other);

  static BunchFilling* loadFrom(const std::string& fileName, const std::string& objName = "");

 private:
  static bool parsePattern(const unsigned char*& input, Pattern& patt, int& ibit, int& level);

  Pattern mPattern{};                                                 // Pattern of interacting BCs at P2
  std::array<Pattern, o2::constants::lhc::NBeamDirections> mBeamAC{}; // pattern of 2 beam bunches at P2, 0 for A, 1 for C beam

  ClassDefNV(BunchFilling, 2);
};
} // namespace o2

namespace framework
{
template <typename T>
struct is_messageable;
template <>
struct is_messageable<o2::BunchFilling> : std::true_type {
};

} // namespace framework

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// @file  AbstractRef.h
/// \brief Class to refer to object indicating its Indec, Source and status flags
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_ABSTRACT_REF_H
#define ALICEO2_ABSTRACT_REF_H

#include "GPUCommonDef.h"
#include "GPUCommonRtypes.h"
#include "GPUCommonTypeTraits.h"

namespace o2
{
namespace dataformats
{

template <int NBIdx, int NBSrc, int NBFlg>
class AbstractRef
{
  template <int NBIT>
  static constexpr auto MVAR()
  {
    static_assert(NBIT <= 64, "> 64 bits not supported");
    typename std::conditional<(NBIT > 32), uint64_t, typename std::conditional<(NBIT > 16), uint32_t, typename std::conditional<(NBIT > 8), uint16_t, uint8_t>::type>::type>::type tp = 0;
    return tp;
  }

 public:
  using Base_t = decltype(AbstractRef::MVAR<NBIdx + NBSrc + NBFlg>());
  using Idx_t = decltype(AbstractRef::MVAR<NBIdx>());
  using Src_t = decltype(AbstractRef::MVAR<NBSrc>());
  using Flg_t = decltype(AbstractRef::MVAR<NBFlg>());

  static constexpr Base_t BaseMask = Base_t((((0x1U << (NBIdx + NBSrc + NBFlg - 1)) - 1) << 1) + 1);
  static constexpr Idx_t IdxMask = Idx_t((((0x1U << (NBIdx - 1)) - 1) << 1) + 1);
  static constexpr Src_t SrcMask = Src_t((((0x1U << (NBSrc - 1)) - 1) << 1) + 1);
  static constexpr Flg_t FlgMask = Flg_t((((0x1U << (NBFlg - 1)) - 1) << 1) + 1);
  static constexpr int NBitsIndex() { return NBIdx; }
  static constexpr int NBitsSource() { return NBSrc; }
  static constexpr int NBitsFlags() { return NBFlg; }

  GPUdDefault() AbstractRef() = default;

  GPUdi() AbstractRef(Idx_t idx, Src_t src) { set(idx, src); }
  GPUdi() AbstractRef(Base_t raw) : mRef(raw) {}

  //
  GPUdi() Idx_t getIndex() const { return static_cast<Idx_t>(mRef & IdxMask); }
  GPUdi() void setIndex(Idx_t idx) { mRef = (mRef & (BaseMask & ~IdxMask)) | (IdxMask & idx); }

  //
  GPUdi() Src_t getSource() const { return static_cast<Idx_t>((mRef >> NBIdx) & SrcMask); }
  GPUdi() void setSource(Src_t src) { mRef = (mRef & (BaseMask & ~(SrcMask << NBIdx))) | ((SrcMask & src) << NBIdx); }

  //
  GPUdi() Flg_t getFlags() const { return static_cast<Flg_t>((mRef >> (NBIdx + NBSrc)) & FlgMask); }
  GPUdi() void setFlags(Flg_t f) { mRef = (mRef & (BaseMask & ~(FlgMask << (NBIdx + NBSrc)))) | ((FlgMask & f) << NBIdx); }
  GPUdi() bool testBit(int i) const { return (mRef >> (NBIdx + NBSrc)) & ((0x1U << i) & FlgMask); }
  GPUdi() void setBit(int i) { mRef = (mRef & (BaseMask & ~(0x1U << (i + NBIdx + NBSrc)))) | (((0x1U << i) & FlgMask) << (NBIdx + NBSrc)); }
  GPUdi() void resetBit(int i) { mRef = (mRef & (BaseMask & ~(0x1U << (i + NBIdx + NBSrc)))); }
  GPUdi() void set(Idx_t idx, Src_t src) { mRef = (mRef & ((Base_t)FlgMask << (NBIdx + NBSrc))) | ((SrcMask & Src_t(src)) << NBIdx) | (IdxMask & Idx_t(idx)); }

  GPUdi() Base_t getRaw() const { return mRef; }
  GPUdi() void setRaw(Base_t v) { mRef = v; }
  GPUdi() Base_t getRawWOFlags() const { return mRef & (IdxMask | (SrcMask << NBIdx)); }
  GPUdi() bool isIndexSet() const { return getIndex() != IdxMask; }
  GPUdi() bool isSourceSet() const { return getSource() != SrcMask; }

  GPUdi() bool operator==(const AbstractRef& o) const { return getRawWOFlags() == o.getRawWOFlags(); }
  GPUdi() bool operator!=(const AbstractRef& o) const { return !operator==(o); }

 protected:
  Base_t mRef = IdxMask | (SrcMask << NBIdx); // packed reference, dummy by default

  ClassDefNV(AbstractRef, 1);
};

} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// @file  FlatHisto1D.h
/// \brief 1D messeageable histo class
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_FLATHISTO1D_H
#define ALICEO2_FLATHISTO1D_H

#include <Rtypes.h>
#include <vector>
#include <gsl/span>
#include <type_traits>
#include <cassert>
#include <memory>

class TH1F;

namespace o2
{
namespace dataformats
{

/*
  Fast 1D histo class which can be messages as
  FlatHisto1D<float> histo(nbins, xmin, xmax);
  histo.fill(...);
  pc.outputs().snapshot(Output{"Origin", "Desc", 0, Lifetime::Timeframe}, histo.getBase());

  and received (read only!) as
  const auto hdata = pc.inputs().get<gsl::span<float>>("histodata");
  FlatHisto1D<float> histoView;
  histoView.adoptExternal(hdata);
  or directly
  FlatHisto1D<float> histoView(pc.inputs().get<gsl::span<float>>("histodata"));
*/

template <typename T = float>
class FlatHisto1D
{
  static_assert(std::is_same<T, float>::value || std::is_same<T, double>::value, "T must be float or double");

 public:
  enum { NBins,
         XMin,
         XMax,
         BinSize,
         NServiceSlots };

  FlatHisto1D() = default;
  FlatHisto1D(uint32_t nb, T xmin, T xmax);
  FlatHisto1D(const FlatHisto1D& src);
  FlatHisto1D(const gsl::span<const T> ext) { adoptExternal(ext); }
  void adoptExternal(const gsl::span<const T> ext);
  void init()
  {
    // when reading from file, need to call this method to make it operational
    assert(mContainer.size() > NServiceSlots);
    init(gsl::span<const T>(mContainer.data(), mContainer.size()));
  }

  uint32_t getNBins() const { return mNBins; }
  T getXMin() const { return mXMin; }
  T getXMax() const { return mXMax; }
  T getBinSize() const { return mBinSize; }
  T getBinSizeInv() const { return mBinSizeInv; }

  T getBinContent(uint32_t ib) const
  {
    assert(ib < getNBins());
    return mDataPtr[ib];
  }

  const T* getData() const
  {
    return mDataPtr;
  }

  T getBinContentForX(T x) const
  {
    auto bin = getBin(x);
    return isValidBin(bin) ? getBinContent(bin) : 0;
  }

  bool isValidBin(uint32_t bin) const { return bin < getNBins(); }
  bool isBinEmpty(uint32_t bin) const { return getBinContent(bin) == 0; }

  T getBinStart(uint32_t i) const
  {
    assert(i < getNBins());
    return getXMin() + i * getBinSize();
  }

  T getBinCenter(uint32_t i) const
  {
    assert(i < getNBins());
    return getXMin() + (i + 0.5) * getBinSize();
  }

  T getBinEnd(uint32_t i) const
  {
    assert(i < getNBins());
    return getXMin() + (i + 1) * getBinSize();
  }

  void add(const FlatHisto1D& other);

  void subtract(const FlatHisto1D& other);

  void setBinContent(uint32_t bin, T w)
  {
    assert(canFill() && isValidBin(bin));
    mDataPtr[bin] = w;
  }

  void clear()
  {
    assert(canFill());
    memset(mDataPtr, 0, sizeof(T) * getNBins());
  }

  T getSum() const;

  int fill(T x)
  {
    uint32_t bin = getBin(x);
    if (isValidBin(bin)) {
      mDataPtr[bin]++;
      return (int)bin;
    }
    return -1;
  }

  int fill(T x, T w)
  {
    uint32_t bin = getBin(x);
    if (isValidBin(bin)) {
      mDataPtr[bin] += w;
      return (int)bin;
    }
    return -1;
  }

  void fillBin(uint32_t bin, T w)
  {
    if (isValidBin(bin)) {
      mDataPtr[bin] += w;
    }
  }

  uint32_t getBin(T x) const
  {
    auto dx = x - getXMin();
    return dx < 0 ? 0xffffffff : uint32_t(dx * getBinSizeInv());
  }

  bool canFill() const
  {
    // histo can be filled only if hase its own data, otherwise only query can be done on the view
    return mContainer.size() > NServiceSlots;
  }

  std::unique_ptr<TH1F> createTH1F(const std::string& name = "histo1d") const;

  const std::vector<T>& getBase() const { return mContainer; }
  gsl::span<const T> getView() const { return mContainerView; }

 protected:
  void init(const gsl::span<const T> ext);

  std::vector<T> mContainer;           //    global container
  gsl::span<const T> mContainerView{}; //!   pointer on container
  T* mDataPtr{};                       //!   histo data
  T mXMin{};                           //!
  T mXMax{};                           //!
  T mBinSize{};                        //!
  T mBinSizeInv{};                     //!
  uint32_t mNBins{};                   //!

  ClassDefNV(FlatHisto1D, 2);
};

using FlatHisto1D_f = FlatHisto1D<float>;
using FlatHisto1D_d = FlatHisto1D<double>;

} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// @file  FlatHisto2D.h
/// \brief 2D messeageable histo class
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_FLATHISTO2D_H
#define ALICEO2_FLATHISTO2D_H

#include <Rtypes.h>
#include <vector>
#include <gsl/span>
#include <type_traits>
#include <cassert>
#include <memory>

class TH1F;
class TH2F;

namespace o2
{
namespace dataformats
{

/*
  Fast 2D histo class which can be messages as
  FlatHisto2D<float> histo(nbinsX, xmin, xmax, nbinsY, ymin, ymax);
  histo.fill(...);
  pc.outputs().snapshot(Output{"Origin", "Desc", 0, Lifetime::Timeframe}, histo.getBase());

  and received (read only!) as
  const auto hdata = pc.inputs().get<gsl::span<float>>("histodata");
  FlatHisto2D<float> histoView;
  histoView.adoptExternal(hdata);
  or directly
  FlatHisto2D<float> histoView(pc.inputs().get<gsl::span<float>>("histodata"));
*/

template <typename T = float>
class FlatHisto2D
{
  static_assert(std::is_same<T, float>::value || std::is_same<T, double>::value, "T must be float or double");

 public:
  enum { NBinsX,
         NBinsY,
         XMin,
         XMax,
         YMin,
         YMax,
         BinSizeX,
         BinSizeY,
         NServiceSlots };

  FlatHisto2D() = default;
  FlatHisto2D(uint32_t nbx, T xmin, T xmax, uint32_t nby, T ymin, T ymax);
  FlatHisto2D(const gsl::span<const T> ext) { adoptExternal(ext); }
  FlatHisto2D(const FlatHisto2D& src);

  void adoptExternal(const gsl::span<const T> ext);
  void init()
  {
    // when reading from file, need to call this method to make it operational
    assert(mContainer.size() > NServiceSlots);
    init(gsl::span<const T>(mContainer.data(), mContainer.size()));
  }

  uint32_t getNBinsX() const { return mNBinsX; }
  uint32_t getNBinsY() const { return mNBinsY; }
  uint32_t getNBins() const { return getNBinsX() * getNBinsY(); }

  T getXMin() const { return mXMin; }
  T getXMax() const { return mXMax; }
  T getYMin() const { return mYMin; }
  T getYMax() const { return mYMax; }
  T getBinSizeX() const { return mBinSizeX; }
  T getBinSizeY() const { return mBinSizeY; }
  T getBinSizeXInv() const { return mBinSizeXInv; }
  T getBinSizeYInv() const { return mBinSizeYInv; }

  T getBinContent(uint32_t ib) const
  {
    assert(ib < getNBins());
    return mDataPtr[ib];
  }

  T getBinContent(uint32_t ibx, uint32_t iby) const { return getBinContent(getGlobalBin(ibx, iby)); }

  T getBinContentForXY(T x, T y) const { return getBinContent(getBinX(x), getBinY(y)); }

  bool isValidBin(uint32_t bin) const { return bin < getNBins(); }
  bool isBinEmpty(uint32_t bin) const { return getBinContent(bin) == 0; }

  T getBinXStart(uint32_t i) const
  {
    assert(i < getNBinsX());
    return getXMin() + i * getBinSizeX();
  }

  T getBinXCenter(uint32_t i) const
  {
    assert(i < getNBinsX());
    return getXMin() + (i + 0.5) * getBinSizeX();
  }

  T getBinXEnd(uint32_t i) const
  {
    assert(i < getNBinsX());
    return getXMin() + (i + 1) * getBinSizeX();
  }

  T getBinYStart(uint32_t i) const
  {
    assert(i < getNBinsY());
    return getYMin() + i * getBinSizeY();
  }

  T getBinYCenter(uint32_t i) const
  {
    assert(i < getNBinsY());
    return getYMin() + (i + 0.5) * getBinSizeY();
  }

  T getBinYEnd(uint32_t i) const
  {
    assert(i < getNBinsY());
    return getYMin() + (i + 1) * getBinSizeY();
  }

  uint32_t getXBin(uint32_t i) const { return i / getNBinsY(); }
  uint32_t getYBin(uint32_t i) const { return i % getNBinsY(); }

  void add(const FlatHisto2D& other);

  void subtract(const FlatHisto2D& other);

  void setBinContent(uint32_t bin, T w)
  {
    assert(canFill() && isValidBin(bin));
    mDataPtr[bin] = w;
  }

  void setBinContent(uint32_t binX, uint32_t binY, T w)
  {
    auto bin = getGlobalBin(binX, binY);
    setBinContent(bin, w);
  }

  void clear()
  {
    assert(canFill());
    memset(mDataPtr, 0, sizeof(T) * getNBins());
  }

  T getSum() const;

  int fill(T x, T y)
  {
    uint32_t bin = getBin(x, y);
    if (isValidBin(bin)) {
      mDataPtr[bin]++;
      return (int)bin;
    }
    return -1;
  }

  int fill(T x, T y, T w)
  {
    uint32_t bin = getBin(x, y);
    if (isValidBin(bin)) {
      mDataPtr[bin] += w;
      return (int)bin;
    }
    return -1;
  }

  void fillBin(uint32_t bin, T w)
  {
    if (isValidBin(bin)) {
      mDataPtr[bin] += w;
    }
  }

  void fillBin(uint32_t bx, uint32_t by, T w)
  {
    auto bin = getGlobalBin(bx, by);
    if (isValidBin(bin)) {
      mDataPtr[bin] += w;
    }
  }

  uint32_t getBinX(T x) const
  {
    auto dx = x - getXMin();
    return dx < 0 ? 0xffffffff : uint32_t(dx * getBinSizeXInv());
  }

  uint32_t getBinY(T y) const
  {
    auto dy = y - getYMin();
    return dy < 0 ? 0xffffffff : uint32_t(dy * getBinSizeYInv());
  }

  uint32_t getBin(T x, T y) const
  {
    auto bx = getBinX(x), by = getBinY(y);
    return bx < getNBinsX() && by < getNBinsY() ? getGlobalBin(bx, by) : 0xffffffff;
  }

  bool canFill() const
  {
    // histo can be filled only if hase its own data, otherwise only query can be done on the view
    return mContainer.size() > NServiceSlots;
  }

  gsl::span<const T> getSliceY(uint32_t binX) const
  {
    uint32_t offs = binX * getNBinsY();
    return binX < getNBinsX() ? gsl::span<const T>(&mDataPtr[offs], getNBinsY()) : gsl::span<const T>();
  }

  std::unique_ptr<TH2F> createTH2F(const std::string& name = "histo2d") const;

  std::unique_ptr<TH1F> createSliceXTH1F(uint32_t binY, const std::string& name = "histo2dsliceX") const;
  std::unique_ptr<TH1F> createSliceYTH1F(uint32_t binX, const std::string& name = "histo2dsliceY") const;

  const std::vector<T>& getBase() const { return mContainer; }
  gsl::span<const T> getView() const { return mContainerView; }

  uint32_t getGlobalBin(uint32_t binX, uint32_t binY) const { return binX * getNBinsY() + binY; }

 protected:
  void init(const gsl::span<const T> ext);

  std::vector<T> mContainer;         // data to fill
  gsl::span<const T> mContainerView; //!
  T* mDataPtr{};                     //!   histo data
  T mXMin{};                         //!
  T mXMax{};                         //!
  T mYMin{};                         //!
  T mYMax{};                         //!
  T mBinSizeX{};                     //!
  T mBinSizeY{};                     //!
  T mBinSizeXInv{};                  //!
  T mBinSizeYInv{};                  //!
  uint32_t mNBinsX{};                //!
  uint32_t mNBinsY{};                //!
  uint32_t mNBins{};                 //!

  ClassDefNV(FlatHisto2D, 2);
};

using FlatHisto2D_f = FlatHisto2D<float>;
using FlatHisto2D_d = FlatHisto2D<double>;

} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_TFIDINFO_H
#define ALICEO2_TFIDINFO_H

#include <Rtypes.h>

namespace o2
{
namespace framework
{
class ProcessingContext;
}
namespace dataformats
{
struct TFIDInfo { // helper info to patch DataHeader

  uint32_t firstTForbit = -1U;
  uint32_t tfCounter = -1U;
  uint32_t runNumber = -1U;
  uint32_t startTime = -1U; // same as timeslot
  uint64_t creation = -1UL;

  bool isDummy() { return tfCounter == -1U; }
  void fill(uint32_t firstTForbit_, uint32_t tfCounter_, uint32_t runNumber_, uint32_t startTime_, uint64_t creation_)
  {
    firstTForbit = firstTForbit_;
    tfCounter = tfCounter_;
    runNumber = runNumber_;
    startTime = startTime_;
    creation = creation_;
  }

  ClassDefNV(TFIDInfo, 2);
};
} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_COMMON_PAIR_H
#define ALICEO2_COMMON_PAIR_H

#include "GPUCommonRtypes.h"

namespace o2
{
namespace dataformats
{
// A messageable pair
template <typename F, typename S>
struct Pair {
  Pair() = default;
  Pair(F f, S s) : first(f), second(s) {}
  F first{};
  S second{};
  ClassDefNV(Pair, 1);
};

} // namespace dataformats
} // namespace o2

#endif /* ALICEO2_COMMON_PAIR_H */
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/********************************************************************************
 *    Copyright (C) 2014 GSI Helmholtzzentrum fuer Schwerionenforschung GmbH    *
 *                                                                              *
 *              This software is distributed under the terms of the             *
 *         GNU Lesser General Public Licence version 3 (LGPL) version 3,        *
 *                  copied verbatim in the file "LICENSE"                       *
 ********************************************************************************/

#ifdef __CLING__

#pragma link off all globals;
#pragma link off all classes;
#pragma link off all functions;

#pragma link C++ class o2::dataformats::TimeStamp < float> + ;
#pragma link C++ class o2::dataformats::TimeStamp < double> + ;
#pragma link C++ class o2::dataformats::TimeStamp < int> + ;
#pragma link C++ class o2::dataformats::TimeStamp < Float16_t > + ;
#pragma link C++ class o2::dataformats::TimeStampWithError < float, float> + ;
#pragma link C++ class o2::dataformats::TimeStampWithError < double, double> + ;
#pragma link C++ class o2::dataformats::TimeStampWithError < int, int> + ;

#pragma link C++ class o2::dataformats::EvIndex < int, int> + ;
#pragma link C++ class o2::dataformats::RangeReference < int, int> + ;
#pragma link C++ class o2::dataformats::RangeReference < uint32_t, uint16_t> + ;
#pragma link C++ class o2::dataformats::RangeReference < o2::dataformats::EvIndex < int, int>, int> + ;

#pragma link C++ class o2::dataformats::RangeRefComp < 4> + ; // reference to a set with 15 entries max (ITS clusters)
#pragma link C++ class o2::dataformats::RangeRefComp < 5> + ; // reference to a set with 15 entries max (ZDC BCData)
#pragma link C++ class o2::dataformats::RangeRefComp < 6> + ; // reference to a set with 63 entries max (FV0 Digit)

#pragma link C++ class o2::dataformats::RangeRefComp < 8> + ; //

#pragma link C++ class std::vector < o2::dataformats::RangeReference < int, int>> + ;

#pragma link C++ class o2::dataformats::AbstractRef < 25, 5, 2> + ;

#pragma link C++ class o2::InteractionRecord + ;
#pragma link C++ class o2::InteractionTimeRecord + ;
#pragma link C++ class o2::BunchFilling + ;
#pragma link C++ class std::pair < long, o2::BunchFilling> + ;

#pragma link C++ class o2::math_utils::detail::Bracket < o2::InteractionRecord> + ;
#pragma link C++ class o2::dataformats::IRFrame + ;
#pragma link C++ class std::vector < o2::dataformats::IRFrame> + ;

#pragma link C++ class o2::dataformats::FlatHisto1D < float> + ;
#pragma link C++ class o2::dataformats::FlatHisto1D < double> + ;
#pragma link C++ class o2::dataformats::FlatHisto1D_f + ;
#pragma link C++ class o2::dataformats::FlatHisto1D_d + ;

#pragma link C++ class o2::dataformats::FlatHisto2D < float> + ;
#pragma link C++ class o2::dataformats::FlatHisto2D < double> + ;
#pragma link C++ class o2::dataformats::FlatHisto2D_f + ;
#pragma link C++ class o2::dataformats::FlatHisto2D_d + ;

#pragma link C++ class o2::dataformats::Pair < float, float> + ;
#pragma link C++ class std::vector < o2::dataformats::Pair < float, float>> + ;

#include "CommonDataFormat/TFIDInfo.h"
#pragma link C++ class o2::dataformats::TFIDInfo + ;
#pragma link C++ class std::vector < o2::dataformats::TFIDInfo> + ;

#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from G__O2ReconstructionDataFormats dictionary payload:450:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ReconstructionDataFormats/GlobalTrackID.h:90:79: error: invalid operands to binary expression ('o2::gpu::gpustd::bitset<32>' and 'DetID::mask_t' (aka 'bitset<32>'))
  GPUdi() bool includesDet(DetID id) const { return (getSourceDetectorsMask() & DetID::getMask(id)).any(); }
                                                     ~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/ios_base.h:83:3: note: candidate function not viable: no known conversion from 'o2::gpu::gpustd::bitset<32>' to 'std::_Ios_Fmtflags' for 1st argument
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/ios_base.h:125:3: note: candidate function not viable: no known conversion from 'o2::gpu::gpustd::bitset<32>' to 'std::_Ios_Openmode' for 1st argument
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/ios_base.h:165:3: note: candidate function not viable: no known conversion from 'o2::gpu::gpustd::bitset<32>' to 'std::_Ios_Iostate' for 1st argument
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/cstddef:138:3: note: candidate function not viable: no known conversion from 'o2::gpu::gpustd::bitset<32>' to 'std::byte' for 1st argument
  operator&(byte __l, byte __r) noexcept
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/atomic_base.h:100:3: note: candidate function not viable: no known conversion from 'o2::gpu::gpustd::bitset<32>' to 'std::memory_order' for 1st argument
  operator&(memory_order __m, __memory_order_modifier __mod)
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/future:143:20: note: candidate function not viable: no known conversion from 'o2::gpu::gpustd::bitset<32>' to 'std::launch' for 1st argument
  constexpr launch operator&(launch __x, launch __y)
                   ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBits.h:148:15: note: candidate function not viable: no known conversion from 'o2::gpu::gpustd::bitset<32>' to 'const TBits::TReference' for 1st argument
inline Bool_t operator&(const TBits::TReference& lhs, const TBits::TReference& rhs)
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBits.h:163:14: note: candidate function not viable: no known conversion from 'o2::gpu::gpustd::bitset<32>' to 'const TBits' for 1st argument
inline TBits operator&(const TBits& lhs, const TBits& rhs)
             ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bitset:1435:5: note: candidate template ignored: could not match 'std::bitset' against 'o2::gpu::gpustd::bitset'
    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) _GLIBCXX_NOEXCEPT
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:411:5: note: candidate template ignored: could not match '_Expr' against 'bitset'
    _DEFINE_EXPR_BINARY_OPERATOR(&, __bitwise_and)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:344:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const _Expr<_Dom1, typename _Dom1::value_type>& __v,   \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:411:5: note: candidate template ignored: could not match '_Expr' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:357:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const _Expr<_Dom, typename _Dom::value_type>& __v,     \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:411:5: note: candidate template ignored: could not match '_Expr' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:370:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const typename _Dom::value_type& __t,                  \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:411:5: note: candidate template ignored: could not match '_Expr' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:383:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const _Expr<_Dom,typename _Dom::value_type>& __e,      \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:411:5: note: candidate template ignored: could not match '_Expr' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:396:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const valarray<typename _Dom::value_type>& __v,        \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1191:1: note: candidate template ignored: could not match 'valarray' against 'bitset'
_DEFINE_BINARY_OPERATOR(&, __bitwise_and)
^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1155:5: note: expanded from macro '_DEFINE_BINARY_OPERATOR'
    operator _Op(const valarray<_Tp>& __v, const valarray<_Tp>& __w)    \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1191:1: note: candidate template ignored: could not match 'valarray' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1166:5: note: expanded from macro '_DEFINE_BINARY_OPERATOR'
    operator _Op(const valarray<_Tp>& __v,                              \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1191:1: note: candidate template ignored: could not match 'valarray' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1177:5: note: expanded from macro '_DEFINE_BINARY_OPERATOR'
    operator _Op(const typename valarray<_Tp>::value_type& __t,         \
    ^
In file included from G__O2ReconstructionDataFormats dictionary payload:450:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ReconstructionDataFormats/GlobalTrackID.h:188:63: error: invalid operands to binary expression ('GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') and 'o2::detectors::DetID::mask_t' (aka 'bitset<32>'))
    if (includesSource(i, srcm) && (getSourceDetectorsMask(i) & id.getMask()).any()) {
                                    ~~~~~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/ios_base.h:83:3: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'std::_Ios_Fmtflags' for 1st argument
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/ios_base.h:125:3: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'std::_Ios_Openmode' for 1st argument
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/ios_base.h:165:3: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'std::_Ios_Iostate' for 1st argument
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/cstddef:138:3: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'std::byte' for 1st argument
  operator&(byte __l, byte __r) noexcept
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/atomic_base.h:100:3: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'std::memory_order' for 1st argument
  operator&(memory_order __m, __memory_order_modifier __mod)
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/future:143:20: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'std::launch' for 1st argument
  constexpr launch operator&(launch __x, launch __y)
                   ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBits.h:148:15: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'const TBits::TReference' for 1st argument
inline Bool_t operator&(const TBits::TReference& lhs, const TBits::TReference& rhs)
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBits.h:163:14: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'const TBits' for 1st argument
inline TBits operator&(const TBits& lhs, const TBits& rhs)
             ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bitset:1435:5: note: candidate template ignored: could not match 'std::bitset' against 'o2::gpu::gpustd::bitset'
    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y) _GLIBCXX_NOEXCEPT
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:411:5: note: candidate template ignored: could not match '_Expr' against 'bitset'
    _DEFINE_EXPR_BINARY_OPERATOR(&, __bitwise_and)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:344:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const _Expr<_Dom1, typename _Dom1::value_type>& __v,   \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:411:5: note: candidate template ignored: could not match '_Expr' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:357:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const _Expr<_Dom, typename _Dom::value_type>& __v,     \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:411:5: note: candidate template ignored: could not match '_Expr' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:370:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const typename _Dom::value_type& __t,                  \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:411:5: note: candidate template ignored: could not match '_Expr' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:383:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const _Expr<_Dom,typename _Dom::value_type>& __e,      \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:411:5: note: candidate template ignored: could not match '_Expr' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/valarray_after.h:396:5: note: expanded from macro '_DEFINE_EXPR_BINARY_OPERATOR'
    operator _Op(const valarray<typename _Dom::value_type>& __v,        \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1191:1: note: candidate template ignored: could not match 'valarray' against 'bitset'
_DEFINE_BINARY_OPERATOR(&, __bitwise_and)
^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1155:5: note: expanded from macro '_DEFINE_BINARY_OPERATOR'
    operator _Op(const valarray<_Tp>& __v, const valarray<_Tp>& __w)    \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1191:1: note: candidate template ignored: could not match 'valarray' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1166:5: note: expanded from macro '_DEFINE_BINARY_OPERATOR'
    operator _Op(const valarray<_Tp>& __v,                              \
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1191:1: note: candidate template ignored: could not match 'valarray' against 'bitset'
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/valarray:1177:5: note: expanded from macro '_DEFINE_BINARY_OPERATOR'
    operator _Op(const typename valarray<_Tp>::value_type& __t,         \
    ^
In file included from G__O2ReconstructionDataFormats dictionary payload:450:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/ReconstructionDataFormats/GlobalTrackID.h:200:12: error: no viable overloaded '|='
      mdet |= getSourceDetectorsMask(i);
      ~~~~ ^  ~~~~~~~~~~~~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/ios_base.h:99:3: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'std::_Ios_Fmtflags &' for 1st argument
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/ios_base.h:141:3: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'std::_Ios_Openmode &' for 1st argument
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/ios_base.h:181:3: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'std::_Ios_Iostate &' for 1st argument
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/cstddef:160:3: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'std::byte &' for 1st argument
  operator|=(byte& __l, byte __r) noexcept
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/future:167:18: note: candidate function not viable: no known conversion from 'GlobalTrackID::DetID::mask_t' (aka 'bitset<32>') to 'std::launch &' for 1st argument
  inline launch& operator|=(launch& __x, launch __y)
                 ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/type_traits:139:31: error: no member named 'value' in 'std::__is_convertible_to_basic_ostream<fair::Logger>'
    : public conditional<_B1::value, _B2, _B1>::type
                         ~~~~~^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/type_traits:144:14: note: in instantiation of template class 'std::__and_<std::__is_convertible_to_basic_ostream<fair::Logger>, std::__is_insertable<void, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > &, void> >' requested here
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
             ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:767:24: note: in instantiation of template class 'std::__and_<std::__not_<std::is_lvalue_reference<fair::Logger> >, std::__is_convertible_to_basic_ostream<fair::Logger>, std::__is_insertable<void, const std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > &, void> >' requested here
    typename enable_if<__and_<__not_<is_lvalue_reference<_Ostream>>,
                       ^
G__O2ReconstructionDataFormats dictionary payload:2232:5: note: while substituting deduced template arguments into function template 'operator<<' [with _Ostream = fair::Logger, _Tp = std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >]
    LOGF(debug, "Number of BCs not in range of compatible BCs: %i", nNotCompBCs);
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:398:14: note: expanded from macro 'LOGF'
#define LOGF FAIR_LOGF
             ^
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:435:48: note: expanded from macro 'FAIR_LOGF'
#define FAIR_LOGF(severity, ...) LOG(severity) << fmt::sprintf(__VA_ARGS__)
                                               ^
Error in <TInterpreter::AutoParse>: Error parsing payload code for class o2::dataformats::Vertex with content:

#line 1 "G__O2ReconstructionDataFormats dictionary payload"

#ifndef ZDC_FASTSIM_ONNX
  #define ZDC_FASTSIM_ONNX 1
#endif
#ifndef ENABLE_UPGRADES
  #define ENABLE_UPGRADES 1
#endif
#ifndef FMT_LOCALE
  #define FMT_LOCALE 1
#endif
#ifndef FMT_SHARED
  #define FMT_SHARED 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef FAIRMQ_HAS_STD_FILESYSTEM
  #define FAIRMQ_HAS_STD_FILESYSTEM 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_CONTAINER_DYN_LINK
  #define BOOST_CONTAINER_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_PROGRAM_OPTIONS_DYN_LINK
  #define BOOST_PROGRAM_OPTIONS_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_FILESYSTEM_DYN_LINK
  #define BOOST_FILESYSTEM_DYN_LINK 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_REGEX_DYN_LINK
  #define BOOST_REGEX_DYN_LINK 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef BOOST_ERROR_CODE_HEADER_ONLY
  #define BOOST_ERROR_CODE_HEADER_ONLY 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_IOSTREAMS_DYN_LINK
  #define BOOST_IOSTREAMS_DYN_LINK 1
#endif
#ifndef DPL_ENABLE_BACKTRACE
  #define DPL_ENABLE_BACKTRACE 1
#endif
#ifndef BOOST_ALL_NO_LIB
  #define BOOST_ALL_NO_LIB 1
#endif
#ifndef BOOST_SERIALIZATION_DYN_LINK
  #define BOOST_SERIALIZATION_DYN_LINK 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Track.h
/// \brief Base track model for the Barrel, params only, w/o covariance
/// \author ruben.shahoyan@cern.ch, michael.lettrich@cern.ch

#ifndef ALICEO2_BASE_TRACK
#define ALICEO2_BASE_TRACK

#include "ReconstructionDataFormats/TrackParametrization.h"
#include "ReconstructionDataFormats/TrackParametrizationWithError.h"

namespace o2
{
namespace track
{

using TrackParF = TrackParametrization<float>;
using TrackParD = TrackParametrization<double>;
using TrackPar = TrackParF;

using TrackParCovF = TrackParametrizationWithError<float>;
using TrackParCovD = TrackParametrizationWithError<double>;
using TrackParCov = TrackParCovF;

} // namespace track
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file TrackFwd.h
/// \brief Base forward track model, params only, w/o covariance
///
/// \author Philippe Pillot, Subatech; adapted by Rafael Pezzi, UFRGS

#ifndef ALICEO2_BASE_TRACKFWD
#define ALICEO2_BASE_TRACKFWD

#include <Rtypes.h>
#include <TMath.h>
#include "Math/SMatrix.h"
#include "MathUtils/Utils.h"
#include "ReconstructionDataFormats/TrackUtils.h"
#include "MathUtils/Primitive2D.h"

namespace o2::track
{

using SMatrix55Sym = ROOT::Math::SMatrix<double, 5, 5, ROOT::Math::MatRepSym<double, 5>>;
using SMatrix55Std = ROOT::Math::SMatrix<double, 5>;
using SMatrix5 = ROOT::Math::SVector<Double_t, 5>;

class TrackParFwd
{ // Forward track parameterization, kinematics only.
 public:
  TrackParFwd() = default;
  ~TrackParFwd() = default;

  TrackParFwd(const TrackParFwd& tp) = default;
  TrackParFwd& operator=(const TrackParFwd& tp) = default;
  TrackParFwd(TrackParFwd&&) = delete;
  TrackParFwd& operator=(TrackParFwd&&) = delete;

  /// return Z coordinate (cm)
  Double_t getZ() const { return mZ; }
  /// set Z coordinate (cm)
  void setZ(Double_t z) { mZ = z; }
  Double_t getX() const { return mParameters(0); }
  void setX(Double_t x) { mParameters(0) = x; }

  Double_t getY() const { return mParameters(1); }
  void setY(Double_t y) { mParameters(1) = y; }

  void setPhi(Double_t phi) { mParameters(2) = phi; }
  Double_t getPhi() const { return mParameters(2); }

  Double_t getSnp() const
  {
    return o2::math_utils::sin(mParameters(2));
  }

  Double_t getCsp2() const
  {
    auto snp = o2::math_utils::sin(mParameters(2));
    Double_t csp;
    csp = std::sqrt((1. - snp) * (1. + snp));
    return csp * csp;
  }

  void setTanl(Double_t tanl) { mParameters(3) = tanl; }
  Double_t getTanl() const { return mParameters(3); }

  Double_t getTgl() const { return mParameters(3); } // for the sake of helixhelper

  void setInvQPt(Double_t invqpt) { mParameters(4) = invqpt; }
  Double_t getInvQPt() const { return mParameters(4); } // return Inverse charged pt
  Double_t getPt() const { return TMath::Abs(1.f / mParameters(4)); }
  Double_t getInvPt() const { return TMath::Abs(mParameters(4)); }
  Double_t getPx() const { return TMath::Cos(getPhi()) * getPt(); }                   // return px
  Double_t getPy() const { return TMath::Sin(getPhi()) * getPt(); }                   // return py
  Double_t getPz() const { return getTanl() * getPt(); }                              // return pz
  Double_t getP() const { return getPt() * TMath::Sqrt(1. + getTanl() * getTanl()); } // return total momentum
  Double_t getInverseMomentum() const { return 1.f / getP(); }

  Double_t getTheta() const { return TMath::PiOver2() - TMath::ATan(getTanl()); }
  Double_t getEta() const { return -TMath::Log(TMath::Tan(getTheta() / 2)); } // return total momentum

  Double_t getCurvature(double b) const
  {
    auto invqpt = getInvQPt();
    return o2::constants::math::B2C * b * invqpt;
  }

  /// return the charge (assumed forward motion)
  Double_t getCharge() const { return TMath::Sign(1., mParameters(4)); }
  /// set the charge (assumed forward motion)
  void setCharge(Double_t charge)
  {
    if (charge * mParameters(4) < 0.) {
      mParameters(4) *= -1.;
    }
  }

  /// return track parameters
  const SMatrix5& getParameters() const { return mParameters; }
  /// set track parameters
  void setParameters(const SMatrix5& parameters) { mParameters = parameters; }
  /// add track parameters
  void addParameters(const SMatrix5& parameters) { mParameters += parameters; }

  /// return the chi2 of the track when the associated cluster was attached
  Double_t getTrackChi2() const { return mTrackChi2; }
  /// set the chi2 of the track when the associated cluster was attached
  void setTrackChi2(Double_t chi2) { mTrackChi2 = chi2; }

  // Track parameter propagation
  void propagateParamToZlinear(double zEnd);
  void propagateParamToZquadratic(double zEnd, double zField);
  void propagateParamToZhelix(double zEnd, double zField);
  void getCircleParams(float bz, o2::math_utils::CircleXY<float>& c, float& sna, float& csa) const;

 protected:
  Double_t mZ = 0.; ///< Z coordinate (cm)

  /// Track parameters ordered as follow:      <pre>
  /// X       = X coordinate   (cm)
  /// Y       = Y coordinate   (cm)
  /// PHI     = azimutal angle
  /// TANL    = tangent of \lambda (dip angle)
  /// INVQPT    = Inverse transverse momentum (GeV/c ** -1) times charge (assumed forward motion)  </pre>
  SMatrix5 mParameters{};   ///< \brief Track parameters
  Double_t mTrackChi2 = 0.; ///< Chi2 of the track when the associated cluster was attached

  ClassDefNV(TrackParFwd, 1);
};

class TrackParCovFwd : public TrackParFwd
{ // Forward track+error parameterization
 public:
  using TrackParFwd::TrackParFwd; // inherit base constructors

  TrackParCovFwd() = default;
  ~TrackParCovFwd() = default;
  TrackParCovFwd& operator=(const TrackParCovFwd& tpf) = default;
  TrackParCovFwd(const Double_t z, const SMatrix5& parameters, const SMatrix55Sym& covariances, const Double_t chi2);

  const SMatrix55Sym& getCovariances() const { return mCovariances; }
  void setCovariances(const SMatrix55Sym& covariances) { mCovariances = covariances; }
  void deleteCovariances() { mCovariances = SMatrix55Sym(); }

  Double_t getSigma2X() const { return mCovariances(0, 0); }
  Double_t getSigma2Y() const { return mCovariances(1, 1); }
  Double_t getSigmaXY() const { return mCovariances(0, 1); }
  Double_t getSigma2Phi() const { return mCovariances(2, 2); }
  Double_t getSigma2Tanl() const { return mCovariances(3, 3); }
  Double_t getSigma2InvQPt() const { return mCovariances(4, 4); }

  // Propagate parameters and covariances matrix
  void propagateToZlinear(double zEnd);
  void propagateToZquadratic(double zEnd, double zField);
  void propagateToZhelix(double zEnd, double zField);
  void propagateToZ(double zEnd, double zField); // Parameters: helix; errors: quadratic

  // Add Multiple Coulomb Scattering effects
  void addMCSEffect(double x2X0);

  // Kalman filter/fitting
  bool update(const std::array<float, 2>& p, const std::array<float, 2>& cov);

 private:
  /// Covariance matrix of track parameters, ordered as follows:    <pre>
  ///  <X,X>         <Y,X>           <PHI,X>       <TANL,X>        <INVQPT,X>
  ///  <X,Y>         <Y,Y>           <PHI,Y>       <TANL,Y>        <INVQPT,Y>
  /// <X,PHI>       <Y,PHI>         <PHI,PHI>     <TANL,PHI>      <INVQPT,PHI>
  /// <X,TANL>      <Y,TANL>       <PHI,TANL>     <TANL,TANL>     <INVQPT,TANL>
  /// <X,INVQPT>   <Y,INVQPT>     <PHI,INVQPT>   <TANL,INVQPT>   <INVQPT,INVQPT>  </pre>
  SMatrix55Sym mCovariances{}; ///< \brief Covariance matrix of track parameters
  ClassDefNV(TrackParCovFwd, 1);
};

} // namespace o2::track

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_BASE_BASECLUSTER_H
#define ALICEO2_BASE_BASECLUSTER_H

#include <MathUtils/Cartesian.h>
#include "GPUCommonRtypes.h"
#ifndef GPUCA_GPUCODE
#include "DetectorsCommonDataFormats/DetMatrixCache.h"
#include <bitset>
#include <iomanip>
#include <ios>
#include <iosfwd>
#endif

namespace o2
{
// Basic cluster class with X,Y,Z position detector ID information + user fields
// The position is ALWAYS stored in tracking frame and is misaligned (in opposite
// to AliRoot). The errors are defined in *ideal* tracking frame
// DetectorID should correspond to continuous (no jumps between detector layers
// planes etc.) internal sensor ID within detector
template <typename T>
class BaseCluster
{
 private:
  math_utils::Point3D<T> mPos; // cartesian position
  T mSigmaY2;                  // error in Y direction (usually rphi)
  T mSigmaZ2;                  // error in Z direction (usually Z)
  T mSigmaYZ;                  // non-diagonal term of error matrix
  std::uint16_t mSensorID = 0; // the sensor id
  std::int8_t mCount = 0;      // user field reserved for counting
  std::uint8_t mBits = 0;      // user field reserved for bit flags
  enum masks_t : std::int32_t { kUserBitsMask = 0xff };

 public:
  BaseCluster() = default;
  ~BaseCluster() = default;

  // constructor
  BaseCluster(std::uint16_t sensid, const math_utils::Point3D<T>& xyz) : mPos(xyz), mSensorID(sensid) {}
  BaseCluster(std::uint16_t sensid, T x, T y, T z) : mPos(x, y, z), mSensorID(sensid) {}
  BaseCluster(std::uint16_t sensid, const math_utils::Point3D<T>& xyz, T sy2, T sz2, T syz)
    : mPos(xyz), mSigmaY2(sy2), mSigmaZ2(sz2), mSigmaYZ(syz), mSensorID(sensid)
  {
  }
  BaseCluster(std::int16_t sensid, T x, T y, T z, T sy2, T sz2, T syz)
    : mPos(x, y, z), mSigmaY2(sy2), mSigmaZ2(sz2), mSigmaYZ(syz), mSensorID(sensid)
  {
  }

  // getting the cartesian coordinates and errors
  T getX() const { return mPos.X(); }
  T getY() const { return mPos.Y(); }
  T getZ() const { return mPos.Z(); }
  T getSigmaY2() const { return mSigmaY2; }
  T getSigmaZ2() const { return mSigmaZ2; }
  T getSigmaYZ() const { return mSigmaYZ; }
  math_utils::Point3D<T> getXYZ() const { return mPos; }
  math_utils::Point3D<T>& getXYZ() { return mPos; }
#ifndef GPUCA_GPUCODE
  // position in local frame, no check for matrices cache validity
  math_utils::Point3D<T> getXYZLoc(const o2::detectors::DetMatrixCache& dm) const { return dm.getMatrixT2L(mSensorID)(mPos); }
  // position in global frame, no check for matrices cache validity
  math_utils::Point3D<T> getXYZGlo(const o2::detectors::DetMatrixCache& dm) const { return dm.getMatrixT2G(mSensorID)(mPos); }
  // position in global frame obtained as simple rotation from tracking one:
  // much faster for barrel detectors than using full 3D matrix.
  // no check for matrices cache validity
  math_utils::Point3D<T> getXYZGloRot(const o2::detectors::DetMatrixCache& dm) const { return dm.getMatrixT2GRot(mSensorID)(mPos); }
#endif
  // get sensor id
  std::int16_t getSensorID() const { return mSensorID; }
  // get count field
  std::int8_t getCount() const { return mCount; }
  // get bit field
  std::uint8_t getBits() const { return mBits; }
  bool isBitSet(int bit) const { return mBits & (0xff & (0x1 << bit)); }
  // cast to Point3D
  operator math_utils::Point3D<T>&() { return mPos; }
  // modifiers

  // set sensor id
  void setSensorID(std::int16_t sid) { mSensorID = sid; }
  // set count field
  void setCount(std::int8_t c) { mCount = c; }
  // set bit field
  void setBits(std::uint8_t b) { mBits = b; }
  void setBit(int bit) { mBits |= kUserBitsMask & (0x1 << bit); }
  void resetBit(int bit) { mBits &= ~(kUserBitsMask & (0x1 << bit)); }
  // set position and errors
  void setX(T x) { mPos.SetX(x); }
  void setY(T y) { mPos.SetY(y); }
  void setZ(T z) { mPos.SetZ(z); }
  void setXYZ(T x, T y, T z)
  {
    setX(x);
    setY(y);
    setZ(z);
  }
  void setPos(const math_utils::Point3D<T>& p) { mPos = p; }
  void setSigmaY2(T v) { mSigmaY2 = v; }
  void setSigmaZ2(T v) { mSigmaZ2 = v; }
  void setSigmaYZ(T v) { mSigmaYZ = v; }
  void setErrors(T sy2, T sz2, T syz)
  {
    setSigmaY2(sy2);
    setSigmaZ2(sz2);
    setSigmaYZ(syz);
  }

 protected:
  ClassDefNV(BaseCluster, 2);
};

#ifndef GPUCA_GPUCODE
template <class T>
std::ostream& operator<<(std::ostream& os, const BaseCluster<T>& c)
{
  // stream itself
  os << "SId" << std::setw(5) << c.getSensorID() << " (" << std::showpos << std::scientific
     << c.getX() << "," << c.getY() << "," << c.getZ() << ")/("
     << c.getSigmaY2() << "," << c.getSigmaYZ() << "," << c.getSigmaZ2()
     << ") cnt:" << std::setw(4) << +c.getCount() << " bits:" << std::bitset<8>(c.getBits());
  return os;
}
#endif
} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file TrackTPCITS.h
/// \brief Result of refitting TPC-ITS matched track
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_TRACKTPCITS_H
#define ALICEO2_TRACKTPCITS_H

#include "ReconstructionDataFormats/Track.h"
#include "ReconstructionDataFormats/TrackLTIntegral.h"
#include "ReconstructionDataFormats/GlobalTrackID.h"
#include "CommonDataFormat/TimeStamp.h"

namespace o2
{
namespace dataformats
{

class TrackTPCITS : public o2::track::TrackParCov
{
  using timeEst = o2::dataformats::TimeStampWithError<float, float>;

 public:
  GPUdDefault() TrackTPCITS() = default;
  GPUdDefault() ~TrackTPCITS() = default;
  GPUdDefault() TrackTPCITS(const TrackTPCITS& src) = default;
  GPUd() TrackTPCITS(const o2::track::TrackParCov& src) : o2::track::TrackParCov(src) {}
  GPUd() TrackTPCITS(const o2::track::TrackParCov& srcIn, const o2::track::TrackParCov& srcOut) : o2::track::TrackParCov(srcIn), mParamOut(srcOut) {}

  GPUd() GlobalTrackID getRefTPC() const { return mRefTPC; }
  GPUd() GlobalTrackID getRefITS() const { return mRefITS; }
  GPUd() void setRefTPC(GlobalTrackID id) { mRefTPC = id; }
  GPUd() void setRefITS(GlobalTrackID id) { mRefITS = id; }

  GPUd() const timeEst& getTimeMUS() const { return mTimeMUS; }
  GPUd() timeEst& getTimeMUS() { return mTimeMUS; }
  GPUd() void setTimeMUS(const timeEst& t) { mTimeMUS = t; }
  GPUd() void setTimeMUS(float t, float te)
  {
    mTimeMUS.setTimeStamp(t);
    mTimeMUS.setTimeStampError(te);
  }

  GPUd() void setChi2Refit(float v) { mChi2Refit = v; }
  GPUd() float getChi2Refit() const { return mChi2Refit; }

  GPUd() void setChi2Match(float v) { mChi2Match = v; }
  GPUd() float getChi2Match() const { return mChi2Match; }

  GPUd() o2::track::TrackParCov& getParamOut() { return mParamOut; }
  GPUd() const o2::track::TrackParCov& getParamOut() const { return mParamOut; }

  GPUd() o2::track::TrackLTIntegral& getLTIntegralOut() { return mLTOut; }
  GPUd() const o2::track::TrackLTIntegral& getLTIntegralOut() const { return mLTOut; }

  void print() const;

 private:
  GlobalTrackID mRefTPC;             ///< reference on ITS track entry in its original container
  GlobalTrackID mRefITS;             ///< reference on TPC track entry in its original container
  float mChi2Refit = 0.f;            ///< chi2 of the refit
  float mChi2Match = 0.f;            ///< chi2 of the match
  timeEst mTimeMUS;                  ///< time estimate in ns
  o2::track::TrackParCov mParamOut;  ///< refitted outer parameter
  o2::track::TrackLTIntegral mLTOut; ///< L,TOF integral calculated during the outward refit
  ClassDefNV(TrackTPCITS, 3);
};
} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file GlobalFwdTrack.h
/// \brief Global Forward Muon tracks

#ifndef ALICEO2_TRACKGLOBALFWD_H
#define ALICEO2_TRACKGLOBALFWD_H

#include "ReconstructionDataFormats/TrackFwd.h"
#include "ReconstructionDataFormats/MatchInfoFwd.h"
#include "Math/SMatrix.h"

namespace o2
{
namespace dataformats
{
using SMatrix5 = ROOT::Math::SVector<Double_t, 5>;
using SMatrix55Sym = ROOT::Math::SMatrix<double, 5, 5, ROOT::Math::MatRepSym<double, 5>>;

class GlobalFwdTrack : public o2::track::TrackParCovFwd, public o2::dataformats::MatchInfoFwd
{
 public:
  GlobalFwdTrack() = default;
  GlobalFwdTrack(const GlobalFwdTrack& t) = default;
  ~GlobalFwdTrack() = default;

  SMatrix5 computeResiduals2Cov(const o2::track::TrackParCovFwd& t) const
  {
    SMatrix5 Residuals2Cov;

    Residuals2Cov(0) = (getX() - t.getX()) / TMath::Sqrt(getCovariances()(0, 0) + t.getCovariances()(0, 0));
    Residuals2Cov(1) = (getY() - t.getY()) / TMath::Sqrt(getCovariances()(1, 1) + t.getCovariances()(1, 1));
    Residuals2Cov(2) = (getPhi() - t.getPhi()) / TMath::Sqrt(getCovariances()(2, 2) + t.getCovariances()(2, 2));
    Residuals2Cov(3) = (getTanl() - t.getTanl()) / TMath::Sqrt(getCovariances()(3, 3) + t.getCovariances()(3, 3));
    Residuals2Cov(4) = (getInvQPt() - t.getInvQPt()) / TMath::Sqrt(getCovariances()(4, 4) + t.getCovariances()(4, 4));
    return Residuals2Cov;
  }

 private:
  ClassDefNV(GlobalFwdTrack, 2);
};

} // namespace dataformats

namespace framework
{
template <typename T>
struct is_messageable;
template <>
struct is_messageable<o2::dataformats::GlobalFwdTrack> : std::true_type {
};
} // namespace framework

} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_VERTEX_H
#define ALICEO2_VERTEX_H

#include "GPUCommonDef.h"
#include "GPUCommonMath.h"
#include "GPUCommonArray.h"
#include <MathUtils/Cartesian.h>

#include "CommonDataFormat/TimeStamp.h"
#ifndef GPUCA_GPUCODE_DEVICE
#include <iosfwd>
#include <string>
#include <type_traits>
#endif

namespace o2
{
namespace dataformats
{

// Base primary vertex class, with position, error
class VertexBase
{
 public:
  enum CovElems : int { kCovXX,
                        kCovXY,
                        kCovYY,
                        kCovXZ,
                        kCovYZ,
                        kCovZZ };
  static constexpr int kNCov = 6;
  GPUhdDefault() VertexBase() = default;
  GPUhdDefault() ~VertexBase() = default;
  GPUhd() VertexBase(const math_utils::Point3D<float>& pos, const gpu::gpustd::array<float, kNCov>& cov) : mPos(pos), mCov(cov)
  {
  }

#if !defined(GPUCA_NO_FMT) && !defined(GPUCA_GPUCODE_DEVICE)
  void print() const;
  std::string asString() const;
#endif

  // getting the cartesian coordinates and errors
  GPUhd() float getX() const { return mPos.X(); }
  GPUhd() float getY() const { return mPos.Y(); }
  GPUhd() float getZ() const { return mPos.Z(); }
  GPUd() float getSigmaX2() const { return mCov[kCovXX]; }
  GPUd() float getSigmaY2() const { return mCov[kCovYY]; }
  GPUd() float getSigmaZ2() const { return mCov[kCovZZ]; }
  GPUd() float getSigmaXY() const { return mCov[kCovXY]; }
  GPUd() float getSigmaXZ() const { return mCov[kCovXZ]; }
  GPUd() float getSigmaYZ() const { return mCov[kCovYZ]; }
  GPUd() const gpu::gpustd::array<float, kNCov>& getCov() const { return mCov; }

  GPUd() math_utils::Point3D<float> getXYZ() const { return mPos; }
  GPUd() math_utils::Point3D<float>& getXYZ() { return mPos; }

  GPUd() void setX(float x) { mPos.SetX(x); }
  GPUd() void setY(float y) { mPos.SetY(y); }
  GPUd() void setZ(float z) { mPos.SetZ(z); }

  GPUd() void setXYZ(float x, float y, float z)
  {
    setX(x);
    setY(y);
    setZ(z);
  }
  GPUd() void setPos(const math_utils::Point3D<float>& p) { mPos = p; }

  GPUd() void setSigmaX2(float v) { mCov[kCovXX] = v; }
  GPUd() void setSigmaY2(float v) { mCov[kCovYY] = v; }
  GPUd() void setSigmaZ2(float v) { mCov[kCovZZ] = v; }
  GPUd() void setSigmaXY(float v) { mCov[kCovXY] = v; }
  GPUd() void setSigmaXZ(float v) { mCov[kCovXZ] = v; }
  GPUd() void setSigmaYZ(float v) { mCov[kCovYZ] = v; }
  GPUd() void setCov(float sxx, float sxy, float syy, float sxz, float syz, float szz)
  {
    setSigmaX2(sxx);
    setSigmaY2(syy);
    setSigmaZ2(szz);
    setSigmaXY(sxy);
    setSigmaXZ(sxz);
    setSigmaYZ(syz);
  }
  GPUd() void setCov(const gpu::gpustd::array<float, kNCov>& cov) { mCov = cov; }

  bool operator==(const VertexBase& other) const;
  bool operator!=(const VertexBase& other) const { return !(*this == other); }

 protected:
  math_utils::Point3D<float> mPos{0., 0., 0.}; ///< cartesian position
  gpu::gpustd::array<float, kNCov> mCov{};     ///< errors, see CovElems enum

  ClassDefNV(VertexBase, 1);
};

// Base primary vertex class, with position, error, N candidates and flags field
// The Stamp template parameter allows to define vertex (time)stamp in different
// formats (ITS ROFrame ID, real time + error etc)

template <typename Stamp>
class Vertex : public VertexBase
{
 public:
  using ushort = unsigned short;
  enum Flags : ushort {
    TimeValidated = 0x1 << 0, // Flag that the vertex was validated by external time measurement (e.g. FIT)
    FlagsMask = 0xffff
  };

  GPUhdDefault() Vertex() = default;
  GPUhdDefault() ~Vertex() = default;
  GPUhd() Vertex(const math_utils::Point3D<float>& pos, const gpu::gpustd::array<float, kNCov>& cov, ushort nCont, float chi2)
    : VertexBase(pos, cov), mChi2(chi2), mNContributors(nCont)
  {
  }

  GPUd() ushort getNContributors() const { return mNContributors; }
  GPUd() void setNContributors(ushort v) { mNContributors = v; }
  GPUd() void addContributor() { mNContributors++; }

  GPUd() ushort getFlags() const { return mBits; }
  GPUd() bool isFlagSet(uint f) const { return mBits & (FlagsMask & f); }
  GPUd() void setFlags(ushort f) { mBits |= FlagsMask & f; }
  GPUd() void resetFrags(ushort f = FlagsMask) { mBits &= ~(FlagsMask & f); }

  GPUd() void setChi2(float v) { mChi2 = v; }
  GPUd() float getChi2() const { return mChi2; }

  GPUd() const Stamp& getTimeStamp() const { return mTimeStamp; }
  GPUd() Stamp& getTimeStamp() { return mTimeStamp; }
  GPUd() void setTimeStamp(const Stamp& v) { mTimeStamp = v; }

 protected:
  float mChi2 = 0;           ///< chi2 or quality of tracks to vertex attachment
  ushort mNContributors = 0; ///< N contributors
  ushort mBits = 0;          ///< bit field for flags
  Stamp mTimeStamp;          ///< vertex time-stamp

  ClassDefNV(Vertex, 3);
};

#if !defined(GPUCA_GPUCODE_DEVICE) && !defined(GPUCA_NO_FMT)
std::ostream& operator<<(std::ostream& os, const o2::dataformats::VertexBase& v);
#endif

} // namespace dataformats

#ifndef GPUCA_GPUCODE_DEVICE
/// Defining PrimaryVertex explicitly as messageable
namespace framework
{
template <typename T>
struct is_messageable;
template <>
struct is_messageable<o2::dataformats::VertexBase> : std::true_type {
};
template <>
struct is_messageable<o2::dataformats::Vertex<o2::dataformats::TimeStamp<int>>> : std::true_type {
};
template <>
struct is_messageable<o2::dataformats::Vertex<o2::dataformats::TimeStamp<float>>> : std::true_type {
};
template <>
struct is_messageable<o2::dataformats::Vertex<o2::dataformats::TimeStampWithError<float, float>>> : std::true_type {
};
} // namespace framework
#endif

} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_PRIMARYVERTEX_H
#define ALICEO2_PRIMARYVERTEX_H

#include "CommonDataFormat/InteractionRecord.h"
#include "ReconstructionDataFormats/Vertex.h"

namespace o2
{
namespace dataformats
{

// primary vertex class: position, time with error + IR (by default: not assigned)

class PrimaryVertex : public Vertex<TimeStampWithError<float, float>>
{
 public:
  using Vertex<TimeStampWithError<float, float>>::Vertex;
  PrimaryVertex() = default;
  PrimaryVertex(const PrimaryVertex&) = default;
  ~PrimaryVertex() = default;

  const InteractionRecord& getIRMax() const { return mIRMax; }
  void setIRMax(const InteractionRecord& ir) { mIRMax = ir; }
  const InteractionRecord& getIRMin() const { return mIRMin; }
  void setIRMin(const InteractionRecord& ir) { mIRMin = ir; }
  void setIR(const InteractionRecord& ir) { mIRMin = mIRMax = ir; }
  bool hasUniqueIR() const { return !mIRMin.isDummy() && (mIRMin == mIRMax); }

#ifndef GPUCA_ALIGPUCODE
  void print() const;
  std::string asString() const;
#endif

 protected:
  InteractionRecord mIRMin{}; ///< by default not assigned!
  InteractionRecord mIRMax{}; ///< by default not assigned!

  ClassDefNV(PrimaryVertex, 1);
};

#ifndef GPUCA_ALIGPUCODE
std::ostream& operator<<(std::ostream& os, const o2::dataformats::PrimaryVertex& v);
#endif

} // namespace dataformats

/// Defining PrimaryVertex explicitly as messageable
namespace framework
{
template <typename T>
struct is_messageable;
template <>
struct is_messageable<o2::dataformats::PrimaryVertex> : std::true_type {
};
} // namespace framework

} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file MatchInfoTOF.h
/// \brief Class to store the output of the matching to TOF

#ifndef ALICEO2_MATCHINFOTOF_H
#define ALICEO2_MATCHINFOTOF_H

#include "ReconstructionDataFormats/TrackLTIntegral.h"
#include "ReconstructionDataFormats/GlobalTrackID.h"
#include "CommonDataFormat/EvIndex.h"

namespace o2
{
namespace dataformats
{
class MatchInfoTOF
{
  using GTrackID = o2::dataformats::GlobalTrackID;

 public:
  MatchInfoTOF(int idLocal, int idxTOFCl, double time, float chi2, o2::track::TrackLTIntegral trkIntLT, GTrackID idxTrack, float dt = 0, float z = 0, float dx = 0, float dz = 0) : mIdLocal(idLocal), mIdxTOFCl(idxTOFCl), mSignal(time), mChi2(chi2), mIntLT(trkIntLT), mIdxTrack(idxTrack), mDeltaT(dt), mZatTOF(z), mDXatTOF(dx), mDZatTOF(dz){};
  MatchInfoTOF() = default;
  void setIdxTOFCl(int index) { mIdxTOFCl = index; }
  void setIdxTrack(GTrackID index) { mIdxTrack = index; }
  int getIdxTOFCl() const { return mIdxTOFCl; }
  GTrackID getTrackRef() const { return mIdxTrack; }
  int getEventTOFClIndex() const { return mIdxTOFCl; }
  int getTOFClIndex() const { return mIdxTOFCl; }
  int getTrackIndex() const { return mIdxTrack.getIndex(); }

  void setChi2(int chi2) { mChi2 = chi2; }
  float getChi2() const { return mChi2; }

  o2::track::TrackLTIntegral& getLTIntegralOut() { return mIntLT; }
  const o2::track::TrackLTIntegral& getLTIntegralOut() const { return mIntLT; }
  void print() const;

  void setDeltaT(float val) { mDeltaT = val; }
  float getDeltaT() const { return mDeltaT; }
  void setZatTOF(float val) { mZatTOF = val; }
  float getZatTOF() const { return mZatTOF; }
  void setDZatTOF(float val) { mDZatTOF = val; }
  float getDZatTOF() const { return mDZatTOF; }
  void setDXatTOF(float val) { mDXatTOF = val; }
  float getDXatTOF() const { return mDXatTOF; }
  void setSignal(double time) { mSignal = time; }
  double getSignal() const { return mSignal; }

  int getIdLocal() const { return mIdLocal; }

 private:
  int mIdLocal;                      // track id in sector of the pair track-TOFcluster
  float mChi2;                       // chi2 of the pair track-TOFcluster
  o2::track::TrackLTIntegral mIntLT; ///< L,TOF integral calculated during the propagation
  int mIdxTOFCl;                     ///< Idx for TOF cluster
  GTrackID mIdxTrack;                ///< Idx for track
  float mZatTOF = 0.0;               ///< Z position at  TOF
  float mDXatTOF = 0.0;              ///< DX position at  TOF
  float mDZatTOF = 0.0;              ///< DZ position at  TOF
  float mDeltaT = 0.0;               ///< tTOF - TPC (microsec)
  double mSignal = 0.0;              ///< TOF time in ps

  ClassDefNV(MatchInfoTOF, 5);
};
} // namespace dataformats
} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file MatchInfoTOFReco.h
/// \brief Class to temporary store the output of the matching to TOF in reconstruction

#ifndef ALICEO2_MATCHINFOTOFRECO_H
#define ALICEO2_MATCHINFOTOFRECO_H

#include "ReconstructionDataFormats/MatchInfoTOF.h"

namespace o2
{
namespace dataformats
{
class MatchInfoTOFReco : public MatchInfoTOF
{
  using GTrackID = o2::dataformats::GlobalTrackID;

 public:
  enum TrackType : int8_t { UNCONS = 0,
                            CONSTR,
                            SIZE,
                            TPC = 0,
                            ITSTPC,
                            TPCTRD,
                            ITSTPCTRD,
                            SIZEALL };

  MatchInfoTOFReco(int idLocal, int idxTOFCl, double time, float chi2, o2::track::TrackLTIntegral trkIntLT, GTrackID idxTrack, TrackType trkType, float dt = 0, float z = 0, float dx = 0, float dz = 0) : MatchInfoTOF(idLocal, idxTOFCl, time, chi2, trkIntLT, idxTrack, dt, z, dx, dz), mTrackType(trkType){};

  MatchInfoTOFReco() = default;

  void setTrackType(TrackType value) { mTrackType = value; }
  TrackType getTrackType() const { return mTrackType; }

 private:
  TrackType mTrackType; ///< track type (TPC, ITSTPC, TPCTRD, ITSTPCTRD)
  ClassDefNV(MatchInfoTOFReco, 2);
};
} // namespace dataformats
} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file TrackLTIntegral.h
/// \brief Track Length and TOF integral
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_TRACK_LTINTEGRAL_H_
#define ALICEO2_TRACK_LTINTEGRAL_H_

#include "GPUCommonRtypes.h"
#include "GPUCommonDef.h"
#include "ReconstructionDataFormats/PID.h"

namespace o2
{
namespace track
{

class TrackLTIntegral
{
 public:
  static constexpr float NeglectTime = -1.; // if 1st mT slot contains this, don't fill time

  GPUdDefault() TrackLTIntegral() = default;
  GPUdDefault() TrackLTIntegral(const TrackLTIntegral& stc) = default;
  GPUdDefault() ~TrackLTIntegral() = default;

  GPUd() static constexpr int getNTOFs() { return o2::track::PID::NIDs; }

  GPUd() float getL() const { return mL; }
  GPUd() float getX2X0() const { return mX2X0; }
  GPUd() float getXRho() const { return mXRho; }
  GPUd() float getTOF(int id) const { return mT[id]; }

  GPUd() void clear()
  {
    mL = 0.f;
    mX2X0 = 0.f;
    mXRho = 0.f;
    for (int i = getNTOFs(); i--;) {
      mT[i] = 0.f;
    }
  }

  GPUd() void addStep(float dL, float p2Inv);
  GPUd() void addX2X0(float d) { mX2X0 += d; }
  GPUd() void addXRho(float d) { mXRho += d; }

  GPUd() void setL(float l) { mL = l; }
  GPUd() void setX2X0(float x) { mX2X0 = x; }
  GPUd() void setXRho(float x) { mXRho = x; }
  GPUd() void setTOF(float t, int id) { mT[id] = t; }

  GPUd() void setTimeNotNeeded() { mT[0] = NeglectTime; }
  GPUd() bool isTimeNotNeeded() const { return mT[0] == NeglectTime; }

  GPUd() void print() const;

 private:
  float mL = 0.;                         // length in cm
  float mX2X0 = 0.;                      // integrated X/X0
  float mXRho = 0.;                      // average X*rho
  float mT[o2::track::PID::NIDs] = {0.}; // TOF in ps

  ClassDefNV(TrackLTIntegral, 2);
};
}; // namespace track
}; // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file PID.h
/// \brief particle ids, masses, names class definition
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_track_PID_H_
#define ALICEO2_track_PID_H_

#include "GPUCommonDef.h"
#include "GPUCommonRtypes.h"
#include "CommonConstants/PhysicsConstants.h"

namespace o2
{
namespace track
{
namespace o2cp = o2::constants::physics;

namespace pid_constants // GPUs currently cannot have static constexpr array members
{
typedef uint8_t ID;
static constexpr ID NIDsTot = 17;
GPUconstexpr() const char* sNames[NIDsTot + 1] = ///< defined particle names
  {"Electron", "Muon", "Pion", "Kaon", "Proton", "Deuteron", "Triton", "He3", "Alpha",
   "Pion0", "Photon", "K0", "Lambda", "HyperTriton", "Hyperhydrog4", "XiMinus", "OmegaMinus", nullptr};

GPUconstexpr() const float sMasses[NIDsTot] = ///< defined particle masses
  {o2cp::MassElectron, o2cp::MassMuon, o2cp::MassPionCharged, o2cp::MassKaonCharged,
   o2cp::MassProton, o2cp::MassDeuteron, o2cp::MassTriton, o2cp::MassHelium3,
   o2cp::MassAlpha, o2cp::MassPionNeutral, o2cp::MassPhoton,
   o2cp::MassKaonNeutral, o2cp::MassLambda, o2cp::MassHyperTriton, o2cp::MassHyperhydrog4, o2cp::MassXiMinus, o2cp::MassOmegaMinus};

GPUconstexpr() const float sMasses2[NIDsTot] = ///< defined particle masses^2
  {o2cp::MassElectron * o2cp::MassElectron,
   o2cp::MassMuon* o2cp::MassMuon,
   o2cp::MassPionCharged* o2cp::MassPionCharged,
   o2cp::MassKaonCharged* o2cp::MassKaonCharged,
   o2cp::MassProton* o2cp::MassProton,
   o2cp::MassDeuteron* o2cp::MassDeuteron,
   o2cp::MassTriton* o2cp::MassTriton,
   o2cp::MassHelium3* o2cp::MassHelium3,
   o2cp::MassAlpha* o2cp::MassAlpha,
   o2cp::MassPionNeutral* o2cp::MassPionNeutral,
   o2cp::MassPhoton* o2cp::MassPhoton,
   o2cp::MassKaonNeutral* o2cp::MassKaonNeutral,
   o2cp::MassLambda* o2cp::MassLambda,
   o2cp::MassHyperTriton* o2cp::MassHyperTriton,
   o2cp::MassHyperhydrog4* o2cp::MassHyperhydrog4,
   o2cp::MassXiMinus* o2cp::MassXiMinus,
   o2cp::MassOmegaMinus* o2cp::MassOmegaMinus};

GPUconstexpr() const float sMasses2Z[NIDsTot] = ///< defined particle masses / Z
  {o2cp::MassElectron, o2cp::MassMuon,
   o2cp::MassPionCharged, o2cp::MassKaonCharged,
   o2cp::MassProton, o2cp::MassDeuteron,
   o2cp::MassTriton, o2cp::MassHelium3 / 2.,
   o2cp::MassAlpha / 2.,
   0, 0, 0, 0, o2cp::MassHyperTriton, o2cp::MassHyperhydrog4,
   o2cp::MassXiMinus, o2cp::MassOmegaMinus};

GPUconstexpr() const int sCharges[NIDsTot] = ///< defined particle charges
  {1, 1, 1, 1, 1, 1, 1, 2, 2,
   0, 0, 0, 0, 1, 1,
   1, 1};
} // namespace pid_constants

class PID
{
 public:
  // particle identifiers, continuos starting from 0
  typedef pid_constants::ID ID;

  static constexpr ID Electron = 0;
  static constexpr ID Muon = 1;
  static constexpr ID Pion = 2;
  static constexpr ID Kaon = 3;
  static constexpr ID Proton = 4;
  static constexpr ID Deuteron = 5;
  static constexpr ID Triton = 6;
  static constexpr ID Helium3 = 7;
  static constexpr ID Alpha = 8;

  static constexpr ID First = Electron;
  static constexpr ID Last = Alpha;     ///< if extra IDs added, update this !!!
  static constexpr ID NIDs = Last + 1;  ///< number of defined IDs

  // PID for derived particles
  static constexpr ID PI0 = 9;
  static constexpr ID Photon = 10;
  static constexpr ID K0 = 11;
  static constexpr ID Lambda = 12;
  static constexpr ID HyperTriton = 13;
  static constexpr ID Hyperhydrog4 = 14;
  static constexpr ID XiMinus = 15;
  static constexpr ID OmegaMinus = 16;
  static constexpr ID FirstExt = PI0;
  static constexpr ID LastExt = OmegaMinus;
  static constexpr ID NIDsTot = pid_constants::NIDsTot; ///< total number of defined IDs
  static_assert(NIDsTot == LastExt + 1, "Incorrect NIDsTot, please update!");

  GPUdDefault() PID() = default;
  GPUd() PID(ID id) : mID(id) {}
  GPUd() PID(const char* name);
  GPUdDefault() PID(const PID& src) = default;
  GPUdDefault() PID& operator=(const PID& src) = default;

  GPUd() ID getID() const { return mID; }
  GPUd() operator ID() const { return getID(); }

  GPUd() float getMass() const { return getMass(mID); }
  GPUd() float getMass2() const { return getMass2(mID); }
  GPUd() float getMass2Z() const { return getMass2Z(mID); }
  GPUd() int getCharge() const { return getCharge(mID); }

  GPUd() static float getMass(ID id) { return pid_constants::sMasses[id]; }
  GPUd() static float getMass2(ID id) { return pid_constants::sMasses2[id]; }
  GPUd() static float getMass2Z(ID id) { return pid_constants::sMasses2Z[id]; }
  GPUd() static int getCharge(ID id) { return pid_constants::sCharges[id]; }
#ifndef GPUCA_GPUCODE_DEVICE
  GPUd() const char* getName() const
  {
    return getName(mID);
  }
  GPUd() static const char* getName(ID id) { return pid_constants::sNames[id]; }
#endif

 private:
  ID mID = Pion;

  // are 2 strings equal ? (trick from Giulio)
  GPUdi() static constexpr bool sameStr(char const* x, char const* y)
  {
    return !*x && !*y ? true : /* default */ (*x == *y && sameStr(x + 1, y + 1));
  }

#ifndef GPUCA_GPUCODE_DEVICE
  GPUdi() static constexpr ID nameToID(char const* name, ID id)
  {
    return id > LastExt ? id : sameStr(name, pid_constants::sNames[id]) ? id : nameToID(name, id + 1);
  }
#endif

  ClassDefNV(PID, 2);
};
} // namespace track
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_DCA_H
#define ALICEO2_DCA_H

#include "GPUCommonDef.h"
#include "GPUCommonRtypes.h"
#include "GPUCommonArray.h"

#ifndef GPUCA_GPUCODE_DEVICE
#include <iosfwd>
#endif

/// \author ruben.shahoyan@cern.ch
/// \brief  class for distance of closest approach to vertex

namespace o2
{
namespace dataformats
{

class DCA
{

 public:
  GPUdDefault() DCA() = default;

  GPUd() DCA(float y, float z, float syy = 0.f, float syz = 0.f, float szz = 0.f)
  {
    set(y, z, syy, syz, szz);
  }

  GPUd() void set(float y, float z, float syy, float syz, float szz)
  {
    mY = y;
    mZ = z;
    mCov[0] = syy;
    mCov[1] = syz;
    mCov[2] = szz;
  }

  GPUd() void set(float y, float z)
  {
    mY = y;
    mZ = z;
  }

  GPUd() auto getY() const { return mY; }
  GPUd() auto getZ() const { return mZ; }
  GPUd() auto getR2() const { return mY * mY + mZ * mZ; }
  GPUd() auto getSigmaY2() const { return mCov[0]; }
  GPUd() auto getSigmaYZ() const { return mCov[1]; }
  GPUd() auto getSigmaZ2() const { return mCov[2]; }
  GPUd() const auto& getCovariance() const { return mCov; }

  void print() const;

 private:
  float mY = 0.f;
  float mZ = 0.f;
  gpu::gpustd::array<float, 3> mCov; ///< s2y, syz, s2z

  ClassDefNV(DCA, 1);
};

#ifndef GPUCA_GPUCODE_DEVICE
std::ostream& operator<<(std::ostream& os, const DCA& d);
#endif

} // namespace dataformats
} // namespace o2

#endif //ALICEO2_DCA_H
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_V0_H
#define ALICEO2_V0_H

#include "ReconstructionDataFormats/VtxTrackIndex.h"
#include "ReconstructionDataFormats/Track.h"
#include "ReconstructionDataFormats/PID.h"
#include <array>
#include <Math/SVector.h>

namespace o2
{
namespace dataformats
{

class V0 : public o2::track::TrackParCov
{
 public:
  using GIndex = o2::dataformats::VtxTrackIndex;
  using Track = o2::track::TrackParCov;
  using PID = o2::track::PID;

  V0() = default;
  V0(const std::array<float, 3>& xyz, const std::array<float, 3>& pxyz, const std::array<float, 6>& covxyz,
     const o2::track::TrackParCov& trPos, const o2::track::TrackParCov& trNeg,
     GIndex trPosID, GIndex trNegID, o2::track::PID pid = o2::track::PID::K0);

  GIndex getProngID(int i) const { return mProngIDs[i]; }
  void setProngID(int i, GIndex gid) { mProngIDs[i] = gid; }

  const Track& getProng(int i) const { return mProngs[i]; }
  Track& getProng(int i) { return mProngs[i]; }
  void setProng(int i, const Track& t) { mProngs[i] = t; }

  float getCosPA() const { return mCosPA; }
  void setCosPA(float c) { mCosPA = c; }

  float getDCA() const { return mDCA; }
  void setDCA(float d) { mDCA = d; }

  int getVertexID() const { return mVertexID; }
  void setVertexID(int id) { mVertexID = id; }

  float calcMass2() const { return calcMass2(mProngs[0].getPID(), mProngs[1].getPID()); }
  float calcMass2(PID pidPos, PID pidNeg) const { return calcMass2(pidPos.getMass2(), pidNeg.getMass2()); }
  float calcMass2(float massPos2, float massNeg2) const;

  float calcR2() const { return getX() * getX() + getY() * getY(); }

 protected:
  std::array<GIndex, 2> mProngIDs; // global IDs of prongs
  std::array<Track, 2> mProngs;    // prongs kinematics at vertex
  float mCosPA = 0;                // cos of pointing angle
  float mDCA = 9990;               // distance of closest approach of prongs
  int mVertexID = -1;              // id of parent vertex

  ClassDefNV(V0, 1);
};

} // namespace dataformats
} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_CASCADE_H
#define ALICEO2_CASCADE_H

#include "ReconstructionDataFormats/GlobalTrackID.h"
#include "ReconstructionDataFormats/Track.h"
#include "ReconstructionDataFormats/PID.h"
#include "ReconstructionDataFormats/V0.h"
#include <array>
#include <Math/SVector.h>

namespace o2
{
namespace dataformats
{

class Cascade : public V0
{
 public:
  Cascade() = default;
  Cascade(const std::array<float, 3>& xyz, const std::array<float, 3>& pxyz, const std::array<float, 6>& covxyz,
          const o2::track::TrackParCov& v0, const o2::track::TrackParCov& bachelor,
          int v0ID, GIndex bachelorID, o2::track::PID pid = o2::track::PID::XiMinus);

  GIndex getBachelorID() const { return mProngIDs[1]; }
  void setBachelorID(GIndex gid) { mProngIDs[1] = gid; }

  int getV0ID() const { return int(mProngIDs[0].getRaw()); }
  void setV0ID(int vid) { mProngIDs[0].setRaw(GIndex::Base_t(vid)); }

  const Track& getV0Track() const { return mProngs[0]; }
  Track& getV0Track() { return mProngs[0]; }

  const Track& getBachelorTrack() const { return mProngs[1]; }
  Track& getBachelorTrack() { return mProngs[1]; }

  void setV0Track(const Track& t) { mProngs[0] = t; }
  void setBachelorTrack(const Track& t) { mProngs[1] = t; }

 protected:
  GIndex getProngID(int i) const = delete;

  ClassDefNV(Cascade, 1);
};

} // namespace dataformats
} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// @file  GlobalTrackID.h
/// \brief Global index for barrel track: provides provenance (detectors combination), index in respective array and some number of bits
/// \author ruben.shahoyan@cern.ch

#ifndef O2_GLOBAL_TRACK_ID
#define O2_GLOBAL_TRACK_ID

#include "GPUCommonBitSet.h"
#include "CommonDataFormat/AbstractRef.h"
#include "DetectorsCommonDataFormats/DetID.h"
#ifndef GPUCA_GPUCODE
#include <iosfwd>
#include <string>
#include <array>
#include <string_view>
#include <bitset>
#endif // GPUCA_GPUCODE_DEVICE

namespace o2
{
namespace dataformats
{

class GlobalTrackID : public AbstractRef<25, 5, 2>
{
 public:
  using DetID = o2::detectors::DetID;

  enum Source : uint8_t { // provenance of the
    ITS,                  // standalone detectors
    TPC,
    TRD,
    TOF,
    PHS, // FIXME Not sure PHS ... FDD should be kept here, at the moment
    CPV, // they are here for completeness
    EMC,
    HMP,
    MFT,
    MCH,
    MID,
    ZDC,
    FT0,
    FV0,
    FDD,
    ITSTPC, // 2-detector tracks
    TPCTOF,
    TPCTRD,
    MFTMCH,
    ITSTPCTRD, // 3-detector tracks
    ITSTPCTOF,
    TPCTRDTOF,
    MFTMCHMID,
    ITSTPCTRDTOF, // full barrel track
    ITSAB,        // ITS AfterBurner tracklets
    CTP,
    //
    MCHMID, // Temporary ordering
    //
    NSources
  };

  using AbstractRef<25, 5, 2>::AbstractRef;
  static_assert(NSources <= 32, "bitset<32> insufficient");
  typedef o2::gpu::gpustd::bitset<32> mask_t;

#ifndef GPUCA_GPUCODE
  static constexpr std::string_view NONE{"none"}; ///< keywork for no sources
  static constexpr std::string_view ALL{"all"};   ///< keywork for all sources
#endif
  static constexpr mask_t MASK_ALL = (1u << NSources) - 1;
  static constexpr mask_t MASK_NONE = 0;

  // methods for detector level manipulations
  GPUdi() static constexpr DetID::mask_t getSourceDetectorsMask(int i);
  GPUdi() static constexpr DetID::mask_t getSourcesDetectorsMask(GlobalTrackID::mask_t srcm);
  GPUdi() static bool includesDet(DetID id, GlobalTrackID::mask_t srcm);
  GPUdi() static bool isTrackSource(int s);
  GPUdi() auto getSourceDetectorsMask() const { return getSourceDetectorsMask(getSource()); }
  GPUdi() bool includesDet(DetID id) const { return (getSourceDetectorsMask() & DetID::getMask(id)).any(); }

  // methods for source level manipulations
#ifndef GPUCA_GPUCODE
  static auto getSourceName(int s)
  {
    return DetID::getNames(getSourceDetectorsMask(s), '-');
  }
  static mask_t getSourcesMask(const std::string_view srcList);
  static std::string getSourcesNames(mask_t srcm);
  auto getSourceName() const { return getSourceName(getSource()); }
#endif // GPUCA_GPUCODE
  GPUd() static constexpr mask_t getSourceMask(int s);
  GPUdi() mask_t getSourceMask() const { return getSourceMask(getSource()); }
  GPUdi() static bool includesSource(int s, mask_t srcm) { return srcm[s]; }
  GPUdi() operator int() const { return int(getIndex()); }

#ifndef GPUCA_GPUCODE
  std::string asString() const;
  void print() const;
#endif // GPUCA_GPUCODE

  ClassDefNV(GlobalTrackID, 3);
};

#ifndef GPUCA_GPUCODE
std::ostream& operator<<(std::ostream& os, const o2::dataformats::GlobalTrackID& v);
#endif // GPUCA_GPUCODE

namespace globaltrackid_internal
{
// static constexpr array class members not possible on the GPU, thus we use this trick.
using DetID = o2::detectors::DetID;
GPUconstexpr() DetID::mask_t SourceDetectorsMasks[GlobalTrackID::NSources] = {
  DetID::mask_t(DetID::getMask(DetID::ITS)),
  DetID::mask_t(DetID::getMask(DetID::TPC)),
  DetID::mask_t(DetID::getMask(DetID::TRD)),
  DetID::mask_t(DetID::getMask(DetID::TOF)),
  DetID::mask_t(DetID::getMask(DetID::PHS)),
  DetID::mask_t(DetID::getMask(DetID::CPV)),
  DetID::mask_t(DetID::getMask(DetID::EMC)),
  DetID::mask_t(DetID::getMask(DetID::HMP)),
  DetID::mask_t(DetID::getMask(DetID::MFT)),
  DetID::mask_t(DetID::getMask(DetID::MCH)),
  DetID::mask_t(DetID::getMask(DetID::MID)),
  DetID::mask_t(DetID::getMask(DetID::ZDC)),
  DetID::mask_t(DetID::getMask(DetID::FT0)),
  DetID::mask_t(DetID::getMask(DetID::FV0)),
  DetID::mask_t(DetID::getMask(DetID::FDD)),
  //
  DetID::mask_t(DetID::getMask(DetID::ITS) | DetID::getMask(DetID::TPC)),
  DetID::mask_t(DetID::getMask(DetID::TPC) | DetID::getMask(DetID::TOF)),
  DetID::mask_t(DetID::getMask(DetID::TPC) | DetID::getMask(DetID::TRD)),
  DetID::mask_t(DetID::getMask(DetID::MFT) | DetID::getMask(DetID::MCH)),
  DetID::mask_t(DetID::getMask(DetID::ITS) | DetID::getMask(DetID::TPC) | DetID::getMask(DetID::TRD)),
  DetID::mask_t(DetID::getMask(DetID::ITS) | DetID::getMask(DetID::TPC) | DetID::getMask(DetID::TOF)),
  DetID::mask_t(DetID::getMask(DetID::TPC) | DetID::getMask(DetID::TRD) | DetID::getMask(DetID::TOF)),
  DetID::mask_t(DetID::getMask(DetID::MFT) | DetID::getMask(DetID::MCH) | DetID::getMask(DetID::MID)),
  DetID::mask_t(DetID::getMask(DetID::ITS) | DetID::getMask(DetID::TPC) | DetID::getMask(DetID::TRD) | DetID::getMask(DetID::TOF)),
  DetID::mask_t(DetID::getMask(DetID::ITS)),
  DetID::mask_t(DetID::getMask(DetID::CTP)),
  DetID::mask_t(DetID::getMask(DetID::MCH) | DetID::getMask(DetID::MID)) // Temporary ordering
};

GPUconstexpr() GlobalTrackID::mask_t sMasks[GlobalTrackID::NSources] = ///< detector masks
  {
    GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::ITS)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::TPC)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::TRD)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::TOF)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::PHS)),
    GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::CPV)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::EMC)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::HMP)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::MFT)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::MCH)),
    GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::MID)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::ZDC)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::FT0)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::FV0)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::FDD)),
    GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::ITSTPC)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::TPCTOF)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::TPCTRD)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::MFTMCH)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::ITSTPCTRD)),
    GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::ITSTPCTOF)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::TPCTRDTOF)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::ITSTPCTRDTOF)), GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::MFTMCHMID)),
    GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::ITSAB)),
    GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::CTP)),
    GlobalTrackID::mask_t(math_utils::bit2Mask(GlobalTrackID::MCHMID)) // Temporary ordering
};

#ifndef __OPENCL__
GPUconstexpr() GlobalTrackID::mask_t sTrackSources =
  sMasks[GlobalTrackID::ITS] | sMasks[GlobalTrackID::TPC] | sMasks[GlobalTrackID::MFT] | sMasks[GlobalTrackID::MCH] | sMasks[GlobalTrackID::ITSTPC] | sMasks[GlobalTrackID::TPCTOF] |
  sMasks[GlobalTrackID::TPCTRD] | sMasks[GlobalTrackID::MFTMCH] | sMasks[GlobalTrackID::ITSTPCTRD] | sMasks[GlobalTrackID::ITSTPCTOF] | sMasks[GlobalTrackID::TPCTRDTOF] |
  sMasks[GlobalTrackID::MFTMCHMID] | sMasks[GlobalTrackID::ITSTPCTRDTOF] | sMasks[GlobalTrackID::ITSAB] | sMasks[GlobalTrackID::MCHMID];
#endif

} // namespace globaltrackid_internal

GPUdi() constexpr GlobalTrackID::DetID::mask_t GlobalTrackID::getSourceDetectorsMask(int i) { return globaltrackid_internal::SourceDetectorsMasks[i]; }
GPUdi() constexpr GlobalTrackID::mask_t GlobalTrackID::getSourceMask(int s) { return globaltrackid_internal::sMasks[s]; }

#ifndef __OPENCL__
GPUdi() bool GlobalTrackID::isTrackSource(int s)
{
  return globaltrackid_internal::sTrackSources[s];
}
#endif

GPUdi() bool GlobalTrackID::includesDet(DetID id, GlobalTrackID::mask_t srcm)
{
  for (int i = 0; i < NSources; i++) {
    if (includesSource(i, srcm) && (getSourceDetectorsMask(i) & id.getMask()).any()) {
      return true;
    }
  }
  return false;
}

GPUd() constexpr GlobalTrackID::DetID::mask_t GlobalTrackID::getSourcesDetectorsMask(GlobalTrackID::mask_t srcm)
{
  GlobalTrackID::DetID::mask_t mdet;
  for (int i = 0; i < NSources; i++) {
    if (srcm[i]) {
      mdet |= getSourceDetectorsMask(i);
    }
  }
  return mdet;
}

} // namespace dataformats
} // namespace o2

#ifndef GPUCA_GPUCODE
namespace std
{
// defining std::hash for GlobalTrackIndex to be used with std containers
template <>
struct hash<o2::dataformats::GlobalTrackID> {
 public:
  size_t operator()(const o2::dataformats::GlobalTrackID& id) const
  {
    return id.getRawWOFlags();
  }
};
} // namespace std
#endif // GPUCA_GPUCODE

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// @file  VtxTrackIndex.h
/// \brief Extention of GlobalTrackID by flags relevant for verter-track association
/// \author ruben.shahoyan@cern.ch

#ifndef O2_VERTEX_TRACK_INDEX
#define O2_VERTEX_TRACK_INDEX

#include "ReconstructionDataFormats/GlobalTrackID.h"
#include <iosfwd>
#include <string>
#include <array>
#include <string_view>

namespace o2
{
namespace dataformats
{

class VtxTrackIndex : public GlobalTrackID
{
 public:
  enum Flags : uint8_t {
    Contributor, // flag that it contributes to vertex fit
    Ambiguous,   // flag that attachment is ambiguous
    NFlags
  };

  using GlobalTrackID::GlobalTrackID;
  VtxTrackIndex() = default;
  VtxTrackIndex(const GlobalTrackID& src) : GlobalTrackID(src) {}

  bool isPVContributor() const { return testBit(Contributor); }
  void setPVContributor() { setBit(Contributor); }

  bool isAmbiguous() const { return testBit(Ambiguous); }
  void setAmbiguous() { setBit(Ambiguous); }

  ClassDefNV(VtxTrackIndex, 2);
};

} // namespace dataformats
} // namespace o2

namespace std
{
// defining std::hash for VtxTrackIndex to be used with std containers
template <>
struct hash<o2::dataformats::VtxTrackIndex> {
 public:
  size_t operator()(const o2::dataformats::VtxTrackIndex& id) const
  {
    return std::hash<o2::dataformats::GlobalTrackID>{}(id);
    //return id.getRawWOFlags();
  }
};
} // namespace std

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// @file  VtxTrackRef.h
/// \brief Referenc on track indices contributing to the vertex, with possibility chose tracks from specific source (global, ITS, TPC...)
/// \author ruben.shahoyan@cern.ch

#ifndef O2_VERTEX_TRACK_REF
#define O2_VERTEX_TRACK_REF

#include "CommonDataFormat/RangeReference.h"
#include "ReconstructionDataFormats/VtxTrackIndex.h"
#include <cassert>
#include <array>
#include <iosfwd>
#include <string>

namespace o2
{
namespace dataformats
{

/* Class to refer in start and number of contributors in the container of with consecutively filled conributors.
     The contributors are suppossed to be sorted according to their sources.
     Note: the only way to fill the references is to fill them all in increasing order and set the end!
     VtxTrackIndex ref;
     for (int i=0;i<VtxTrackIndex::Source::NSources;i++) {
       ref.setFirstEntryOfSource(i, idxI); // idxI must be >= idxI-1 (if it is =, then source i has not entries
     }
     ref.setEnd(idxLast + 1); // i.e. idxLast+1 = idx0 + TotalNumberOfEntries
  */

class VtxTrackRef : public RangeReference<int, int>
{
 public:
  VtxTrackRef() : RangeReference(-1, 0)
  {
    for (int i = VtxTrackIndex::Source::NSources - 1; i--;) {
      mFirstEntrySource[i] = -1; // only 1st source (base reference) is filled at constructor level
    }
  }

  void print(bool skipEmpty = true) const;
  std::string asString(bool skipEmpty = true) const;

  // get 1st of entry of indices for given source
  int getFirstEntryOfSource(int s) const
  {
    assert(s >= 0 && s < VtxTrackIndex::NSources);
    return s ? mFirstEntrySource[s - 1] : getFirstEntry();
  }

  // get number of entries for given source
  int getEntriesOfSource(int s) const
  {
    return (s == VtxTrackIndex::NSources - 1 ? (getFirstEntry() + getEntries()) : getFirstEntryOfSource(s + 1)) - getFirstEntryOfSource(s);
  }

  void setFirstEntryOfSource(int s, int i)
  {
    assert(s >= 0 && s < VtxTrackIndex::NSources);
    if (s) {
      mFirstEntrySource[s - 1] = i;
    } else {
      setFirstEntry(i);
    }
  }

  void setVtxID(int i) { mVtxID = i; }
  int getVtxID() const { return mVtxID; }

  // set the last +1 element index and finalize all references
  void setEnd(int end);

 private:
  using RangeReference<int, int>::RangeReference;
  int mVtxID = -1; // vertex ID. The reference for unassigned tracks will have it negative!
  std::array<int, VtxTrackIndex::Source::NSources - 1> mFirstEntrySource{0};

  ClassDefNV(VtxTrackRef, 2);
};

std::ostream& operator<<(std::ostream& os, const o2::dataformats::VtxTrackRef& v);

} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file TrackTPCTOF.h
/// \brief Result of refitting TPC with TOF match constraint
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_TRACKTPCTOF_H
#define ALICEO2_TRACKTPCTOF_H

#include "ReconstructionDataFormats/Track.h"
#include "ReconstructionDataFormats/TrackLTIntegral.h"
#include "CommonDataFormat/TimeStamp.h"

namespace o2
{
namespace dataformats
{

class TrackTPCTOF : public o2::track::TrackParCov
{
  using timeEst = o2::dataformats::TimeStampWithError<float, float>;

 public:
  TrackTPCTOF() = default;
  ~TrackTPCTOF() = default;
  TrackTPCTOF(const TrackTPCTOF& src) = default;
  TrackTPCTOF(const o2::track::TrackParCov& src) : o2::track::TrackParCov(src) {}

  int getRefMatch() const { return mRefMatch; }
  void setRefMatch(int id) { mRefMatch = id; }

  const timeEst& getTimeMUS() const { return mTimeMUS; }
  timeEst& getTimeMUS() { return mTimeMUS; }
  void setTimeMUS(const timeEst& t) { mTimeMUS = t; }
  void setTimeMUS(float t, float te)
  {
    mTimeMUS.setTimeStamp(t);
    mTimeMUS.setTimeStampError(te);
  }

  void setChi2Refit(float v) { mChi2Refit = v; }
  float getChi2Refit() const { return mChi2Refit; }

  o2::track::TrackParCov& getParamOut() { return mParamOut; }
  const o2::track::TrackParCov& getParamOut() const { return mParamOut; }
  void setParamOut(const o2::track::TrackParCov& v) { mParamOut = v; }

  void print() const;

 private:
  o2::track::TrackParCov mParamOut; // outward fit (in TPC at the moment)
  int mRefMatch = -1;     ///< reference on track-TOF match in its original container
  float mChi2Refit = 0.f; ///< chi2 of the refit
  timeEst mTimeMUS;       ///< time estimate in ns

  ClassDefNV(TrackTPCTOF, 2);
};
} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file TrackCosmics.h
/// \brief Result of top-bottom cosmic tracks leg matching
/// \author ruben.shahoyan@cern.ch

#ifndef ALICEO2_TRACKCOSMICS_H
#define ALICEO2_TRACKCOSMICS_H

#include "ReconstructionDataFormats/Track.h"
#include "ReconstructionDataFormats/GlobalTrackID.h"
#include "CommonDataFormat/TimeStamp.h"

namespace o2
{
namespace dataformats
{

class TrackCosmics : public o2::track::TrackParCov
{
  using timeEst = o2::dataformats::TimeStampWithError<float, float>;

 public:
  TrackCosmics() = default;
  ~TrackCosmics() = default;
  TrackCosmics(const TrackCosmics& src) = default;
  TrackCosmics(GlobalTrackID btm, GlobalTrackID top, const o2::track::TrackParCov& srcCent, const o2::track::TrackParCov& srcOut, float chi2Ref, float chi2Match, int ncl, float t, float tErr)
    : o2::track::TrackParCov(srcCent), mParamOut(srcOut), mRefBottom(btm), mRefTop(top), mChi2Refit(chi2Ref), mChi2Match(chi2Match), mNClusters(ncl), mTimeMUS{t, tErr} {}

  GlobalTrackID getRefBottom() const { return mRefBottom; }
  GlobalTrackID getRefTop() const { return mRefTop; }
  void setRefBottom(GlobalTrackID id) { mRefBottom = id; }
  void setRefTop(GlobalTrackID id) { mRefTop = id; }

  const timeEst& getTimeMUS() const { return mTimeMUS; }
  timeEst& getTimeMUS() { return mTimeMUS; }
  void setTimeMUS(const timeEst& t) { mTimeMUS = t; }
  void setTimeMUS(float t, float te)
  {
    mTimeMUS.setTimeStamp(t);
    mTimeMUS.setTimeStampError(te);
  }

  void setChi2Refit(float v) { mChi2Refit = v; }
  float getChi2Refit() const { return mChi2Refit; }

  void setChi2Match(float v) { mChi2Match = v; }
  float getChi2Match() const { return mChi2Match; }

  int getNClusters() const { return mNClusters; }
  void setNClusters(int n) { mNClusters = n; }

  o2::track::TrackParCov& getParamOut() { return mParamOut; }
  const o2::track::TrackParCov& getParamOut() const { return mParamOut; }

  void print() const;

 private:
  GlobalTrackID mRefBottom;         ///< reference on Bottom leg
  GlobalTrackID mRefTop;            ///< reference on Top leg
  float mChi2Refit = 0.f;           ///< chi2 of the global refit
  float mChi2Match = 0.f;           ///< chi2 of the top/bottom match
  int mNClusters = 0;               ///< total number of fitted clusters
  timeEst mTimeMUS;                 ///< time estimate in ns
  o2::track::TrackParCov mParamOut; ///< refitted outer parameter

  ClassDefNV(TrackCosmics, 1);
};
} // namespace dataformats
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file TrackMCHMID.h
/// \brief Definition of the MUON track
///
/// \author Philippe Pillot, Subatech

#ifndef ALICEO2_TRACKMCHMID_H
#define ALICEO2_TRACKMCHMID_H

#include <utility>

#include "CommonDataFormat/InteractionRecord.h"
#include "CommonDataFormat/TimeStamp.h"
#include "ReconstructionDataFormats/GlobalTrackID.h"

namespace o2
{
namespace dataformats
{

/// MUON track external format
class TrackMCHMID
{
  using Time = o2::dataformats::TimeStampWithError<float, float>;

 public:
  TrackMCHMID() = default;
  TrackMCHMID(const GlobalTrackID& mchID, const GlobalTrackID& midID, const InteractionRecord& midIR, double chi2)
    : mMCHRef(mchID), mMIDRef(midID), mIR(midIR), mMatchNChi2(chi2) {}
  TrackMCHMID(uint32_t mchIdx, uint32_t midIdx, const InteractionRecord& midIR, double chi2)
    : mMCHRef(mchIdx, GlobalTrackID::MCH), mMIDRef(midIdx, GlobalTrackID::MID), mIR(midIR), mMatchNChi2(chi2) {}
  ~TrackMCHMID() = default;

  TrackMCHMID(const TrackMCHMID& track) = default;
  TrackMCHMID& operator=(const TrackMCHMID& track) = default;
  TrackMCHMID(TrackMCHMID&&) = default;
  TrackMCHMID& operator=(TrackMCHMID&&) = default;

  /// get the reference to the MCH track entry in its original container
  GlobalTrackID getMCHRef() const { return mMCHRef; }
  /// set the reference to the MCH track entry in its original container
  void setMCHRef(const GlobalTrackID& id) { mMCHRef = id; }
  /// set the reference to the MCH track entry in its original container
  void setMCHRef(uint32_t idx) { mMCHRef.set(idx, GlobalTrackID::MCH); }

  /// get the reference to the MID track entry in its original container
  GlobalTrackID getMIDRef() const { return mMIDRef; }
  /// set the reference to the MID track entry in its original container
  void setMIDRef(const GlobalTrackID& id) { mMIDRef = id; }
  /// set the reference to the MID track entry in its original container
  void setMIDRef(uint32_t idx) { mMIDRef.set(idx, GlobalTrackID::MID); }

  /// get the interaction record associated to this track
  InteractionRecord getIR() const { return mIR; }
  /// set the interaction record associated to this track
  void setIR(const InteractionRecord& ir) { mIR = ir; }

  std::pair<Time, bool> getTimeMUS(const InteractionRecord& startIR, uint32_t nOrbits = 128,
                                   bool printError = false) const;

  /// get the MCH-MID matching chi2/ndf
  double getMatchChi2OverNDF() const { return mMatchNChi2; }
  /// set the MCH-MID matching chi2/ndf
  void setMatchChi2OverNDF(double chi2) { mMatchNChi2 = chi2; }

  void print() const;

 private:
  GlobalTrackID mMCHRef{}; ///< reference to MCH track entry in its original container
  GlobalTrackID mMIDRef{}; ///< reference to MID track entry in its original container
  InteractionRecord mIR{}; ///< associated interaction record
  double mMatchNChi2 = 0.; ///< MCH-MID matching chi2/ndf

  ClassDefNV(TrackMCHMID, 1);
};

std::ostream& operator<<(std::ostream& os, const TrackMCHMID& track);

} // namespace dataformats
} // namespace o2

#endif // ALICEO2_TRACKMCHMID_H
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file MatchInfoFwd.h

#ifndef ALICEO2_MATCH_INFO_MFTMCH_H
#define ALICEO2_MATCH_INFO_MFTMCH_H

#include "CommonDataFormat/InteractionRecord.h"
#include "ReconstructionDataFormats/GlobalTrackID.h"
#include "CommonDataFormat/TimeStamp.h"

namespace o2
{
namespace dataformats
{
using timeEst = o2::dataformats::TimeStampWithError<float, float>;

class MatchInfoFwd
{
 public:
  MatchInfoFwd() = default;
  ~MatchInfoFwd() = default;

  void setMFTMCHMatchingChi2(float chi2) { mMFTMCHMatchingChi2 = chi2; }
  const auto& getMFTMCHMatchingChi2() const { return mMFTMCHMatchingChi2; }

  void setMFTMCHMatchingScore(float score) { mMFTMCH_MLScore = score; }
  const auto& getMFTMCHMatchingScore() const { return mMFTMCH_MLScore; }

  void setMIDMatchingChi2(float chi2) { mMCHMIDMatchingChi2 = chi2; }
  const auto& getMIDMatchingChi2() const { return mMCHMIDMatchingChi2; }

  void countMFTCandidate() { mNMFTCandidates++; }
  const auto& getNMFTCandidates() const { return mNMFTCandidates; }
  void setNMFTCandidates(int n) { mNMFTCandidates = n; }

  void setCloseMatch(bool v = true) { mCloseMatch = v; }
  const auto& isCloseMatch() const { return mCloseMatch; }

  void setMatchInfo(const MatchInfoFwd& m)
  {

    mMFTMCHMatchingChi2 = m.mMFTMCHMatchingChi2;
    mMCHMIDMatchingChi2 = m.mMCHMIDMatchingChi2;
    mMFTTrackID = m.mMFTTrackID;
    mMCHTrackID = m.mMCHTrackID;
    mMIDTrackID = m.mMIDTrackID;
    mNMFTCandidates = m.mNMFTCandidates;
    mCloseMatch = m.mCloseMatch;
    mMFTMCH_MLScore = m.mMFTMCH_MLScore;
    mTimeMUS = m.mTimeMUS;
  }

  void setMCHTrackID(int ID) { mMCHTrackID = ID; }
  const auto& getMCHTrackID() const { return mMCHTrackID; }
  void setMFTTrackID(int ID) { mMFTTrackID = ID; }
  const auto& getMFTTrackID() const { return mMFTTrackID; }
  void setMIDTrackID(int ID) { mMIDTrackID = ID; }
  const auto& getMIDTrackID() const { return mMIDTrackID; }

  const timeEst& getTimeMUS() const { return mTimeMUS; }
  timeEst& getTimeMUS() { return mTimeMUS; }
  void setTimeMUS(const timeEst& t) { mTimeMUS = t; }
  void setTimeMUS(float t, float te)
  {
    mTimeMUS.setTimeStamp(t);
    mTimeMUS.setTimeStampError(te);
  }

 private:
  float mMFTMCHMatchingChi2 = o2::constants::math::VeryBig; ///< MCH-MFT Matching Chi2
  float mMCHMIDMatchingChi2 = -1.0;                         ///< MCH-MID Matching Chi2
  int mMFTTrackID = -1;                                     ///< Track ID of best MFT-match
  int mMCHTrackID = -1;                                     ///< MCH Track ID
  int mMIDTrackID = -1;                                     ///< MID Track ID
  int mNMFTCandidates = 0;                                  ///< Number of MFT candidates within search cut
  bool mCloseMatch = false;                                 ///< Close match = correct MFT pair tested (MC-only)
  float mMFTMCH_MLScore = o2::constants::math::VeryBig;     ///< MCH-MFT Machine Learning Matching Score
  timeEst mTimeMUS;                                         ///< time estimate in ns

  ClassDefNV(MatchInfoFwd, 1);
};

} // namespace dataformats
} // namespace o2

#endif // ALICEO2_MATCH_INFO_MFTMCH_H
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.
#ifndef ALICEO2_BCRANGE_H
#define ALICEO2_BCRANGE_H

#include "CommonDataFormat/Pair.h"

namespace o2
{
namespace dataformats
{
// .............................................................................
struct bcRanges {

  using limits = o2::dataformats::Pair<uint64_t, uint64_t>;

  // members
  const char* mlistName;
  std::vector<limits> mbcRangesList;
  bool isSorted;
  bool isMerged;
  bool isExtended;

 public:
  // constructor
  bcRanges(const char* label)
  {
    mlistName = label;
    reset();
  }

  // reset list
  void reset()
  {
    isSorted = false;
    isMerged = false;
    isExtended = false;
    mbcRangesList.clear();
  }

  char status()
  {
    return isSorted * (1 << 0) + isMerged * (1 << 1) + isExtended * (1 << 2);
  }

  // return number of BC ranges in list
  auto size()
  {
    return mbcRangesList.size();
  }

  // add BC range
  void add(uint64_t first, uint64_t last)
  {
    mbcRangesList.push_back(limits(first, last));
    isSorted = false;
    isMerged = false;
    isExtended = false;
  }

  // sort mbcRangesList according to first entries
  void sort()
  {
    std::sort(mbcRangesList.begin(), mbcRangesList.end(), [](limits a, limits b) {
      return a.first < b.first;
    });
    isSorted = true;
  }

  // get number of BCs not included in ranges
  template <typename BCs>
  uint64_t getnNotCompBCs(BCs bcs)
  {
    // needs to be merged
    if (!isMerged) {
      merge();
    }

    // loop over ranges and count number of BCs not contained in a range
    uint64_t nNotCompBCs = 0;
    uint64_t ilast = 1, inext;
    for (auto iter = mbcRangesList.begin(); iter != mbcRangesList.end(); ++iter) {
      inext = iter->first;
      if (iter == mbcRangesList.begin()) {
        nNotCompBCs += (inext - ilast);
      } else {
        nNotCompBCs += (inext - ilast - 1);
      }
      ilast = iter->second;
    }
    auto bclast = bcs.rawIteratorAt(bcs.size());
    nNotCompBCs += (bclast.globalIndex() - ilast);
    LOGF(debug, "Number of BCs not in range of compatible BCs: %i", nNotCompBCs);

    return nNotCompBCs;
  }

  // merge overlaping ranges
  void merge(bool toForce = false)
  {
    // return if list of ranges is empty
    if (size() == 0) {
      return;
    }

    // is merging required?
    if (!isMerged || toForce) {
      std::vector<limits> tmpList;
      uint64_t ifirst = 0, ilast;

      // apply sorting of the ranges
      if (!isSorted) {
        sort();
      }

      // run over elements of mbcRangesList and merge lines where possible
      for (auto iter = mbcRangesList.begin(); iter != mbcRangesList.end(); ++iter) {
        if (iter == mbcRangesList.begin()) {
          ifirst = iter->first;
          ilast = iter->second;
          continue;
        }

        if (iter->first > (ilast + 1)) {
          // update tmpList
          tmpList.push_back(limits(ifirst, ilast));
          ifirst = iter->first;
          ilast = iter->second;
        } else {
          if (iter->second > ilast) {
            ilast = iter->second;
          }
        }
      }
      tmpList.push_back(limits(ifirst, ilast));

      mbcRangesList.clear();
      mbcRangesList = tmpList;
      isMerged = true;
    }
  }

  // add a factor fillFac of BCs not yet included in the BC ranges
  template <typename BCs>
  void compact(BCs bcs, Double_t fillFac, bool toForce = false)
  {
    if (!isExtended || toForce) {
      // apply merging of the ranges
      if (!isMerged || toForce) {
        merge(toForce);
      }

      // find out number of BCs not in a compatible range
      auto nBCs = bcs.size();
      auto nNotCompBCs = getnNotCompBCs(bcs);

      // keep adding BCs until the required number has been added
      auto nToAdd = (uint64_t)(nNotCompBCs * fillFac);

      // special case when list of ranges is empty
      if (size() == 0) {
        uint64_t ifirst = (nBCs - nToAdd) / 2;
        uint64_t ilast = ifirst + nToAdd - 1;
        add(ifirst, ilast);
      } else {
        int cnt = 0;
        while (nToAdd > 0) {
          // add BC at the beginning
          if (mbcRangesList[0].first > 1) {
            mbcRangesList[0].first--;
            nToAdd--;
          }

          // number of BCs to add in this round
          auto nr = size();
          if (nr > nToAdd) {
            nr = nToAdd;
          }

          // add BC after each range
          for (auto ii = 0; ii < nr; ii++) {
            if (mbcRangesList[ii].second < nBCs) {
              mbcRangesList[ii].second++;
              nToAdd--;
            }
          }
          merge(true);
        }
      }
      isExtended = true;
    }
  }

  // check if the value index is in a range
  // and return true if this is the case
  bool isInRange(uint64_t index)
  {
    // make sure that the list is merged
    merge(false);

    // find the range in which the value index falls
    auto range = std::find_if(mbcRangesList.begin(), mbcRangesList.end(), [index](limits a) {
      return (index >= a.first) && (index <= a.second);
    });
    return (range != mbcRangesList.end());
  }

  // get BC range
  auto operator[](int index)
  {
    return mbcRangesList[index];
  }
  auto begin()
  {
    return mbcRangesList.begin();
  }
  auto end()
  {
    return mbcRangesList.end();
  }

  // return list name
  auto name()
  {
    return mlistName;
  }

  // return the list
  auto list()
  {
    return mbcRangesList;
  }
};

// .............................................................................
} // namespace dataformats

} // namespace o2

#endif // ALICEO2__BCRANGE_H
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file MatchInfoHMP.h
/// \brief Class to store the output of the matching to HMPID

#ifndef ALICEO2_MATCHINFOHMP_H
#define ALICEO2_MATCHINFOHMP_H

#include "ReconstructionDataFormats/TrackLTIntegral.h"
#include "ReconstructionDataFormats/GlobalTrackID.h"
#include "CommonDataFormat/EvIndex.h"

namespace o2
{
namespace dataformats
{
class MatchInfoHMP
{
  using GTrackID = o2::dataformats::GlobalTrackID;

 public:
  MatchInfoHMP(int idxHMPClus, GTrackID idxTrack, float angle = 0, float q = 0, float size = 0, int idxPhotClus = 0) : mIdxHMPClus(idxHMPClus), mIdxTrack(idxTrack), mCkovAngle(angle), mMipCluQ(q), mMipCluSize(size), mIdxPhotClus(idxPhotClus){};
  MatchInfoHMP() = default;

  void setIdxHMPClus(int index) { mIdxHMPClus = index; }
  int getIdxHMPClus() const { return mIdxHMPClus; }

  void setIdxTrack(GTrackID index) { mIdxTrack = index; }
  GTrackID getTrackRef() const { return mIdxTrack; }

  int getTrackIndex() const { return mIdxTrack.getIndex(); }

  void setCkovAngle(float angle) { mCkovAngle = angle; }
  float getCkovAngle() const { return mCkovAngle; }

  void setMipClusQ(float q) { mMipCluQ = q; }
  float getMipClusQ() const { return mMipCluQ; }

  void setMipClusSize(int size) { mMipCluSize = size; }
  int getMipClusSize() const { return mMipCluSize; }

  void setNPhots(int n) { mNPhots = n; }
  int getNPhots() const { return mNPhots; }

  void setPhotIndex(int idx) { mIdxPhotClus = idx; }
  int getPhotIndex() const { return mIdxPhotClus; }

  void print() const;

 private:
  int mIdxHMPClus;       // Idx for HMP cluster
  GTrackID mIdxTrack;    // Idx for track
  float mCkovAngle;      // emission angle value
  float mMipCluQ = 0.0;  // MIP cluster charge
  int mMipCluSize = 0.0; // MIP cluster size
  int mNPhots = 0.0;     // number of candidate photo-electrons
  int mIdxPhotClus;      // index of the first photo

  ClassDefNV(MatchInfoHMP, 1);
};
} // namespace dataformats
} // namespace o2
#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

Error in <TInterpreter::AutoParse>: Error parsing payload code for class o2::math_utils::Rotation2D with content:

#line 1 "G__O2MathUtils dictionary payload"

#ifndef ZDC_FASTSIM_ONNX
  #define ZDC_FASTSIM_ONNX 1
#endif
#ifndef ENABLE_UPGRADES
  #define ENABLE_UPGRADES 1
#endif
#ifndef FMT_LOCALE
  #define FMT_LOCALE 1
#endif
#ifndef FMT_SHARED
  #define FMT_SHARED 1
#endif

#define _BACKWARD_BACKWARD_WARNING_H
// Inline headers
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Utils.h
/// \brief General auxilliary methods
/// \author ruben.shahoyan@cern.ch, michael.lettrich@cern.ch

#ifndef ALICEO2_COMMON_MATH_UTILS_
#define ALICEO2_COMMON_MATH_UTILS_

#include "MathUtils/detail/bitOps.h"
#include "MathUtils/detail/StatAccumulator.h"
#include "MathUtils/detail/trigonometric.h"
#include "MathUtils/detail/TypeTruncation.h"
#include "MathUtils/detail/basicMath.h"

namespace o2
{
namespace math_utils
{

GPUdi() float to02Pi(float phi)
{
  return detail::to02Pi<float>(phi);
}

GPUdi() double to02Pid(double phi)
{
  return detail::to02Pi<double>(phi);
}

GPUdi() void bringTo02Pi(float& phi)
{
  detail::bringTo02Pi<float>(phi);
}

GPUdi() void bringTo02Pid(double& phi)
{
  detail::bringTo02Pi<double>(phi);
}

inline float toPMPiGen(float phi)
{
  return detail::toPMPiGen<float>(phi);
}

inline double toPMPiGend(double phi)
{
  return detail::toPMPiGen<double>(phi);
}

inline void bringToPMPiGen(float& phi)
{
  detail::bringToPMPiGen<float>(phi);
}

inline void bringToPMPiGend(double& phi)
{
  detail::bringToPMPiGen<double>(phi);
}

inline float to02PiGen(float phi)
{
  return detail::to02PiGen<float>(phi);
}

inline double to02PiGend(double phi)
{
  return detail::to02PiGen<double>(phi);
}

inline void bringTo02PiGen(float& phi)
{
  detail::bringTo02PiGen<float>(phi);
}

inline void bringTo02PiGend(double& phi)
{
  detail::bringTo02PiGen<double>(phi);
}

inline float toPMPi(float phi)
{
  return detail::toPMPi<float>(phi);
}

inline double toPMPid(double phi)
{
  return detail::toPMPi<double>(phi);
}

inline void bringToPMPi(float& phi)
{
  return detail::bringToPMPi<float>(phi);
}

inline void bringToPMPid(double& phi)
{
  return detail::bringToPMPi<double>(phi);
}

GPUdi() void sincos(float ang, float& s, float& c)
{
  detail::sincos<float>(ang, s, c);
}
#ifndef __OPENCL__
GPUdi() void sincosd(double ang, double& s, double& c)
{
  detail::sincos<double>(ang, s, c);
}
#endif

GPUdi() void rotateZ(float xL, float yL, float& xG, float& yG, float snAlp, float csAlp)
{
  return detail::rotateZ<float>(xL, yL, xG, yG, snAlp, csAlp);
}

GPUdi() void rotateZd(double xL, double yL, double& xG, double& yG, double snAlp, double csAlp)
{
  return detail::rotateZ<double>(xL, yL, xG, yG, snAlp, csAlp);
}

#ifndef GPUCA_GPUCODE_DEVICE
inline void rotateZInv(float xG, float yG, float& xL, float& yL, float snAlp, float csAlp)
{
  detail::rotateZInv<float>(xG, yG, xL, yL, snAlp, csAlp);
}

inline void rotateZInvd(double xG, double yG, double& xL, double& yL, double snAlp, double csAlp)
{
  detail::rotateZInv<double>(xG, yG, xL, yL, snAlp, csAlp);
}

inline std::tuple<float, float> rotateZInv(float xG, float yG, float snAlp, float csAlp)
{
  return detail::rotateZInv<float>(xG, yG, snAlp, csAlp);
}

inline std::tuple<double, double> rotateZInvd(double xG, double yG, double snAlp, double csAlp)
{
  return detail::rotateZInv<double>(xG, yG, snAlp, csAlp);
}

GPUdi() std::tuple<float, float> sincos(float ang)
{
  return detail::sincos<float>(ang);
}

GPUdi() std::tuple<double, double> sincosd(double ang)
{
  return detail::sincos<double>(ang);
}

inline std::tuple<float, float> rotateZ(float xL, float yL, float snAlp, float csAlp)
{
  return detail::rotateZ<float>(xL, yL, snAlp, csAlp);
}

inline std::tuple<double, double> rotateZd(double xL, double yL, double snAlp, double csAlp)
{
  return detail::rotateZ<double>(xL, yL, snAlp, csAlp);
}

inline void rotateZ(std::array<float, 3>& xy, float alpha)
{
  detail::rotateZ<float>(xy, alpha);
}

inline void rotateZd(std::array<double, 3>& xy, double alpha)
{
  detail::rotateZ<double>(xy, alpha);
}
#endif

inline int angle2Sector(float phi)
{
  return detail::angle2Sector<float>(phi);
}

inline int angle2Sectord(double phi)
{
  return detail::angle2Sector<double>(phi);
}

inline float sector2Angle(int sect)
{
  return detail::sector2Angle<float>(sect);
}

inline double sector2Angled(int sect)
{
  return detail::sector2Angle<double>(sect);
}

inline float angle2Alpha(float phi)
{
  return detail::angle2Alpha<float>(phi);
}

inline double angle2Alphad(double phi)
{
  return detail::angle2Alpha<double>(phi);
}

GPUhdi() float fastATan2(float y, float x)
{
  return detail::fastATan2<float>(y, x);
}

GPUhdi() double fastATan2d(double y, double x)
{
  return detail::fastATan2<double>(y, x);
}

template <class T>
GPUhdi() T min(const T x, const T y)
{
  return detail::min<T>(x, y);
};

GPUhdi() double mind(const double x, const double y)
{
  return detail::min<double>(x, y);
};

template <class T>
GPUhdi() T max(const T x, const T y)
{
  return detail::max<T>(x, y);
};

GPUhdi() double maxd(const double x, const double y)
{
  return detail::max<double>(x, y);
};

GPUhdi() float sqrt(float x)
{
  return detail::sqrt<float>(x);
};

GPUhdi() double sqrtd(double x)
{
  return detail::sqrt<double>(x);
};

GPUhdi() float abs(float x)
{
  return detail::abs<float>(x);
};

GPUhdi() double absd(double x)
{
  return detail::abs<double>(x);
};

GPUdi() float asin(float x)
{
  return detail::asin<float>(x);
};

GPUdi() double asind(double x)
{
  return detail::asin<double>(x);
};

GPUdi() float atan(float x)
{
  return detail::atan<float>(x);
};

GPUdi() double atand(double x)
{
  return detail::atan<double>(x);
};

GPUdi() float atan2(float y, float x)
{
  return detail::atan2<float>(y, x);
};

GPUdi() double atan2d(double y, double x)
{
  return detail::atan2<double>(y, x);
};

GPUdi() float sin(float x)
{
  return detail::sin<float>(x);
};

GPUdi() double sind(double x)
{
  return detail::sin<double>(x);
};

GPUdi() float cos(float x)
{
  return detail::cos<float>(x);
};

GPUdi() double cosd(double x)
{
  return detail::cos<double>(x);
};

GPUdi() float tan(float x)
{
  return detail::tan<float>(x);
};

GPUdi() double tand(double x)
{
  return detail::tan<double>(x);
};

GPUdi() float twoPi()
{
  return detail::twoPi<float>();
};

GPUdi() double twoPid()
{
  return detail::twoPi<double>();
};

GPUdi() float pi()
{
  return detail::pi<float>();
}

GPUdi() double pid()
{
  return detail::pi<double>();
}

GPUdi() int nint(float x)
{
  return detail::nint<float>(x);
};

GPUdi() int nintd(double x)
{
  return detail::nint<double>(x);
};

GPUdi() bool finite(float x)
{
  return detail::finite<float>(x);
}

GPUdi() bool finited(double x)
{
  return detail::finite<double>(x);
}

GPUdi() unsigned int clz(unsigned int val)
{
  return detail::clz(val);
};

GPUdi() unsigned int popcount(unsigned int val)
{
  return detail::popcount(val);
};

GPUdi() float log(float x)
{
  return detail::log<float>(x);
};

GPUdi() double logd(double x)
{
  return detail::log<double>(x);
};

using detail::StatAccumulator;

using detail::bit2Mask;
using detail::numberOfBitsSet;
using detail::truncateFloatFraction;

} // namespace math_utils
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Cheb3D.h
/// \brief Definition of the Cheb3D class
/// \author ruben.shahoyan@cern.ch 09/09/2006

#ifndef ALICEO2_MATHUTILS_CHEBYSHEV3D_H_
#define ALICEO2_MATHUTILS_CHEBYSHEV3D_H_

#include <TNamed.h>                    // for TNamed
#include <TObjArray.h>                 // for TObjArray
#include <cstdio>                      // for FILE, stdout
#include "MathUtils/Chebyshev3DCalc.h" // for Chebyshev3DCalc, etc
#include "Rtypes.h"                    // for Float_t, Int_t, Double_t, Bool_t, etc
#include "TString.h"                   // for TString

class TH1;         // lines 15-15
class TMethodCall; // lines 16-16

namespace o2
{
namespace math_utils
{

/// Chebyshev3D produces the interpolation of the user 3D->NDimOut arbitrary function supplied in
/// "void (*fcn)(float* inp,float* out)" format either in a separate macro file or as a function pointer. Only
/// coefficients needed to guarantee the requested precision are kept. The user-callable methods are:
/// To create the interpolation use:
/// Cheb3D(const char* funName, // name of the file with user function or
/// Cheb3D(void (*ptr)(float*,float*) // pointer on the  user function
/// \param Int_t DimOut dimensionality of the function's output
/// \param Float_t *bmin lower 3D bounds of interpolation domain
/// \param Float_t *bmax upper 3D bounds of interpolation domain
/// \param Int_t *npoints number of points in each of 3 input dimension, defining the interpolation grid
/// \param Float_t prec=1E-6); requested max.absolute difference between the interpolation and any point on grid
/// To test obtained parameterization use the method TH1* TestRMS(int idim,int npoints = 1000,TH1* histo=0);
/// it will compare the user output of the user function and interpolation for idim-th output dimension and
/// fill the difference in the supplied histogram. If no histogram is supplied, it will be created.
/// To save the interpolation data: saveData(const char* filename, Bool_t append ) write text file with data.
/// If append is kTRUE and the output file already exists, data will be added in the end of the file.
/// Alternatively, saveData(FILE* stream) will write the data to already existing stream.
/// To read back already stored interpolation use either the constructor Chebyshev3D(const char* inpFile);
/// or the default constructor Chebyshev3D() followed by Chebyshev3D::loadData(const char* inpFile);
/// To compute the interpolation use Eval(float* par,float *res) method, with par being 3D vector of arguments
/// (inside the validity region) and res is the array of DimOut elements for the output.
/// If only one component (say, idim-th) of the output is needed, use faster Float_t Eval(Float_t *par,int idim) method
/// void Print(option="") will print the name, the ranges of validity and the absolute precision of the
/// parameterization. Option "l" will also print the information about the number of coefficients for each output
/// dimension.
/// NOTE: during the evaluation no check is done for parameter vector being outside the interpolation region.
/// If there is such a risk, use Bool_t isInside(float *par) method. Chebyshev parameterization is not
/// good for extrapolation!
/// For the properties of Chebyshev parameterization see:
/// H.Wind, CERN EP Internal Report, 81-12/Rev.
class Chebyshev3D : public TNamed
{
 public:
  Chebyshev3D();

  Chebyshev3D(const Chebyshev3D& src);

  Chebyshev3D(const char* inpFile);

  Chebyshev3D(FILE* stream);

#ifdef _INC_CREATION_Chebyshev3D_
  /// Construct the parameterization for the function
  /// \param funName : name of the file containing the function: void funName(Float_t * inp,Float_t * out)
  /// \param DimOut  : dimension of the vector computed by the user function
  /// \param bmin    : array of 3 elements with the lower boundaries of the region where the function is defined
  /// \param bmax    : array of 3 elements with the upper boundaries of the region where the function is defined
  /// \param npoints : array of 3 elements with the number of points to compute in each of 3 dimension
  /// \param prec    : max allowed absolute difference between the user function and computed parameterization on the
  /// requested grid, common for all 1D components
  /// \param precD   : optional precison per component
  Chebyshev3D(const char* funName, Int_t dimOut, const Float_t* bmin, const Float_t* bmax, const Int_t* npoints,
              Float_t prec = 1E-6, const Float_t* precD = nullptr);
  /// Construct the parameterization for the function
  /// \param ptr     : pointer on the function: void fun(Float_t * inp,Float_t * out)
  /// \param DimOut  : dimension of the vector computed by the user function
  /// \param bmin    : array of 3 elements with the lower boundaries of the region where the function is defined
  /// \param bmax    : array of 3 elements with the upper boundaries of the region where the function is defined
  /// \param npoints : array of 3 elements with the number of points to compute in each of 3 dimension
  /// \param prec    : max allowed absolute difference between the user function and computed parameterization on the
  /// requested grid, common for all 1D components
  /// \param precD   : optional precison per component
  Chebyshev3D(void (*ptr)(float*, float*), Int_t dimOut, const Float_t* bmin, const Float_t* bmax, const Int_t* npoints,
              Float_t prec = 1E-6, const Float_t* precD = nullptr);
  /// Construct very economic  parameterization for the function
  /// \param ptr     : pointer on the function: void fun(Float_t * inp,Float_t * out)
  /// \param DimOut  : dimension of the vector computed by the user function
  /// \param bmin    : array of 3 elements with the lower boundaries of the region where the function is defined
  /// \param bmax    : array of 3 elements with the upper boundaries of the region where the function is defined
  /// \param npX     : array of 3 elements with the number of points to compute in each dimension for 1st component
  /// \param npY     : array of 3 elements with the number of points to compute in each dimension for 2nd component
  /// \param npZ     : array of 3 elements with the number of points to compute in each dimension for 3d  component
  /// \param prec    : max allowed absolute difference between the user function and computed parameterization on the
  /// requested grid, common for all 1D components
  /// \param precD   : optional precison per component
  Chebyshev3D(void (*ptr)(float*, float*), int dimOut, const Float_t* bmin, const Float_t* bmax,
              const Int_t* npX, const Int_t* npY, const Int_t* npZ,
              Float_t prec = 1E-6, const Float_t* precD = nullptr);
  /// Construct very economic  parameterization for the function with automatic calculation of the root's grid
  /// \param ptr     : pointer on the function: void fun(Float_t * inp,Float_t * out)
  /// \param DimOut  : dimension of the vector computed by the user function
  /// \param bmin    : array of 3 elements with the lower boundaries of the region where the function is defined
  /// \param bmax    : array of 3 elements with the upper boundaries of the region where the function is defined
  /// \param prec    : max allowed absolute difference between the user function and computed parameterization on the
  /// \param requested grid, common for all 1D components
  /// \param precD   : optional precison per component
  Chebyshev3D(void (*ptr)(float*, float*), int DimOut, const Float_t* bmin, const Float_t* bmax, Float_t prec = 1E-6,
              Bool_t run = kTRUE, const Float_t* precD = nullptr);
#endif

  ~Chebyshev3D() override
  {
    Clear();
  }

  Chebyshev3D& operator=(const Chebyshev3D& rhs);

  void Eval(const Float_t* par, Float_t* res);

  Float_t Eval(const Float_t* par, int idim);

  void Eval(const Double_t* par, Double_t* res);

  Double_t Eval(const Double_t* par, int idim);

  void evaluateDerivative(int dimd, const Float_t* par, Float_t* res);

  void evaluateDerivative2(int dimd1, int dimd2, const Float_t* par, Float_t* res);

  Float_t evaluateDerivative(int dimd, const Float_t* par, int idim);

  Float_t evaluateDerivative2(int dimd1, int dimd2, const Float_t* par, int idim);

  void evaluateDerivative3D(const Float_t* par, Float_t dbdr[3][3]);

  void evaluateDerivative3D2(const Float_t* par, Float_t dbdrdr[3][3][3]);

  void Print(const Option_t* opt = "") const override;

  Bool_t isInside(const Float_t* par) const;

  Bool_t isInside(const Double_t* par) const;

  Chebyshev3DCalc* getChebyshevCalc(int i) const
  {
    return (Chebyshev3DCalc*)mChebyshevParameter.UncheckedAt(i);
  }

  Float_t getBoundMin(int i) const
  {
    return mMinBoundaries[i];
  }

  Float_t getBoundMax(int i) const
  {
    return mMaxBoundaries[i];
  }

  Float_t* getBoundMin() const
  {
    return (float*)mMinBoundaries;
  }

  Float_t* getBoundMax() const
  {
    return (float*)mMaxBoundaries;
  }

  Float_t* getBoundaryMappingScale() const
  {
    return (float*)mBoundaryMappingScale;
  }

  Float_t* getBoundaryMappingOffset() const
  {
    return (float*)mBoundaryMappingOffset;
  }

  Float_t getPrecision() const
  {
    return mPrecision;
  }

  void shiftBound(int id, float dif);

  void loadData(const char* inpFile);

  void loadData(FILE* stream);

#ifdef _INC_CREATION_Chebyshev3D_
  void invertSign();
  int* getNcNeeded(float xyz[3], int dimVar, float mn, float mx, float prec, Int_t npCheck = 30);
  void estimateNumberOfPoints(float prec, int gridBC[3][3], Int_t npd1 = 30, Int_t npd2 = 30, Int_t npd3 = 30);
  void saveData(const char* outfile, Bool_t append = kFALSE) const;
  void saveData(FILE* stream = stdout) const;

  void setuserFunction(const char* name);
  void setuserFunction(void (*ptr)(float*, float*));
  void evaluateUserFunction(const Float_t* x, Float_t* res);
  TH1* TestRMS(int idim, int npoints = 1000, TH1* histo = nullptr);
  static Int_t calculateChebyshevCoefficients(const Float_t* funval, int np, Float_t* outCoefs, Float_t prec = -1);
#endif

 protected:
  void Clear(const Option_t* option = "") override;

  void setDimOut(const int d, const float* prec = nullptr);

  void prepareBoundaries(const Float_t* bmin, const Float_t* bmax);

#ifdef _INC_CREATION_Chebyshev3D_
  void evaluateUserFunction();
  void defineGrid(const Int_t* npoints);
  Int_t chebyshevFit(); // fit all output dimensions
  Int_t chebyshevFit(int dmOut);
  void setPrecision(float prec)
  {
    mPrecision = prec;
  }
#endif

  Float_t mapToInternal(Float_t x, Int_t d) const; // map x to [-1:1]
  Float_t mapToExternal(Float_t x, Int_t d) const
  {
    return x / mBoundaryMappingScale[d] + mBoundaryMappingOffset[d];
  }                                                  // map from [-1:1] to x
  Double_t mapToInternal(Double_t x, Int_t d) const; // map x to [-1:1]
  Double_t mapToExternal(Double_t x, Int_t d) const
  {
    return x / mBoundaryMappingScale[d] + mBoundaryMappingOffset[d];
  } // map from [-1:1] to x

 private:
  Int_t mOutputArrayDimension;       ///< dimension of the ouput array
  Float_t mPrecision;                ///< requested precision
  Float_t mMinBoundaries[3];         ///< min boundaries in each dimension
  Float_t mMaxBoundaries[3];         ///< max boundaries in each dimension
  Float_t mBoundaryMappingScale[3];  ///< scale for boundary mapping to [-1:1] interval
  Float_t mBoundaryMappingOffset[3]; ///< offset for boundary mapping to [-1:1] interval
  TObjArray mChebyshevParameter;     ///< Chebyshev parameterization for each output dimension

  Int_t mMaxCoefficients;               //! max possible number of coefs per parameterization
  Int_t mNumberOfPoints[3];             //! number of used points in each dimension
  Float_t mTemporaryCoefficient[3];     //! temporary vector for coefs calculation
  Float_t* mTemporaryUserResults;       //! temporary vector for results of user function calculation
  Float_t* mTemporaryChebyshevGrid;     //! temporary buffer for Chebyshef roots grid
  Int_t mTemporaryChebyshevGridOffs[3]; //! start of grid for each dimension
  TString mUserFunctionName;            //! name of user macro containing the function of  "void (*fcn)(float*,float*)" format
  TMethodCall* mUserMacro;              //! Pointer to MethodCall for function from user macro

  static const Float_t sMinimumPrecision; ///< minimum precision allowed

  ClassDefOverride(o2::math_utils::Chebyshev3D,
                   2) // Chebyshev parametrization for 3D->N function
};

/// Checks if the point is inside of the fitted box
inline Bool_t Chebyshev3D::isInside(const Float_t* par) const
{
  for (int i = 3; i--;) {
    if (mMinBoundaries[i] > par[i] || par[i] > mMaxBoundaries[i]) {
      return kFALSE;
    }
  }
  return kTRUE;
}

/// Checks if the point is inside of the fitted box
inline Bool_t Chebyshev3D::isInside(const Double_t* par) const
{
  for (int i = 3; i--;) {
    if (mMinBoundaries[i] > par[i] || par[i] > mMaxBoundaries[i]) {
      return kFALSE;
    }
  }
  return kTRUE;
}

/// Evaluates Chebyshev parameterization for 3d->DimOut function
inline void Chebyshev3D::Eval(const Float_t* par, Float_t* res)
{
  for (int i = 3; i--;) {
    mTemporaryCoefficient[i] = mapToInternal(par[i], i);
  }
  for (int i = mOutputArrayDimension; i--;) {
    res[i] = getChebyshevCalc(i)->Eval(mTemporaryCoefficient);
  }
}

/// Evaluates Chebyshev parameterization for 3d->DimOut function
inline void Chebyshev3D::Eval(const Double_t* par, Double_t* res)
{
  for (int i = 3; i--;) {
    mTemporaryCoefficient[i] = mapToInternal(par[i], i);
  }
  for (int i = mOutputArrayDimension; i--;) {
    res[i] = getChebyshevCalc(i)->Eval(mTemporaryCoefficient);
  }
}

/// Evaluates Chebyshev parameterization for idim-th output dimension of 3d->DimOut function
inline Double_t Chebyshev3D::Eval(const Double_t* par, int idim)
{
  for (int i = 3; i--;) {
    mTemporaryCoefficient[i] = mapToInternal(par[i], i);
  }
  return getChebyshevCalc(idim)->Eval(mTemporaryCoefficient);
}

/// Evaluates Chebyshev parameterization for idim-th output dimension of 3d->DimOut function
inline Float_t Chebyshev3D::Eval(const Float_t* par, int idim)
{
  for (int i = 3; i--;) {
    mTemporaryCoefficient[i] = mapToInternal(par[i], i);
  }
  return getChebyshevCalc(idim)->Eval(mTemporaryCoefficient);
}

/// Returns the gradient matrix
inline void Chebyshev3D::evaluateDerivative3D(const Float_t* par, Float_t dbdr[3][3])
{
  for (int i = 3; i--;) {
    mTemporaryCoefficient[i] = mapToInternal(par[i], i);
  }
  for (int ib = 3; ib--;) {
    for (int id = 3; id--;) {
      dbdr[ib][id] = getChebyshevCalc(ib)->evaluateDerivative(id, mTemporaryCoefficient) * mBoundaryMappingScale[id];
    }
  }
}

/// Returns the gradient matrix
inline void Chebyshev3D::evaluateDerivative3D2(const Float_t* par, Float_t dbdrdr[3][3][3])
{
  for (int i = 3; i--;) {
    mTemporaryCoefficient[i] = mapToInternal(par[i], i);
  }
  for (int ib = 3; ib--;) {
    for (int id = 3; id--;) {
      for (int id1 = 3; id1--;) {
        dbdrdr[ib][id][id1] = getChebyshevCalc(ib)->evaluateDerivative2(id, id1, mTemporaryCoefficient) *
                              mBoundaryMappingScale[id] * mBoundaryMappingScale[id1];
      }
    }
  }
}

// Evaluates Chebyshev parameterization derivative for 3d->DimOut function
inline void Chebyshev3D::evaluateDerivative(int dimd, const Float_t* par, Float_t* res)
{
  for (int i = 3; i--;) {
    mTemporaryCoefficient[i] = mapToInternal(par[i], i);
  }
  for (int i = mOutputArrayDimension; i--;) {
    res[i] = getChebyshevCalc(i)->evaluateDerivative(dimd, mTemporaryCoefficient) * mBoundaryMappingScale[dimd];
  };
}

// Evaluates Chebyshev parameterization 2nd derivative over dimd1 and dimd2 dimensions for 3d->DimOut function
inline void Chebyshev3D::evaluateDerivative2(int dimd1, int dimd2, const Float_t* par, Float_t* res)
{
  for (int i = 3; i--;) {
    mTemporaryCoefficient[i] = mapToInternal(par[i], i);
  }
  for (int i = mOutputArrayDimension; i--;) {
    res[i] = getChebyshevCalc(i)->evaluateDerivative2(dimd1, dimd2, mTemporaryCoefficient) *
             mBoundaryMappingScale[dimd1] * mBoundaryMappingScale[dimd2];
  }
}

/// Evaluates Chebyshev parameterization derivative over dimd dimention for idim-th output dimension of 3d->DimOut
/// function
inline Float_t Chebyshev3D::evaluateDerivative(int dimd, const Float_t* par, int idim)
{
  for (int i = 3; i--;) {
    mTemporaryCoefficient[i] = mapToInternal(par[i], i);
  }
  return getChebyshevCalc(idim)->evaluateDerivative(dimd, mTemporaryCoefficient) * mBoundaryMappingScale[dimd];
}

/// Evaluates Chebyshev parameterization 2ns derivative over dimd1 and dimd2 dimensions for idim-th output dimension of
/// 3d->DimOut function
inline Float_t Chebyshev3D::evaluateDerivative2(int dimd1, int dimd2, const Float_t* par, int idim)
{
  for (int i = 3; i--;) {
    mTemporaryCoefficient[i] = mapToInternal(par[i], i);
  }
  return getChebyshevCalc(idim)->evaluateDerivative2(dimd1, dimd2, mTemporaryCoefficient) *
         mBoundaryMappingScale[dimd1] * mBoundaryMappingScale[dimd2];
}

/// Μaps x to [-1:1]
inline Float_t Chebyshev3D::mapToInternal(Float_t x, Int_t d) const
{
#ifdef _BRING_TO_BOUNDARY_
  T res = (x - mBoundaryMappingOffset[d]) * mBoundaryMappingScale[d];
  if (res < -1) {
    return -1;
  }
  if (res > 1) {
    return 1;
  }
  return res;
#else
  return (x - mBoundaryMappingOffset[d]) * mBoundaryMappingScale[d];
#endif
}

/// Μaps x to [-1:1]
inline Double_t Chebyshev3D::mapToInternal(Double_t x, Int_t d) const
{
#ifdef _BRING_TO_BOUNDARY_
  T res = (x - mBoundaryMappingOffset[d]) * mBoundaryMappingScale[d];
  if (res < -1) {
    return -1;
  }
  if (res > 1) {
    return 1;
  }
  return res;
#else
  return (x - mBoundaryMappingOffset[d]) * mBoundaryMappingScale[d];
#endif
}
} // namespace math_utils
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Cheb3DCalc.h
/// \brief Definition of the Cheb3DCalc class
/// \author ruben.shahoyan@cern.ch 09/09/2006

#ifndef ALICEO2_MATHUTILS_CHEBYSHEV3DCALC_H_
#define ALICEO2_MATHUTILS_CHEBYSHEV3DCALC_H_

#include <TNamed.h> // for TNamed
#include <cstdio>   // for FILE, stdout
#include "Rtypes.h" // for Float_t, UShort_t, Int_t, Double_t, etc

class TString;

// To decrease the compilable code size comment this define. This will exclude the routines
// used for the calculation and saving of the coefficients.
#define _INC_CREATION_Chebyshev3D_

// When _BRING_TO_BOUNDARY_ is defined, the point outside of the fitted folume is assumed to be on the surface
// #define _BRING_TO_BOUNDARY_

namespace o2
{
namespace math_utils
{
class Chebyshev3DCalc : public TNamed
{

 public:
  /// Default constructor
  Chebyshev3DCalc();

  /// Copy constructor
  Chebyshev3DCalc(const Chebyshev3DCalc& src);

  /// Constructor from coefficients stream
  Chebyshev3DCalc(FILE* stream);

  /// Default destructor
  ~Chebyshev3DCalc() override
  {
    Clear();
  }

  /// Assignment operator
  Chebyshev3DCalc& operator=(const Chebyshev3DCalc& rhs);

  /// Prints info
  void Print(const Option_t* opt = "") const override;

  /// Loads coefficients from the stream
  void loadData(FILE* stream);

  /// Evaluates Chebyshev parameterization derivative in given dimension for 3D function.
  /// VERY IMPORTANT: par must contain the function arguments ALREADY MAPPED to [-1:1] interval
  Float_t evaluateDerivative(int dim, const Float_t* par) const;

  /// Evaluates Chebyshev parameterization 2n derivative in given dimensions  for 3D function.
  /// VERY IMPORTANT: par must contain the function arguments ALREADY MAPPED to [-1:1] interval
  Float_t evaluateDerivative2(int dim1, int dim2, const Float_t* par) const;

#ifdef _INC_CREATION_Chebyshev3D_

  /// Writes coefficients data to output text file, optionally appending on the end of existing file
  void saveData(const char* outfile, Bool_t append = kFALSE) const;

  // Writes coefficients data to existing output stream
  // Note: mNumberOfColumns, mNumberOfElementsBound2D and mColumnAtRowBeginning are not stored, will be computed on fly
  // during the loading of this file
  void saveData(FILE* stream = stdout) const;

#endif

  /// Sets maximum number of significant rows in the coefficients matrix
  void initializeRows(int nr);

  /// Sets maximum number of significant columns in the coefficients matrix
  void initializeColumns(int nc);

  Int_t getNumberOfCoefficients() const
  {
    return mNumberOfCoefficients;
  }

  Int_t getNumberOfColumns() const
  {
    return (Int_t)mNumberOfColumns;
  }

  Int_t getNumberOfRows() const
  {
    return (Int_t)mNumberOfRows;
  }

  Int_t getNumberOfElementsBound2D() const
  {
    return (Int_t)mNumberOfElementsBound2D;
  }

  Int_t getMaxColumnsAtRow() const;

  UShort_t* getNumberOfColumnsAtRow() const
  {
    return mNumberOfColumnsAtRow;
  }

  UShort_t* getColAtRowBg() const
  {
    return mColumnAtRowBeginning;
  }

  Float_t getPrecision() const
  {
    return mPrecision;
  }

  /// Sets requested precision
  void setPrecision(Float_t prc = 1e-6)
  {
    mPrecision = prc;
  }

  /// Sets maximum number of significant coefficients for given row/column of coefficients 3D matrix
  void initializeElementBound2D(int ne);

  UShort_t* getCoefficientBound2D0() const
  {
    return mCoefficientBound2D0;
  }

  UShort_t* getCoefficientBound2D1() const
  {
    return mCoefficientBound2D1;
  }

  /// Deletes all dynamically allocated structures
  void Clear(const Option_t* option = "") override;

  static Float_t chebyshevEvaluation1D(Float_t x, const Float_t* array, int ncf);

  /// Evaluates 1D Chebyshev parameterization's derivative. x is the argument mapped to [-1:1] interval
  static Float_t chebyshevEvaluation1Derivative(Float_t x, const Float_t* array, int ncf);

  /// Evaluates 1D Chebyshev parameterization's 2nd derivative. x is the argument mapped to [-1:1] interval
  static Float_t chebyshevEvaluation1Derivative2(Float_t x, const Float_t* array, int ncf);

  /// Sets total number of significant coefficients
  void initializeCoefficients(int nc);

  Float_t* getCoefficients() const
  {
    return mCoefficients;
  }

  /// Reads single line from the stream, skipping empty and commented lines. EOF is not expected
  static void readLine(TString& str, FILE* stream);

  Float_t Eval(const Float_t* par) const;

  Double_t Eval(const Double_t* par) const;

 private:
  Int_t mNumberOfCoefficients;    ///< total number of coeeficients
  Int_t mNumberOfRows;            ///< number of significant rows in the 3D coeffs matrix
  Int_t mNumberOfColumns;         ///< max number of significant cols in the 3D coeffs matrix
  Int_t mNumberOfElementsBound2D; ///< number of elements (mNumberOfRows*mNumberOfColumns) to store for the 2D boundary
  Float_t mPrecision;             ///< requested precision
  /// of significant coeffs
  UShort_t*
    mNumberOfColumnsAtRow;         //[mNumberOfRows] number of sighificant columns (2nd dim) at each row of 3D coefs matrix
  UShort_t* mColumnAtRowBeginning; //[mNumberOfRows] beginning of significant columns (2nd dim) for row in the 2D
  // boundary matrix
  UShort_t* mCoefficientBound2D0; //[mNumberOfElementsBound2D] 2D matrix defining the boundary of significance for 3D
  // coeffs.matrix
  //(Ncoefs for col/row)
  UShort_t* mCoefficientBound2D1; //[mNumberOfElementsBound2D] 2D matrix defining the start beginning of significant
  // coeffs for col/row
  Float_t* mCoefficients; //[mNumberOfCoefficients] array of Chebyshev coefficients

  Float_t* mTemporaryCoefficients2D; //[mNumberOfColumns] temp. coeffs for 2d summation
  Float_t* mTemporaryCoefficients1D; //[mNumberOfRows] temp. coeffs for 1d summation

  ClassDefOverride(o2::math_utils::Chebyshev3DCalc,
                   2) // Class for interpolation of 3D->1 function by Chebyshev parametrization
};

/// Evaluates 1D Chebyshev parameterization. x is the argument mapped to [-1:1] interval
inline Float_t Chebyshev3DCalc::chebyshevEvaluation1D(Float_t x, const Float_t* array, int ncf)
{
  if (ncf <= 0) {
    return 0;
  }

  Float_t b0, b1, b2, x2 = x + x;
  b0 = array[--ncf];
  b1 = b2 = 0;

  for (int i = ncf; i--;) {
    b2 = b1;
    b1 = b0;
    b0 = array[i] + x2 * b1 - b2;
  }
  return b0 - x * b1;
}

/// Evaluates Chebyshev parameterization for 3D function.
/// VERY IMPORTANT: par must contain the function arguments ALREADY MAPPED to [-1:1] interval
inline Float_t Chebyshev3DCalc::Eval(const Float_t* par) const
{
  for (int id0 = mNumberOfRows; id0--;) {
    int nCLoc = mNumberOfColumnsAtRow[id0]; // number of significant coefs on this row
    int col0 = mColumnAtRowBeginning[id0];  // beginning of local column in the 2D boundary matrix
    for (int id1 = nCLoc; id1--;) {
      int id = id1 + col0;
      mTemporaryCoefficients2D[id1] = chebyshevEvaluation1D(par[2], mCoefficients + mCoefficientBound2D1[id], mCoefficientBound2D0[id]);
    }
    mTemporaryCoefficients1D[id0] = chebyshevEvaluation1D(par[1], mTemporaryCoefficients2D, nCLoc);
  }
  return chebyshevEvaluation1D(par[0], mTemporaryCoefficients1D, mNumberOfRows);
}

/// Evaluates Chebyshev parameterization for 3D function.
/// VERY IMPORTANT: par must contain the function arguments ALREADY MAPPED to [-1:1] interval
inline Double_t Chebyshev3DCalc::Eval(const Double_t* par) const
{
  for (int id0 = mNumberOfRows; id0--;) {
    int nCLoc = mNumberOfColumnsAtRow[id0]; // number of significant coefs on this row
    int col0 = mColumnAtRowBeginning[id0];  // beginning of local column in the 2D boundary matrix
    for (int id1 = nCLoc; id1--;) {
      int id = id1 + col0;
      mTemporaryCoefficients2D[id1] = chebyshevEvaluation1D(par[2], mCoefficients + mCoefficientBound2D1[id], mCoefficientBound2D0[id]);
    }
    mTemporaryCoefficients1D[id0] = chebyshevEvaluation1D(par[1], mTemporaryCoefficients2D, nCLoc);
  }
  return chebyshevEvaluation1D(par[0], mTemporaryCoefficients1D, mNumberOfRows);
}
} // namespace math_utils
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

#ifndef ALICEO2_MATHUTILS_MATHBASE_H_
#define ALICEO2_MATHUTILS_MATHBASE_H_

/// \file   MathBase.h
/// \author Jens Wiechula, Jens.Wiechula@ikf.uni-frankfurt.de

#include <cmath>
#include <numeric>
#include <algorithm>
#include <vector>
#include <array>

#include "Rtypes.h"
#include "TLinearFitter.h"
#include "TVectorD.h"
#include "TMath.h"
#include "TF1.h"
#include "Foption.h"
#include "HFitInterface.h"
#include "TFitResultPtr.h"
#include "TFitResult.h"
#include "Fit/Fitter.h"
#include "Fit/BinData.h"
#include "Math/WrappedMultiTF1.h"
#include <Math/SMatrix.h>
#include <Math/SVector.h>
#include "Framework/Logger.h"

namespace o2
{
namespace math_utils
{
/// fit 1D array of histogrammed data with generic root function
///
/// The code was extracted out of ROOT to be able to do fitting on an array with histogrammed data
/// instead of root histograms.
/// It is a stripped down version, so does not provide the same functionality.
/// To be used with care.
///
/// \param[in]  nbins size of the array and number of histogram bins
/// \param[in]  arr   array with elements
/// \param[in]  xMin  minimum range of the array
/// \param[in]  xMax  maximum range of the array
/// \param[in] func fit function
///
///
template <typename T>
TFitResultPtr fit(const size_t nBins, const T* arr, const T xMin, const T xMax, TF1& func, std::string_view option = "")
{
  Foption_t fitOption;
  ROOT::Fit::FitOptionsMake(ROOT::Fit::kHistogram, option.data(), fitOption);

  ROOT::Fit::DataRange range(xMin, xMax);
  ROOT::Fit::DataOptions opt;
  ROOT::Fit::BinData fitdata(opt, range);
  fitdata.Initialize(nBins, 1);

  // create an empty TFitResult
  std::shared_ptr<TFitResult> tfr(new TFitResult());
  // create the fitter from an empty fit result
  //std::shared_ptr<ROOT::Fit::Fitter> fitter(new ROOT::Fit::Fitter(std::static_pointer_cast<ROOT::Fit::FitResult>(tfr) ) );
  ROOT::Fit::Fitter fitter(tfr);
  //ROOT::Fit::FitConfig & fitConfig = fitter->Config();

  const double binWidth = double(xMax - xMin) / double(nBins);

  for (Int_t ibin = 0; ibin < nBins; ibin++) {
    const double x = double(xMin) + double(ibin + 0.5) * binWidth;
    const double y = double(arr[ibin]);
    const double ey = std::sqrt(y);
    fitdata.Add(x, y, ey);
  }

  const int special = func.GetNumber();
  const int npar = func.GetNpar();
  bool linear = func.IsLinear();
  if (special == 299 + npar) {
    linear = kTRUE; // for polynomial functions
  }
  // do not use linear fitter in these case
  if (fitOption.Bound || fitOption.Like || fitOption.Errors || fitOption.Gradient || fitOption.More || fitOption.User || fitOption.Integral || fitOption.Minuit) {
    linear = kFALSE;
  }

  if (special != 0 && !fitOption.Bound && !linear) {
    if (special == 100) {
      ROOT::Fit::InitGaus(fitdata, &func); // gaussian
    } else if (special == 400) {
      ROOT::Fit::InitGaus(fitdata, &func); // landau (use the same)
    } else if (special == 200) {
      ROOT::Fit::InitExpo(fitdata, &func); // exponential
    }
  }

  if ((linear || fitOption.Gradient)) {
    fitter.SetFunction(ROOT::Math::WrappedMultiTF1(func));
  } else {
    fitter.SetFunction(static_cast<const ROOT::Math::IParamMultiFunction&>(ROOT::Math::WrappedMultiTF1(func)));
  }

  // standard least square fit
  const bool fitok = fitter.Fit(fitdata, fitOption.ExecPolicy);
  if (!fitok) {
    LOGP(warning, "bad fit");
  }

  return TFitResultPtr(tfr);
}

/// fast median estimate of gaussian parameters for histogrammed data
///
/// \param[in]  nbins size of the array and number of histogram bins
/// \param[in]  arr   array with elements
/// \param[in]  xMin  minimum range of the array
/// \param[in]  xMax  maximum range of the array
/// \param[out] param return paramters of the fit (0-Constant, 1-Mean, 2-Sigma)
///
/// \return false on failure (empty data)

template <typename T>
bool medmadGaus(size_t nBins, const T* arr, const T xMin, const T xMax, std::array<double, 3>& param)
{
  int bStart = 0, bEnd = -1;
  double sum = 0, binW = double(xMax - xMin) / nBins, medVal = xMin;
  for (int i = 0; i < (int)nBins; i++) {
    auto v = arr[i];
    if (v) {
      if (!sum) {
        bStart = i;
      }
      sum += v;
      bEnd = i;
    }
  }
  if (bEnd < bStart) {
    return false;
  }
  bEnd++;
  double cum = 0, thresh = 0.5 * sum, frac0 = 0;
  int bid = bStart, prevbid = bid;
  while (bid < bEnd) {
    if (arr[bid] > 0) {
      cum += arr[bid];
      if (cum > thresh) {
        frac0 = 1. + (thresh - cum) / float(arr[bid]);
        medVal = xMin + binW * (bid + frac0);
        int bdiff = bid - prevbid - 1;
        if (bdiff > 0) {
          medVal -= bdiff * binW * 0.5; // account for the gap
          bid -= bdiff / 2;
        }
        break;
      }
      prevbid = bid;
    }
    bid++;
  }
  cum = 0.;
  double edgeL = frac0 + bid, edgeR = edgeL, dist = 0., wL = 0, wR = 0;
  while (1) {
    float amp = 0.;
    int bL = edgeL, bR = edgeR; // left and right bins
    if (edgeL > bStart) {
      wL = edgeL - bL;
      amp += arr[bL];
    } else {
      wL = 1.;
    }
    if (edgeR < bEnd) {
      wR = 1. + bR - edgeR;
      amp += arr[bR];
    } else {
      wR = 1.;
    }
    auto wdt = std::min(wL, wR);
    if (wdt < 1e-5) {
      wdt = std::max(wL, wR);
    }
    if (amp > 0) {
      amp *= wdt;
      cum += amp;
      if (cum >= thresh) {
        dist += wdt * (cum - thresh) / amp * 0.5;
        break;
      }
    }
    dist += wdt;
    edgeL -= wdt;
    edgeR += wdt;
  }
  constexpr double SQRT2PI = 2.5066283;
  param[1] = medVal;
  param[2] = dist * binW * 1.4826; // MAD -> sigma
  param[0] = sum * binW / (param[2] * SQRT2PI);
  return true;
}

/// fast fit of an array with ranges (histogram) with gaussian function
///
/// Fitting procedure:
/// 1. Step - make logarithm
/// 2. Linear  fit (parabola) - more robust, always converges, fast
///
/// \param[in]  nbins size of the array and number of histogram bins
/// \param[in]  arr   array with elements
/// \param[in]  xMin  minimum range of the array
/// \param[in]  xMax  maximum range of the array
/// \param[out] param return paramters of the fit (0-Constant, 1-Mean, 2-Sigma, 3-Sum)
///
/// \return chi2 or exit code
///          >0: the chi2 returned by TLinearFitter
///          -3: only three points have been used for the calculation - no fitter was used
///          -2: only two points have been used for the calculation - center of gravity was uesed for calculation
///          -1: only one point has been used for the calculation - center of gravity was uesed for calculation
///          -4: invalid result!!
///
//template <typename T>
//Double_t  fitGaus(const size_t nBins, const T *arr, const T xMin, const T xMax, std::vector<T>& param);
template <typename T>
Double_t fitGaus(const size_t nBins, const T* arr, const T xMin, const T xMax, std::vector<T>& param)
{
  static TLinearFitter fitter(3, "pol2");
  static TMatrixD mat(3, 3);
  static Double_t kTol = mat.GetTol();
  fitter.StoreData(kFALSE);
  fitter.ClearPoints();
  TVectorD par(3);
  TVectorD sigma(3);
  TMatrixD A(3, 3);
  TMatrixD b(3, 1);
  T rms = TMath::RMS(nBins, arr);
  T max = TMath::MaxElement(nBins, arr);
  T binWidth = (xMax - xMin) / T(nBins);

  Float_t meanCOG = 0;
  Float_t rms2COG = 0;
  Float_t sumCOG = 0;

  Float_t entries = 0;
  Int_t nfilled = 0;

  param.resize(4);
  param[0] = 0.;
  param[1] = 0.;
  param[2] = 0.;
  param[3] = 0.;

  for (size_t i = 0; i < nBins; i++) {
    entries += arr[i];
    if (arr[i] > 0) {
      nfilled++;
    }
  }

  // TODO: Check why this is needed
  if (max < 4) {
    return -4;
  }
  if (entries < 12) {
    return -4;
  }

  if (rms < kTol) {
    return -4;
  }

  param[3] = entries;

  Int_t npoints = 0;
  for (size_t ibin = 0; ibin < nBins; ibin++) {
    Float_t entriesI = arr[ibin];
    if (entriesI > 1) {
      Double_t xcenter = xMin + (ibin + 0.5) * binWidth;
      Double_t error = 1. / TMath::Sqrt(entriesI);
      Double_t val = TMath::Log(Float_t(entriesI));
      fitter.AddPoint(&xcenter, val, error);
      if (npoints < 3) {
        A(npoints, 0) = 1;
        A(npoints, 1) = xcenter;
        A(npoints, 2) = xcenter * xcenter;
        b(npoints, 0) = val;
        meanCOG += xcenter * entriesI;
        rms2COG += xcenter * entriesI * xcenter;
        sumCOG += entriesI;
      }
      npoints++;
    }
  }

  Double_t chi2 = 0;
  if (npoints >= 3) {
    if (npoints == 3) {
      //analytic calculation of the parameters for three points
      A.Invert();
      TMatrixD res(1, 3);
      res.Mult(A, b);
      par[0] = res(0, 0);
      par[1] = res(0, 1);
      par[2] = res(0, 2);
      chi2 = -3.;
    } else {
      // use fitter for more than three points
      fitter.Eval();
      fitter.GetParameters(par);
      fitter.GetCovarianceMatrix(mat);
      chi2 = fitter.GetChisquare() / Double_t(npoints);
    }
    if (TMath::Abs(par[1]) < kTol) {
      return -4;
    }
    if (TMath::Abs(par[2]) < kTol) {
      return -4;
    }
    param[1] = T(par[1] / (-2. * par[2]));
    param[2] = T(1. / TMath::Sqrt(TMath::Abs(-2. * par[2])));
    Double_t lnparam0 = par[0] + par[1] * param[1] + par[2] * param[1] * param[1];
    if (lnparam0 > 307) {
      return -4;
    }
    param[0] = TMath::Exp(lnparam0);

    return chi2;
  }

  if (npoints == 2) {
    //use center of gravity for 2 points
    meanCOG /= sumCOG;
    rms2COG /= sumCOG;
    param[0] = max;
    param[1] = meanCOG;
    param[2] = TMath::Sqrt(TMath::Abs(meanCOG * meanCOG - rms2COG));
    chi2 = -2.;
  }
  if (npoints == 1) {
    meanCOG /= sumCOG;
    param[0] = max;
    param[1] = meanCOG;
    param[2] = binWidth / TMath::Sqrt(12);
    chi2 = -1.;
  }
  return chi2;
}

// more optimal implementation of guassian fit via log-normal fit, appropriate for MT calls
// Only bins with values above minVal will be accounted.
// If applyMAD is true, the fit is done whithin the nSigmaMAD range of the preliminary estimate by MAD
template <typename T>
double fitGaus(size_t nBins, const T* arr, const T xMin, const T xMax, std::array<double, 3>& param,
               ROOT::Math::SMatrix<double, 3, 3, ROOT::Math::MatRepSym<double, 3>>* covMat = nullptr,
               int minVal = 2, bool applyMAD = true)
{
  double binW = double(xMax - xMin) / nBins, s0 = 0, s1 = 0, s2 = 0, s3 = 0, s4 = 0, sy0 = 0, sy1 = 0, sy2 = 0, syy = 0;
  int np = 0;
  int bStart = 0, bEnd = (int)nBins;
  const float nSigmaMAD = 2.;
  if (applyMAD) {
    std::array<double, 3> madPar;
    if (!medmadGaus(nBins, arr, xMin, xMax, madPar)) {
      return -10;
    }
    bStart = std::max(bStart, int((madPar[1] - nSigmaMAD * madPar[2] - xMin) / binW));
    bEnd = std::min(bEnd, 1 + int((madPar[1] + nSigmaMAD * madPar[2] - xMin) / binW));
  }
  float x = xMin + (bStart - 0.5) * binW;
  for (int i = bStart; i < bEnd; i++) {
    x += binW;
    auto v = arr[i];
    if (v < 0) {
      throw std::runtime_error("Log-normal fit is possible only with non-negative data");
    }
    if (v < minVal) {
      continue;
    }
    double y = std::log(v), err2i = v, err2iX = err2i, err2iY = err2i * y;
    s0 += err2iX;
    s1 += (err2iX *= x);
    s2 += (err2iX *= x);
    s3 += (err2iX *= x);
    s4 += (err2iX *= x);
    sy0 += err2iY;
    syy += err2iY * y;
    sy1 += (err2iY *= x);
    sy2 += (err2iY *= x);
    np++;
  }
  if (np < 1) {
    return -10;
  }
  auto recover = [&param, binW, np, s0, s1, s2, sy0]() {
    param[0] = std::exp(sy0 / s0); // recover center of gravity
    param[1] = s1 / s0;            // mean x;
    param[2] = np == 1 ? binW / std::sqrt(12) : std::sqrt(std::abs(param[1] * param[1] - s2 / s0));
  };
  if (np < 3) {
    recover();
    return -np;
  }
  ROOT::Math::SMatrix<double, 3, 3, ROOT::Math::MatRepSym<double, 3>> m33{};
  ROOT::Math::SVector<double, 3> v3{sy0, sy1, sy2};
  m33(0, 0) = s0;
  m33(1, 0) = s1;
  m33(1, 1) = m33(2, 0) = s2;
  m33(2, 1) = s3;
  m33(2, 2) = s4;
  int res = 0;
  auto m33i = m33.Inverse(res);
  if (res) {
    recover();
    LOG(error) << np << " points collected, matrix inversion failed " << m33;
    return -10;
  }
  auto v = m33i * v3;
  if (v(2) >= 0.) { // fit failed, use mean amd RMS
    recover();
    return -3;
  }

  double chi2 = v(0) * v(0) * s0 + v(1) * v(1) * s2 + v(2) * v(2) * s4 + syy +
                2. * (v(0) * v(1) * s1 + v(0) * v(2) * s2 + v(1) * v(2) * s3 - v(0) * sy0 - v(1) * sy1 - v(2) * sy2);
  param[1] = -0.5 * v(1) / v(2);
  param[2] = 1. / std::sqrt(-2. * v(2));
  param[0] = std::exp(v(0) - param[1] * param[1] * v(2));
  if (std::isnan(param[0]) || std::isnan(param[1]) || std::isnan(param[2])) {
    recover();
    return -3;
  }
  if (covMat) {
    // build jacobian of transformation from log-normal to normal params
    ROOT::Math::SMatrix<double, 3, 3, ROOT::Math::MatRepStd<double, 3, 3>> j33{};
    j33(0, 0) = param[0];
    j33(0, 1) = param[0] * param[1];
    j33(0, 2) = j33(0, 1) * param[1];
    j33(1, 1) = -0.5 / v(2);
    j33(1, 2) = -param[1] / v(2);
    j33(2, 2) = param[2] * j33(1, 1);
    *covMat = ROOT::Math::Similarity(j33, m33i);
  }
  return np > 3 ? chi2 / (np - 3.) : 0.;
}

/// struct for returning statistical parameters
///
/// \todo make type templated?
/// \todo use Vc
struct StatisticsData {
  double mCOG{0};    ///< calculated centre of gravity
  double mStdDev{0}; ///< standard deviation
  double mSum{0};    ///< sum of values
};

/// calculate statistical parameters on a binned array
///
/// The function assumes a binned array of
/// \param nBins size of the array
/// \param xMin lower histogram bound
/// \param xMax upper histogram bound
/// \todo make return type templated?
template <typename T>
StatisticsData getStatisticsData(const T* arr, const size_t nBins, const double xMin, const double xMax)
{
  double mean = 0;
  double rms2 = 0;
  double sum = 0;
  size_t npoints = 0;

  double binWidth = (xMax - xMin) / (double)nBins;

  StatisticsData data;
  // in case something went wrong the COG is the histogram lower limit
  data.mCOG = xMin;

  for (size_t ibin = 0; ibin < nBins; ++ibin) {
    double entriesI = (double)arr[ibin];
    double xcenter = xMin + (ibin + 0.5) * binWidth; // +0.5 to shift to bin centre
    if (entriesI > 0) {
      mean += xcenter * entriesI;
      rms2 += xcenter * entriesI * xcenter;
      sum += entriesI;
      ++npoints;
    }
  }
  if (sum == 0) {
    return data;
  }
  mean /= sum;

  data.mCOG = mean;
  // exception in case of only one bin is filled
  // set the standard deviation to bin width over sqrt(12)
  rms2 /= sum;
  if (npoints == 1) {
    data.mStdDev = binWidth / std::sqrt(12.);
  } else {
    data.mStdDev = std::sqrt(std::abs(rms2 - mean * mean));
  }

  data.mSum = sum;

  return data;
}

/// median of values in a std::vector
///
/// we need to make a copy of the vector since we need to sort it
/// based on this discussion: https://stackoverflow.com/questions/1719070/what-is-the-right-approach-when-using-stl-container-for-median-calculation/1719155#1719155
/// \todo Is there a better way to do this?
template <typename T, typename R = double>
R median(std::vector<T> v)
{
  if (v.empty()) {
    return R{};
  }
  auto n = v.size() / 2;
  nth_element(v.begin(), v.begin() + n, v.end());
  auto med = R{v[n]};
  if (!(v.size() & 1)) { //If the set size is even
    auto max_it = max_element(v.begin(), v.begin() + n);
    med = R{(*max_it + med) / 2.0};
  }
  return med;
}

/// Fills the index vector with sorted indices of the input vector.
/// The input vector is not modified (similar to TMath::Sort()).
/// \param values Vector to be indexed
/// \param index Vector to hold the sorted indices (must have the same size as values)
template <typename T>
void SortData(std::vector<T> const& values, std::vector<size_t>& index)
{
  if (values.size() != index.size()) {
    LOG(error) << "Vector with values must have same size as vector for indices";
    return;
  }
  std::iota(index.begin(), index.end(), static_cast<size_t>(0));
  std::sort(index.begin(), index.end(), [&](size_t a, size_t b) { return values[a] < values[b]; });
}

/// LTM : Trimmed mean of unbinned array
///
/// Robust statistic to estimate properties of the distribution
/// To handle binning error special treatment
/// for definition of unbinned data see:
///     http://en.wikipedia.org/w/index.php?title=Trimmed_estimator&oldid=582847999
/// \param data Input vector (unsorted)
/// \param index Vector with indices of sorted input data
/// \param params Array with characteristics of distribution
/// \param fracKeep Fraction of data to be kept
/// \return Flag if successfull
/// Characteristics:
/// -# area
/// -# mean
/// -# rms
/// -# error estimate of mean
/// -# error estimate of RMS
/// -# first accepted element (of sorted array)
/// -# last accepted  element (of sorted array)
template <typename T>
bool LTMUnbinned(const std::vector<T>& data, std::vector<size_t>& index, std::array<float, 7>& params, float fracKeep)
{
  int nPoints = data.size();
  std::vector<float> w(2 * nPoints);
  int nKeep = nPoints * fracKeep;
  if (nKeep > nPoints) {
    nKeep = nPoints;
  }
  if (nKeep < 2) {
    return false;
  }
  // sort in increasing order
  SortData(data, index);
  // build cumulants
  double sum1 = 0.0;
  double sum2 = 0.0;
  for (int i = 0; i < nPoints; i++) {
    double x = data[index[i]];
    sum1 += x;
    sum2 += x * x;
    w[i] = sum1;
    w[i + nPoints] = sum2;
  }
  double maxRMS = sum2 + 1e6;
  params[0] = nKeep;
  int limI = nPoints - nKeep + 1; // lowest possible bin to accept
  for (int i = 0; i < limI; i++) {
    const int limJ = i + nKeep - 1; // highest accepted bin
    sum1 = static_cast<double>(w[limJ]) - static_cast<double>(i ? w[i - 1] : 0.);
    sum2 = static_cast<double>(w[nPoints + limJ]) - static_cast<double>(i ? w[nPoints + i - 1] : 0.);
    const double mean = sum1 / nKeep;
    const double rms2 = sum2 / nKeep - mean * mean;
    if (rms2 > maxRMS) {
      continue;
    }
    maxRMS = rms2;
    params[1] = mean;
    params[2] = rms2;
    params[5] = i;
    params[6] = limJ;
  }
  //
  if (params[2] < 0) {
    LOG(error) << "Rounding error: RMS = " << params[2] << " < 0";
    return false;
  }
  params[2] = std::sqrt(params[2]);
  params[3] = params[2] / std::sqrt(params[0]); // error on mean
  params[4] = params[3] / std::sqrt(2.0);       // error on RMS
  return true;
}

/// Rearranges the input vector in the order given by the index vector
/// \param data Input vector
/// \param index Index vector
template <typename T>
void Reorder(std::vector<T>& data, const std::vector<size_t>& index)
{
  // rearange data in order given by index
  if (data.size() != index.size()) {
    LOG(error) << "Reordering not possible if number of elements in index container different from the data container";
    return;
  }
  std::vector<T> tmp(data);
  for (size_t i = 0; i < data.size(); ++i) {
    data[i] = tmp[index[i]];
  }
}

/// Compare this function to LTMUnbinned.
/// A target sigma of the distribution can be specified and it will be trimmed to match that target.
/// \param data Input vector (unsorted)
/// \param index Vector with indices of sorted input data
/// \param params Array with characteristics of distribution
/// \param fracKeepMin Minimum fraction to keep of the input data
/// \param sigTgt Target distribution sigma
/// \param sorted Flag if the data is already sorted
/// \return Flag if successfull
template <typename T>
bool LTMUnbinnedSig(const std::vector<T>& data, std::vector<size_t>& index, std::array<float, 7>& params, float fracKeepMin, float sigTgt, bool sorted = false)
{
  int nPoints = data.size();
  std::vector<double> wx(nPoints);
  std::vector<double> wx2(nPoints);

  if (!sorted) {
    // sort in increasing order
    SortData(data, index);
  } else {
    // array is already sorted
    std::iota(index.begin(), index.end(), 0);
  }
  // build cumulants
  double sum1 = 0.0;
  double sum2 = 0.0;
  for (int i = 0; i < nPoints; i++) {
    double x = data[index[i]];
    sum1 += x;
    sum2 += x * x;
    wx[i] = sum1;
    wx2[i] = sum2;
  }
  int keepMax = nPoints;
  int keepMin = fracKeepMin * nPoints;
  if (keepMin > keepMax) {
    keepMin = keepMax;
  }
  float sigTgt2 = sigTgt * sigTgt;
  //
  while (true) {
    double maxRMS = wx2.back() + 1e6;
    int keepN = (keepMax + keepMin) / 2;
    if (keepN < 2) {
      return false;
    }
    params[0] = keepN;
    int limI = nPoints - keepN + 1;
    for (int i = 0; i < limI; ++i) {
      const int limJ = i + keepN - 1;
      sum1 = wx[limJ] - (i ? wx[i - 1] : 0.);
      sum2 = wx2[limJ] - (i ? wx2[i - 1] : 0.);
      const double mean = sum1 / keepN;
      const double rms2 = sum2 / keepN - mean * mean;
      if (rms2 > maxRMS) {
        continue;
      }
      maxRMS = rms2;
      params[1] = mean;
      params[2] = rms2;
      params[5] = i;
      params[6] = limJ;
    }
    if (maxRMS < sigTgt2) {
      keepMin = keepN;
    } else {
      keepMax = keepN;
    }
    if (keepMin >= keepMax - 1) {
      break;
    }
  }
  params[2] = std::sqrt(params[2]);
  params[3] = params[2] / std::sqrt(params[0]); // error on mean
  params[4] = params[3] / std::sqrt(2.0);       // error on RMS
  return true;
}
} // namespace math_utils
} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// @brief O2 interface class to ROOT::Math::Transform3D for Cartesian transformations
/// @author Sandro Wenzel, sandro.wenzel@cern.ch
/// @author Ruben Shahoyan, ruben.shahoyan@cern.ch

#ifndef ALICEO2_CARTESIAN3D_H
#define ALICEO2_CARTESIAN3D_H

#include "GPUCommonDef.h"
#include "GPUCommonRtypes.h"
#if (!defined(GPUCA_STANDALONE) || !defined(DGPUCA_NO_ROOT)) && !defined(GPUCA_GPUCODE) && !defined(GPUCOMMONRTYPES_H_ACTIVE)
#include <Math/SMatrix.h>
#include <Math/SVector.h>
#include <Math/GenVector/DisplacementVector3D.h>
#include <Math/GenVector/PositionVector3D.h>
#include <Math/GenVector/Rotation3D.h>
#include <Math/GenVector/Transform3D.h>
#include <Math/GenVector/Translation3D.h>
#include <Math/GenVector/DisplacementVector2D.h>
#include <Math/GenVector/PositionVector2D.h>
#include <TGeoMatrix.h>
#include <iosfwd>
#else
#include "GPUCommonMath.h"
#include "CartesianGPU.h"
#include "SMatrixGPU.h"

#endif
#include "GPUROOTCartesianFwd.h"
#include "GPUROOTSMatrixFwd.h"

namespace o2
{

namespace math_utils
{

// more typedefs can follow

/// predefined transformations: Tracking->Local, Tracking->Global, Local->Global etc
/// The IDs must be < 32

struct TransformType {
  static constexpr int L2G = 0;
  static constexpr int T2L = 1;
  static constexpr int T2G = 2;
  static constexpr int T2GRot = 3;
}; /// transformation types

template <typename value_T>
class Rotation2D
{
  //
  // class to perform rotation of 3D (around Z) and 2D points

 public:
  using value_t = value_T;

  Rotation2D() = default;
  Rotation2D(value_t cs, value_t sn) : mCos(cs), mSin(sn) {}
  Rotation2D(value_t phiZ) : mCos(cos(phiZ)), mSin(sin(phiZ)) {}
  ~Rotation2D() = default;
  Rotation2D(const Rotation2D& src) = default;
  Rotation2D(Rotation2D&& src) = default;
  Rotation2D& operator=(const Rotation2D& src) = default;
  Rotation2D& operator=(Rotation2D&& src) = default;

  void set(value_t phiZ)
  {
    mCos = cos(phiZ);
    mSin = sin(phiZ);
  }

  void set(value_t cs, value_t sn)
  {
    mCos = cs;
    mSin = sn;
  }

  void getComponents(value_t& cs, value_t& sn) const
  {
    cs = mCos;
    sn = mSin;
  }

  template <typename T>
  Point3D<T> operator()(const Point3D<T>& v) const
  { // local->master
    return Point3D<T>(v.X() * mCos - v.Y() * mSin, v.X() * mSin + v.Y() * mCos, v.Z());
  }

  template <typename T>
  Point3D<T> operator^(const Point3D<T>& v) const
  { // master->local
    return Point3D<T>(v.X() * mCos + v.Y() * mSin, -v.X() * mSin + v.Y() * mCos, v.Z());
  }

  template <typename T>
  Vector3D<T> operator()(const Vector3D<T>& v) const
  { // local->master
    return Vector3D<T>(v.X() * mCos - v.Y() * mSin, v.X() * mSin + v.Y() * mCos, v.Z());
  }

  template <typename T>
  Vector3D<T> operator^(const Vector3D<T>& v) const
  { // master->local
    return Vector3D<T>(v.X() * mCos + v.Y() * mSin, -v.X() * mSin + v.Y() * mCos, v.Z());
  }

  template <typename T>
  Point2D<T> operator()(const Point2D<T>& v) const
  { // local->master
    return Point2D<T>(v.X() * mCos - v.Y() * mSin, v.X() * mSin + v.Y() * mCos);
  }

  template <typename T>
  Point2D<T> operator^(const Point2D<T>& v) const
  { // master->local
    return Point2D<T>(v.X() * mCos + v.Y() * mSin, -v.X() * mSin + v.Y() * mCos);
  }

  template <typename T>
  Vector2D<T> operator()(const Vector2D<T>& v) const
  { // local->master
    return Vector2D<T>(v.X() * mCos - v.Y() * mSin, v.X() * mSin + v.Y() * mCos);
  }

  template <typename T>
  Vector2D<T> operator^(const Vector2D<T>& v) const
  { // master->local
    return Vector2D<T>(v.X() * mCos + v.Y() * mSin, -v.X() * mSin + v.Y() * mCos);
  }

 private:
  value_t mCos = 1; ///< cos of rotation angle
  value_t mSin = 0; ///< sin of rotation angle

  ClassDefNV(Rotation2D, 2);
};

using Rotation2Df_t = Rotation2D<float>;
using Rotation2Dd_t = Rotation2D<double>;

#if (!defined(GPUCA_STANDALONE) || !defined(DGPUCA_NO_ROOT)) && !defined(GPUCA_GPUCODE) && !defined(GPUCOMMONRTYPES_H_ACTIVE)

class Transform3D : public ROOT::Math::Transform3D
{
  //
  // Class to perform geom.transformations (rotation and displacements only) in
  // double precision over the cartesian points and vectors (float or double).
  // Adds to the base ROOT::Math::Transform3D<double> class a convertor from
  // TGeoMatrix.
  // To be used instead of TGeoHMatrix for all transformations of hits,
  // clusters etc.
  //

 public:
  Transform3D() = default;
  Transform3D(const TGeoMatrix& m);
  ~Transform3D() = default;

  // inherit assignment operators of the base class
  using ROOT::Math::Transform3D::operator=;

  // to avoid conflict between the base Transform3D(const ForeignMatrix & m) and
  // Transform3D(const TGeoMatrix &m) constructors we cannot inherit base c-tors,
  // therefore we redefine them here
  Transform3D(const ROOT::Math::Rotation3D& r, const Vector& v) : ROOT::Math::Transform3D(r, v) {}
  Transform3D(const ROOT::Math::Rotation3D& r, const ROOT::Math::Translation3D& t) : ROOT::Math::Transform3D(r, t) {}
  template <class IT>
  Transform3D(IT begin, IT end) : ROOT::Math::Transform3D(begin, end)
  {
  }

  // conversion operator to TGeoHMatrix
  operator TGeoHMatrix&() const
  {
    static TGeoHMatrix tmp;
    double rot[9], tra[3];
    GetComponents(rot[0], rot[1], rot[2], tra[0], rot[3], rot[4], rot[5], tra[1], rot[6], rot[7], rot[8], tra[2]);
    tmp.SetRotation(rot);
    tmp.SetTranslation(tra);
    return tmp;
  }

  void set(const TGeoMatrix& m); // set parameters from TGeoMatrix

  using ROOT::Math::Transform3D::operator();
  // the local->master transformation for points and vectors can be
  // done in operator form (inherited from base Transform3D) as
  // Point3D pnt;
  // Transform3D trans;
  // auto pntTr0 = trans(pnt); // 1st version
  // auto pntTr1 = trans*pnt;  // 2nd version
  //
  // For the inverse transform we define our own operator^

  template <typename T>
  Point3D<T> operator^(const Point3D<T>& p) const
  { // master->local
    return ApplyInverse(p);
  }

  template <typename T>
  Vector3D<T> operator^(const Vector3D<T>& v) const
  { // local->master
    return ApplyInverse(v);
  }

  // TGeoHMatrix-like aliases
  template <typename T>
  void LocalToMaster(const Point3D<T>& loc, Point3D<T>& mst) const
  {
    mst = operator()(loc);
  }

  template <typename T>
  void MasterToLocal(const Point3D<T>& mst, Point3D<T>& loc) const
  {
    loc = operator^(mst);
  }

  template <typename T>
  void LocalToMasterVect(const Point3D<T>& loc, Point3D<T>& mst) const
  {
    mst = operator()(loc);
  }

  template <typename T>
  void MasterToLocalVect(const Point3D<T>& mst, Point3D<T>& loc) const
  {
    loc = operator^(mst);
  }

  void print() const;

  ClassDefNV(Transform3D, 1);
};
#endif // Disable for GPU
} // namespace math_utils
} // namespace o2

#if (!defined(GPUCA_STANDALONE) || !defined(DGPUCA_NO_ROOT)) && !defined(GPUCA_GPUCODE) && !defined(GPUCOMMONRTYPES_H_ACTIVE)
std::ostream& operator<<(std::ostream& os, const o2::math_utils::Rotation2Df_t& t);
std::ostream& operator<<(std::ostream& os, const o2::math_utils::Rotation2Dd_t& t);

namespace std
{

/// Defining Point3D explicitly as trivially copyable
///
/// std::is_trivially_copyable<ROOT::Math::Cartesian3D<T>> fails because the class
/// implements a copy constructor, although it does not much more than the default copy
/// constructor. We need Point3D to fulfill the condition in order to make types
/// inheriting from it or using it as member can be safely detected as messageable.
///
/// We believe that Point3D is messageable and explicitly specialize the type trait.
/// There is a unit test for checking trivial copy
/// This is a workaround, we will also make suggestions to fix the cause in ROOT itself
/// TODO: delete once it is fixed in ROOT
template <typename T>
struct is_trivially_copyable<o2::math_utils::Point3D<T>> : std::true_type {
};
} // namespace std
#endif // Disable for GPU

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file CartesianGPU.h
/// @author David Rohr

#ifndef ALICEO2_CARTESIANGPU_H
#define ALICEO2_CARTESIANGPU_H

#include "GPUCommonDef.h"

namespace o2::math_utils
{

namespace detail
{
template <typename T, int I>
struct GPUPoint2D {
  GPUdDefault() GPUPoint2D() = default;
  GPUhd() GPUPoint2D(T a, T b) : xx(a), yy(b) {}
  GPUhd() float X() const { return xx; }
  GPUhd() float Y() const { return yy; }
  GPUd() float R() const { return o2::gpu::CAMath::Sqrt(xx * xx + yy * yy); }
  GPUd() void SetX(float v) { xx = v; }
  GPUd() void SetY(float v) { yy = v; }
  T xx;
  T yy;
};

template <typename T, int I>
struct GPUPoint3D : public GPUPoint2D<T, I> {
  GPUdDefault() GPUPoint3D() = default;
  GPUhd() GPUPoint3D(T a, T b, T c) : GPUPoint2D<T, I>(a, b), zz(c) {}
  GPUhd() float Z() const { return zz; }
  GPUd() float R() const { return o2::gpu::CAMath::Sqrt(GPUPoint2D<T, I>::xx * GPUPoint2D<T, I>::xx + GPUPoint2D<T, I>::yy * GPUPoint2D<T, I>::yy + zz * zz); }
  GPUd() void SetZ(float v) { zz = v; }
  T zz;
};
} // namespace detail

} // end namespace o2::math_utils

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// @brief Extension to ROOT::TF1 allowing to cache integral
/// @author Sandro Wenzel, sandro.wenzel@cern.ch

#ifndef ALICEO2_CACHINGTF1_H
#define ALICEO2_CACHINGTF1_H

#include <TF1.h>

namespace o2
{
namespace math_utils
{
class CachingTF1 : public TF1
{
  ///
  /// Class extending TF1 with capability to store expensive
  /// internal caches (integral, etc) when streaming out
  /// This can immensely speed up the construction of the TF1
  /// (e.g., for the purpose of random number generation from arbitrary distributions)
  ///
 public:
  using TF1::TF1;
  ~CachingTF1() override = default;

  // get reading access to fIntegral member
  std::vector<double> const& getIntegralVector() const { return fIntegral; }

 private:
  // in the original TF1 implementation, these members
  // are marked transient; by simply introducing something that
  // points to them they will now be written correctly to disc
  std::vector<double>* mIntegralCache = &fIntegral;
  std::vector<double>* mAlphaCache = &fAlpha;
  std::vector<double>* mBetaCache = &fBeta;
  std::vector<double>* mGammaCache = &fGamma;
  ClassDefOverride(CachingTF1, 1);
};
} // namespace math_utils
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

///
/// @file   RandomRing.h
/// @author Jens Wiechula, Jens.Wiechula@ikf.uni-frankfurt.de
///

/// @brief  Ring with random number
///
/// This class creates a set of random (or any sort of pregenerated) numbers
/// in a ring buffer.

/// The idea is to create a set of random numbers that can be
/// reused in order to save computing time.
/// The numbers can then be used as a continuous stream in
/// a ring buffer
///
/// @author Jens Wiechula, Jens.Wiechula@cern.ch

#ifndef ALICEO2_MATHUTILS_RANDOMRING_H_
#define ALICEO2_MATHUTILS_RANDOMRING_H_

#include <array>

#include "TF1.h"
#include "TRandom.h"
#include <functional>


namespace o2
{
namespace math_utils
{

template <size_t N = 4 * 100000>
class RandomRing
{
 public:
  enum class RandomType : char {
    Gaus,         ///< Gaussian distribution
    Flat,         ///< Flat distribution
    CustomTF1,    ///< Custom TF1 function to be used
    CustomLambda, ///< Initialized through external lambda
  };

  /// constructor
  /// @param [in] randomType type of the random generator
  RandomRing(const RandomType randomType = RandomType::Gaus);

  /// constructor accepting TF1
  /// @param [in] function TF1 function
  RandomRing(TF1& function);

  /// initialisation of the random ring
  /// @param [in] randomType type of the random generator
  void initialize(const RandomType randomType = RandomType::Gaus);

  /// initialisation of the random ring
  /// @param [in] randomType type of the random generator
  void initialize(TF1& function);

  /// initialisation of the random ring
  /// @param [in] randomType type of the random generator
  void initialize(std::function<float()> function);

  /// next random value from the ring buffer
  /// This function return a value from the ring buffer
  /// and increases the buffer position
  /// @return next random value
  float getNextValue()
  {
    const float value = mRandomNumbers[mRingPosition];
    ++mRingPosition;
    if (mRingPosition >= mRandomNumbers.size()) {
      mRingPosition = 0;
    }
    return value;
  }

  /// next vector with random values
  /// This function retuns a Vc vector with random numbers to be
  /// used for vectorised programming and increases the buffer
  /// position by the size of the vector
  /// @return vector with random values
  template <typename VcType>
  VcType getNextValueVc()
  {
    // This function is templated so that we don't need to include the <Vc/Vc> header
    // within this header file (to reduce memory problems during compilation).
    // The hope is that the calling user calls this with a
    // correct Vc type (Vc::float_v) in a source file.
    const VcType value = VcType(&mRandomNumbers[mRingPosition]);
    mRingPosition += VcType::size();
    if (mRingPosition >= mRandomNumbers.size()) {
      mRingPosition = 0;
    }
    return value;
  }

  /// position in the ring buffer
  /// @return position in the ring buffer
  unsigned int getRingPosition() const { return mRingPosition; }

 private:
  // =========================================================================
  // ===| members |===========================================================
  //

  RandomType mRandomType;              ///< Type of random numbers used
  std::array<float, N> mRandomNumbers; ///< Ring with random gaus numbers
  size_t mRingPosition = 0;            ///< presently accessed position in the ring

}; // end class RandomRing

//______________________________________________________________________________
template <size_t N>
inline RandomRing<N>::RandomRing(const RandomType randomType)
  : mRandomType(randomType),
    mRandomNumbers()

{
  initialize(randomType);
}

//______________________________________________________________________________
template <size_t N>
inline RandomRing<N>::RandomRing(TF1& function)
  : mRandomType(RandomType::CustomTF1),
    mRandomNumbers()
{
  initialize(function);
}

//______________________________________________________________________________
template <size_t N>
inline void RandomRing<N>::initialize(const RandomType randomType)
{

  for (auto& v : mRandomNumbers) {
    // TODO: configurable mean and sigma
    switch (randomType) {
      case RandomType::Gaus: {
        v = gRandom->Gaus(0, 1);
        break;
      }
      case RandomType::Flat: {
        v = gRandom->Rndm();
        break;
      }
      default: {
        v = 0;
        break;
      }
    }
  }
}

//______________________________________________________________________________
template <size_t N>
inline void RandomRing<N>::initialize(TF1& function)
{
  mRandomType = RandomType::CustomTF1;
  for (auto& v : mRandomNumbers) {
    v = function.GetRandom();
  }
}

//______________________________________________________________________________
template <size_t N>
inline void RandomRing<N>::initialize(std::function<float()> function)
{
  mRandomType = RandomType::CustomLambda;
  for (auto& v : mRandomNumbers) {
    v = function();
  }
}

} // namespace math_utils
} // namespace o2
#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file Primitive2D.h
/// \brief Declarations of 2D primitives
/// \author ruben.shahoyan@cern.ch michael.lettrich@cern.ch

#ifndef ALICEO2_COMMON_MATH_PRIMITIVE2D_H
#define ALICEO2_COMMON_MATH_PRIMITIVE2D_H

#include "GPUCommonRtypes.h"
#include "MathUtils/detail/CircleXY.h"
#include "MathUtils/detail/IntervalXY.h"
#include "MathUtils/detail/Bracket.h"

namespace o2
{
namespace math_utils
{
template <typename T>
using CircleXY = detail::CircleXY<T>;
using CircleXYf_t = detail::CircleXY<float>;
using CircleXYd_t = detail::CircleXY<double>;

template <typename T>
using IntervalXY = detail::IntervalXY<T>;
using IntervalXYf_t = detail::IntervalXY<float>;
using IntervalXYd_t = detail::IntervalXY<double>;

template <typename T>
using Bracket = detail::Bracket<T>;
using Bracketf_t = detail::Bracket<float>;
using Bracketd_t = detail::Bracket<double>;

} // namespace math_utils
} // namespace o2

#endif
// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
// All rights not expressly granted are reserved.
//
// This software is distributed under the terms of the GNU General Public
// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
//
// In applying this license CERN does not waive the privileges and immunities
// granted to it by virtue of its status as an Intergovernmental Organization
// or submit itself to any jurisdiction.

/// \file SMatrixGPU.h
/// \author Matteo Concas mconcas@cern.ch
/// \brief This is a close porting of the SMatrix and SVectorGPU ROOT interfaces.
/// Only parts strictly requiring STD library have been changed.
/// Also some utilities to have basic checks and printouts working on GPUs have been rewritten.
///
/// Notably only templated implementation of
/// row_offsets_utils::make and row_offsets_utils::do_make
/// has been reworked to support gpustd::array as backend.
///
/// Other than that, the author is not taking any credit on the methodologies implemented
/// which have been taken straight from root source code
///
/// Original sources are on the official website:
/// - https://root.cern.ch

#ifndef ALICEO2_SMATRIX_GPU_H
#define ALICEO2_SMATRIX_GPU_H

#include "GPUCommonDef.h"
#include "GPUCommonArray.h"
#include "GPUCommonMath.h"
#include "GPUCommonAlgorithm.h"

namespace o2::math_utils
{
template <bool>
struct Check {
  GPUd() Check(void*) {}
};
template <>
struct Check<false> {
};

#define GPU_STATIC_CHECK(expr, msg) \
  {                                 \
    class ERROR_##msg               \
    {                               \
    };                              \
    ERROR_##msg e;                  \
    (void)(Check<(expr) != 0>(&e)); \
  }

template <typename T, unsigned int N>
class SVectorGPU
{
 public:
  typedef T value_type;
  typedef T* iterator;
  typedef const T* const_iterator;
  GPUd() iterator begin();
  GPUd() iterator end();
  GPUd() const_iterator begin() const;
  GPUd() const_iterator end() const;
  GPUd() SVectorGPU();
  GPUd() SVectorGPU(const SVectorGPU<T, N>& rhs);

  GPUd() const T& operator[](unsigned int i) const;
  GPUd() const T& operator()(unsigned int i) const;
  GPUd() T& operator[](unsigned int i);
  GPUd() T& operator()(unsigned int i);
  GPUd() const T* Array() const;
  GPUd() T* Array();
  GPUd() T apply(unsigned int i) const;

  // Operators
  GPUd() SVectorGPU<T, N>& operator-=(const SVectorGPU<T, N>& rhs);
  GPUd() SVectorGPU<T, N>& operator+=(const SVectorGPU<T, N>& rhs);

  enum {
    kSize = N
  };

  GPUdi() static unsigned int Dim() { return N; }

 private:
  T mArray[N];
};

template <class T, unsigned int D>
GPUdi() T* SVectorGPU<T, D>::begin()
{
  return mArray;
}

template <class T, unsigned int D>
GPUdi() const T* SVectorGPU<T, D>::begin() const
{
  return mArray;
}

template <class T, unsigned int D>
GPUdi() T* SVectorGPU<T, D>::end()
{
  return mArray + Dim();
}

template <class T, unsigned int D>
GPUdi() const T* SVectorGPU<T, D>::end() const
{
  return mArray + Dim();
}
template <class T, unsigned int N>

GPUdi() const T& SVectorGPU<T, N>::operator[](unsigned int i) const
{
  return mArray[i];
}

template <class T, unsigned int N>
GPUdi() const T& SVectorGPU<T, N>::operator()(unsigned int i) const
{
  return mArray[i];
}

template <class T, unsigned int N>
GPUdi() T& SVectorGPU<T, N>::operator[](unsigned int i)
{
  return mArray[i];
}

template <class T, unsigned int N>
GPUdi() T& SVectorGPU<T, N>::operator()(unsigned int i)
{
  return mArray[i];
}

template <class T, unsigned int N>
GPUd() SVectorGPU<T, N>::SVectorGPU()
{
  for (unsigned int i = 0; i < N; ++i) {
    mArray[i] = 7;
  }
}

template <class T, unsigned int N>
GPUd() SVectorGPU<T, N>::SVectorGPU(const SVectorGPU<T, N>& rhs)
{
  for (unsigned int i = 0; i < N; ++i) {
    mArray[i] = rhs.mArray[i];
  }
}

template <class T, unsigned int D>
GPUdi() T SVectorGPU<T, D>::apply(unsigned int i) const
{
  return mArray[i];
}

template <class T, unsigned int D>
GPUdi() const T* SVectorGPU<T, D>::Array() const
{
  return mArray;
}

template <class T, unsigned int D>
GPUdi() T* SVectorGPU<T, D>::Array()
{
  return mArray;
}

template <unsigned int I>
struct meta_dot {
  template <class A, class B, class T>
  static GPUdi() T f(const A& lhs, const B& rhs, const T& x)
  {
    return lhs.apply(I) * rhs.apply(I) + meta_dot<I - 1>::f(lhs, rhs, x);
  }
};

template <>
struct meta_dot<0> {
  template <class A, class B, class T>
  static GPUdi() T f(const A& lhs, const B& rhs, const T& /*x */)
  {
    return lhs.apply(0) * rhs.apply(0);
  }
};

template <class T, unsigned int D>
GPUdi() T Dot(const SVectorGPU<T, D>& lhs, const SVectorGPU<T, D>& rhs)
{
  return meta_dot<D - 1>::f(lhs, rhs, T());
}

template <class T, unsigned int D>
GPUdi() SVectorGPU<T, D>& SVectorGPU<T, D>::operator-=(const SVectorGPU<T, D>& rhs)
{
  for (unsigned int i = 0; i < D; ++i) {
    mArray[i] -= rhs.apply(i);
  }
  return *this;
}

template <class T, unsigned int D>
GPUd() SVectorGPU<T, D>& SVectorGPU<T, D>::operator+=(const SVectorGPU<T, D>& rhs)
{
  for (unsigned int i = 0; i < D; ++i) {
    mArray[i] += rhs.apply(i);
  }
  return *this;
}

template <unsigned int I>
struct meta_matrix_dot {

  template <class MatrixA, class MatrixB>
  static GPUdi() typename MatrixA::value_type f(const MatrixA& lhs,
                                                const MatrixB& rhs,
                                                const unsigned int offset)
  {
    return lhs.apply(offset / MatrixB::kCols * MatrixA::kCols + I) *
             rhs.apply(MatrixB::kCols * I + offset % MatrixB::kCols) +
           meta_matrix_dot<I - 1>::f(lhs, rhs, offset);
  }

  template <class MatrixA, class MatrixB>
  static GPUdi() typename MatrixA::value_type g(const MatrixA& lhs,
                                                const MatrixB& rhs,
                                                unsigned int i,
                                                unsigned int j)
  {
    return lhs(i, I) * rhs(I, j) +
           meta_matrix_dot<I - 1>::g(lhs, rhs, i, j);
  }
};

template <>
struct meta_matrix_dot<0> {

  template <class MatrixA, class MatrixB>
  static GPUdi() typename MatrixA::value_type f(const MatrixA& lhs,
                                                const MatrixB& rhs,
                                                const unsigned int offset)
  {
    return lhs.apply(offset / MatrixB::kCols * MatrixA::kCols) *
           rhs.apply(offset % MatrixB::kCols);
  }

  // multiplication using i and j
  template <class MatrixA, class MatrixB>
  static GPUdi() typename MatrixA::value_type g(const MatrixA& lhs,
                                                const MatrixB& rhs,
                                                unsigned int i, unsigned int j)
  {
    return lhs(i, 0) * rhs(0, j);
  }
};

namespace row_offsets_utils
{
template <int...>
struct indices {
};

template <int I, class IndexTuple, int N>
struct make_indices_impl;

template <int I, int... Indices, int N>
struct make_indices_impl<I, indices<Indices...>, N> {
  typedef typename make_indices_impl<I + 1, indices<Indices..., I>,
                                     N>::type type;
};

template <int N, int... Indices>
struct make_indices_impl<N, indices<Indices...>, N> {
  typedef indices<Indices...> type;
};

template <int N>
struct make_indices : make_indices_impl<0, indices<>, N> {
};

template <int I0, class F, int... I>
constexpr auto do_make(F f, indices<I...>) -> gpu::gpustd::array<int, sizeof...(I)>
{
  gpu::gpustd::array<int, sizeof...(I)> retarr = {f(I0 + I)...};
  return retarr;
}

template <int N, int I0 = 0, class F>
constexpr auto make(F f) -> gpu::gpustd::array<int, N>
{
  return do_make<I0>(f, typename make_indices<N>::type());
}
} // namespace row_offsets_utils

// Symm representation
template <class T, unsigned int D>
class MatRepSymGPU
{
 public:
  typedef T value_type;
  GPUdDefault() MatRepSymGPU() = default;
  GPUdi() T& operator()(unsigned int i, unsigned int j)
  {
    return mArray[offset(i, j)];
  }

  GPUdi() T const& operator()(unsigned int i, unsigned int j) const
  {
    return mArray[offset(i, j)];
  }

  GPUdi() T& operator[](unsigned int i)
  {
    return mArray[off(i)];
  }

  GPUdi() T const& operator[](unsigned int i) const
  {
    return mArray[off(i)];
  }

  GPUdi() T apply(unsigned int i) const
  {
    return mArray[off(i)];
  }

  GPUdi() T* Array() { return mArray; }

  GPUdi() const T* Array() const { return mArray; }

  // assignment: only symmetric to symmetric allowed
  template <class R>
  GPUdi() MatRepSymGPU<T, D>& operator=(const R&)
  {
    GPU_STATIC_CHECK(0 == 1, Check_symmetric_matrices_equivalence);
    return *this;
  }

  GPUdi() MatRepSymGPU<T, D>& operator=(const MatRepSymGPU& rhs)
  {
    for (unsigned int i = 0; i < kSize; ++i) {
      mArray[i] = rhs.Array()[i];
    }
    return *this;
  }

  enum {
    kRows = D,              // rows
    kCols = D,              // columns
    kSize = D * (D + 1) / 2 // rows*columns
  };

  static constexpr int off0(int i) { return i == 0 ? 0 : off0(i - 1) + i; }
  static constexpr int off2(int i, int j) { return j < i ? off0(i) + j : off0(j) + i; }
  static constexpr int off1(int i) { return off2(i / D, i % D); }

  static GPUdi() int off(int i)
  {
    static constexpr auto v = row_offsets_utils::make<D * D>(off1);
    return v[i];
  }

  static GPUdi() constexpr unsigned int offset(unsigned int i, unsigned int j)
  {
    return off(i * D + j);
  }

 private:
  T mArray[kSize];
};

/// SMatReprStd starting port here
template <class T, unsigned int D1, unsigned int D2 = D1>
class MatRepStdGPU
{
 public:
  typedef T value_type;
  GPUdDefault() MatRepStdGPU() = default;
  GPUdi() const T& operator()(unsigned int i, unsigned int j) const
  {
    return mArray[i * D2 + j];
  }
  GPUdi() T& operator()(unsigned int i, unsigned int j)
  {
    return mArray[i * D2 + j];
  }
  GPUdi() T& operator[](unsigned int i) { return mArray[i]; }
  GPUdi() const T& operator[](unsigned int i) const { return mArray[i]; }
  GPUdi() T apply(unsigned int i) const { return mArray[i]; }
  GPUdi() T* Array() { return mArray; }
  GPUdi() const T* Array() const { return mArray; }

  template <class R>
  GPUdi() MatRepStdGPU<T, D1, D2>& operator=(const R& rhs)
  {
    for (unsigned int i = 0; i < kSize; ++i) {
      mArray[i] = rhs[i];
    }
    return *this;
  }
  template <class R>
  GPUdi() bool operator==(const R& rhs) const
  {
    bool rc = true;
    for (unsigned int i = 0; i < kSize; ++i) {
      rc = rc && (mArray[i] == rhs[i]);
    }
    return rc;
  }
  enum {
    kRows = D1,     // rows
    kCols = D2,     // columns
    kSize = D1 * D2 // rows*columns
  };

 private:
  T mArray[kSize];
};

/// SMatrixGPU starting port here
struct SMatrixIdentity {
};
struct SMatrixNoInit {
};

// Expression utility to describe operations
template <class ExprType, class T, unsigned int D, unsigned int D2 = 1, class R1 = MatRepStdGPU<T, D, D2>>
class Expr
{
 public:
  typedef T value_type;
  GPUd() Expr(const ExprType& rhs) : mRhs(rhs) {} // NOLINT: False positive
  GPUdDefault() ~Expr() = default;
  GPUdi() T apply(unsigned int i) const
  {
    return mRhs.apply(i);
  }
  GPUdi() T operator()(unsigned int i, unsigned j) const
  {
    return mRhs(i, j);
  }
  GPUdi() bool IsInUse(const T* p) const
  {
    return mRhs.IsInUse(p);
  }

  enum {
    kRows = D,
    kCols = D2
  };

 private:
  ExprType mRhs;
};

template <class T, unsigned int D1, unsigned int D2 = D1, class R = MatRepStdGPU<T, D1, D2>>
class SMatrixGPU
{
 public:
  typedef T value_type;
  typedef R rep_type;
  typedef T* iterator;
  typedef const T* const_iterator;
  GPUdDefault() SMatrixGPU() = default;
  GPUdi() SMatrixGPU(SMatrixNoInit) {}
  GPUd() SMatrixGPU(SMatrixIdentity);
  GPUd() SMatrixGPU(const SMatrixGPU<T, D1, D2, R>& rhs);
  template <class A, class R2>
  GPUd() SMatrixGPU(const Expr<A, T, D1, D2, R2>& rhs);
  template <class M>
  GPUd() SMatrixGPU<T, D1, D2, R>& operator=(const M& rhs);
  template <class A, class R2>
  GPUd() SMatrixGPU<T, D1, D2, R>& operator=(const Expr<A, T, D1, D2, R2>& rhs);
  enum {
    kRows = D1,     // rows
    kCols = D2,     // columns
    kSize = D1 * D2 // rows*columns
  };
  GPUd() T apply(unsigned int i) const;
  GPUd() const T* Array() const;
  GPUd() T* Array();
  GPUd() iterator begin();
  GPUd() iterator end();
  GPUd() const T& operator()(unsigned int i, unsigned int j) const;
  GPUd() T& operator()(unsigned int i, unsigned int j);

  class SMatrixRowGPU
  {
   public:
    GPUd() SMatrixRowGPU(SMatrixGPU<T, D1, D2, R>& rhs, unsigned int i) : mMat(&rhs), mRow(i)
    {
    }
    GPUd() T& operator[](int j) { return (*mMat)(mRow, j); }
    //
   private:
    SMatrixGPU<T, D1, D2, R>* mMat;
    unsigned int mRow;
  };

  class SMatrixRowGPUconst
  {
   public:
    GPUd() SMatrixRowGPUconst(const SMatrixGPU<T, D1, D2, R>& rhs, unsigned int i) : mMat(&rhs), mRow(i)
    {
    }
    //
    GPUd() const T& operator[](int j) const { return (*mMat)(mRow, j); }
    //
   private:
    const SMatrixGPU<T, D1, D2, R>* mMat;
    unsigned int mRow;
  };

  GPUd() SMatrixRowGPUconst operator[](unsigned int i) const { return SMatrixRowGPUconst(*this, i); }
  GPUd() SMatrixRowGPU operator[](unsigned int i) { return SMatrixRowGPU(*this, i); }
  GPUd() bool Invert();
  GPUd() bool IsInUse(const T* p) const;

 public:
  R mRep;
};

template <class T, unsigned int D1, unsigned int D2, class R>
GPUdi() SMatrixGPU<T, D1, D2, R>::SMatrixGPU(SMatrixIdentity)
{
  for (unsigned int i = 0; i < R::kSize; ++i) {
    mRep.Array()[i] = 0;
  }
  if (D1 <= D2) {
    for (unsigned int i = 0; i < D1; ++i) {
      mRep[i * D2 + i] = 1;
    }
  } else {
    for (unsigned int i = 0; i < D2; ++i) {
      mRep[i * D2 + i] = 1;
    }
  }
}

template <class T, unsigned int D1, unsigned int D2, class R>
GPUdi() SMatrixGPU<T, D1, D2, R>::SMatrixGPU(const SMatrixGPU<T, D1, D2, R>& rhs)
{
  mRep = rhs.mRep;
}

template <class T, unsigned int D1, unsigned int D2, class R>
GPUdi() T* SMatrixGPU<T, D1, D2, R>::begin()
{
  return mRep.Array();
}

template <class T, unsigned int D1, unsigned int D2, class R>
GPUdi() T* SMatrixGPU<T, D1, D2, R>::end()
{
  return mRep.Array() + R::kSize;
}

template <class T, unsigned int D1, unsigned int D2, class R>
GPUdi() bool SMatrixGPU<T, D1, D2, R>::IsInUse(const T* p) const
{
  return p == mRep.Array();
}

template <class T, unsigned int D1, unsigned int D2, class A, class R1, class R2>
struct Assign {
  // Evaluate the expression from general to general matrices.
  GPUd() static void Evaluate(SMatrixGPU<T, D1, D2, R1>& lhs, const Expr<A, T, D1, D2, R2>& rhs)
  {
    if (!rhs.IsInUse(lhs.begin())) {
      unsigned int l = 0;
      for (unsigned int i = 0; i < D1; ++i) {
        for (unsigned int j = 0; j < D2; ++j) {
          lhs.mRep[l] = rhs(i, j);
          l++;
        }
      }
    } else {
      T tmp[D1 * D2];
      unsigned int l = 0;
      for (unsigned int i = 0; i < D1; ++i) {
        for (unsigned int j = 0; j < D2; ++j) {
          tmp[l] = rhs(i, j);
          l++;
        }
      }

      for (unsigned int i = 0; i < D1 * D2; ++i) {
        lhs.mRep[i] = tmp[i];
      }
    }
  }
};

template <class T, unsigned int D1, unsigned int D2, class A>
struct Assign<T, D1, D2, A, MatRepSymGPU<T, D1>, MatRepSymGPU<T, D1>> {
  // Evaluate the expression from  symmetric to symmetric matrices.
  GPUd() static void Evaluate(SMatrixGPU<T, D1, D2, MatRepSymGPU<T, D1>>& lhs,
                              const Expr<A, T, D1, D2, MatRepSymGPU<T, D1>>& rhs)
  {
    if (!rhs.IsInUse(lhs.begin())) {
      unsigned int l = 0;
      for (unsigned int i = 0; i < D1; ++i) {
        // storage of symmetric matrix is in lower block
        for (unsigned int j = 0; j <= i; ++j) {
          lhs.mRep.Array()[l] = rhs(i, j);
          l++;
        }
      }
    } else {
      T tmp[MatRepSymGPU<T, D1>::kSize];
      unsigned int l = 0;
      for (unsigned int i = 0; i < D1; ++i) {
        for (unsigned int j = 0; j <= i; ++j) {
          tmp[l] = rhs(i, j);
          l++;
        }
      }
      for (unsigned int i = 0; i < MatRepSymGPU<T, D1>::kSize; ++i) {
        lhs.mRep.Array()[i] = tmp[i];
      }
    }
  }
};

// avoid assigment from expression based on a general matrix to a symmetric matrix
template <class T, unsigned int D1, unsigned int D2, class A>
struct Assign<T, D1, D2, A, MatRepSymGPU<T, D1>, MatRepStdGPU<T, D1, D2>> {
  GPUd() static void Evaluate(SMatrixGPU<T, D1, D2, MatRepSymGPU<T, D1>>&,
                              const Expr<A, T, D1, D2, MatRepStdGPU<T, D1, D2>>&)
  {
    GPU_STATIC_CHECK(0 == 1, Check_general_to_symmetric_matrix_assignment);
  }
};

// Force Expression evaluation from general to symmetric
struct AssignSym {
  // assign a symmetric matrix from an expression
  template <class T, unsigned int D, class A, class R>
  GPUd() static void Evaluate(SMatrixGPU<T, D, D, MatRepSymGPU<T, D>>& lhs, const Expr<A, T, D, D, R>& rhs)
  {
    unsigned int l = 0;
    for (unsigned int i = 0; i < D; ++i) {
      for (unsigned int j = 0; j <= i; ++j) {
        lhs.mRep.Array()[l] = rhs(i, j);
        l++;
      }
    }
  }

  // assign the symmetric matrix from a general matrix
  template <class T, unsigned int D, class R>
  GPUd() static void Evaluate(SMatrixGPU<T, D, D, MatRepSymGPU<T, D>>& lhs, const SMatrixGPU<T, D, D, R>& rhs)
  {
    unsigned int l = 0;
    for (unsigned int i = 0; i < D; ++i) {
      for (unsigned int j = 0; j <= i; ++j) {
        lhs.mRep.Array()[l] = rhs(i, j);
        l++;
      }
    }
  }
};

template <class T, unsigned int D1, unsigned int D2, class R>
template <class A, class R2>
GPUdi() SMatrixGPU<T, D1, D2, R>& SMatrixGPU<T, D1, D2, R>::operator=(const Expr<A, T, D1, D2, R2>& rhs)
{
  Assign<T, D1, D2, A, R, R2>::Evaluate(*this, rhs);
  return *this;
}

template <class T, unsigned int D1, unsigned int D2, class R>
template <class M>
GPUdi() SMatrixGPU<T, D1, D2, R>& SMatrixGPU<T, D1, D2, R>::operator=(const M& rhs)
{
  mRep = rhs.mRep;
  return *this;
}

template <class T, unsigned int D1, unsigned int D2, class R>
template <class A, class R2>
GPUdi() SMatrixGPU<T, D1, D2, R>::SMatrixGPU(const Expr<A, T, D1, D2, R2>& rhs)
{
  operator=(rhs);
}

template <class T, unsigned int D1, unsigned int D2, class R>
GPUdi() const T& SMatrixGPU<T, D1, D2, R>::operator()(unsigned int i, unsigned int j) const
{
  return mRep(i, j);
}

template <class T, unsigned int D1, unsigned int D2, class R>
GPUdi() T& SMatrixGPU<T, D1, D2, R>::operator()(unsigned int i, unsigned int j)
{
  return mRep(i, j);
}

template <class T, class R1, class R2>
struct MultPolicyGPU {
  enum {
    N1 = R1::kRows,
    N2 = R2::kCols
  };
  typedef MatRepStdGPU<T, N1, N2> RepType;
};

template <class MatrixA, class MatrixB, class T, unsigned int D>
class MatrixMulOpGPU
{
 public:
  GPUd() MatrixMulOpGPU(const MatrixA& lhs, const MatrixB& rhs) : lhs_(lhs), rhs_(rhs) {}
  GPUdDefault() ~MatrixMulOpGPU() = default;
  GPUdi() T apply(unsigned int i) const
  {
    return meta_matrix_dot<D - 1>::f(lhs_, rhs_, i);
  }

  GPUdi() T operator()(unsigned int i, unsigned int j) const
  {
    return meta_matrix_dot<D - 1>::g(lhs_, rhs_, i, j);
  }

  GPUdi() bool IsInUse(const T* p) const
  {
    return lhs_.IsInUse(p) || rhs_.IsInUse(p);
  }

 protected:
  const MatrixA& lhs_;
  const MatrixB& rhs_;
};

template <class T, unsigned int D1, unsigned int D, unsigned int D2, class R1, class R2>
GPUdi() Expr<MatrixMulOpGPU<SMatrixGPU<T, D1, D, R1>, SMatrixGPU<T, D, D2, R2>, T, D>, T, D1, D2, typename MultPolicyGPU<T, R1, R2>::RepType>
  operator*(const SMatrixGPU<T, D1, D, R1>& lhs, const SMatrixGPU<T, D, D2, R2>& rhs)
{
  typedef MatrixMulOpGPU<SMatrixGPU<T, D1, D, R1>, SMatrixGPU<T, D, D2, R2>, T, D> MatMulOp;
  return Expr<MatMulOp, T, D1, D2,
              typename MultPolicyGPU<T, R1, R2>::RepType>(MatMulOp(lhs, rhs));
}

/// Inversion
template <unsigned int D, unsigned int N = D>
class Inverter
{
 public:
  // generic square matrix using LU factorization
  template <class MatrixRep>
  GPUd() static bool Dinv(MatrixRep& rhs)
  {
    unsigned int work[N + 1] = {0};
    typename MatrixRep::value_type det(0.0);

    if (DfactMatrix(rhs, det, work) != 0) {
      return false;
    }

    int ifail = DfinvMatrix(rhs, work);
    if (ifail == 0) {
      return true;
    }
    return false;
  }

  //  symmetric matrix inversion (Bunch-kaufman pivoting)
  template <class T>
  GPUd() static bool Dinv(MatRepSymGPU<T, D>& rhs)
  {
    int ifail{0};
    InvertBunchKaufman(rhs, ifail);
    if (!ifail) {
      return true;
    }
    return false;
  }

  // LU Factorization method for inversion of general square matrices
  template <class T>
  GPUd() static int DfactMatrix(MatRepStdGPU<T, D, N>& rhs, T& det, unsigned int* work);

  // LU inversion of general square matrices. To be called after DFactMatrix
  template <class T>
  GPUd() static int DfinvMatrix(MatRepStdGPU<T, D, N>& rhs, unsigned int* work);

  // Bunch-Kaufman method for inversion of symmetric matrices
  template <class T>
  GPUd() static void InvertBunchKaufman(MatRepSymGPU<T, D>& rhs, int& ifail);
};

template <unsigned int D, unsigned int N>
template <class T>
GPUdi() void Inverter<D, N>::InvertBunchKaufman(MatRepSymGPU<T, D>& rhs, int& ifail)
{
  typedef T value_type;
  int i, j, k, s;
  int pivrow;
  const int nrow = MatRepSymGPU<T, D>::kRows;

  SVectorGPU<T, MatRepSymGPU<T, D>::kRows> xvec;
  SVectorGPU<int, MatRepSymGPU<T, D>::kRows> pivv;

  typedef int* pivIter;
  typedef T* mIter;

  mIter x = xvec.begin();
  // x[i] is used as helper storage, needs to have at least size nrow.
  pivIter piv = pivv.begin();
  // piv[i] is used to store details of exchanges

  value_type temp1, temp2;
  mIter ip, mjj, iq;
  value_type lambda, sigma;
  const value_type alpha = .6404; // = (1+sqrt(17))/8
  // LM (04/2009) remove this useless check (it is not in LAPACK) which fails inversion of
  // a matrix with  values < epsilon in the diagonal
  //
  // const double epsilon = 32*std::numeric_limits<T>::epsilon();
  // whenever a sum of two doubles is below or equal to epsilon
  // it is set to zero.
  // this constant could be set to zero but then the algorithm
  // doesn't neccessarily detect that a matrix is singular

  for (i = 0; i < nrow; i++) {
    piv[i] = i + 1;
  }

  ifail = 0;

  // compute the factorization P*A*P^T = L * D * L^T
  // L is unit lower triangular, D is direct sum of 1x1 and 2x2 matrices
  // L and D^-1 are stored in A = *this, P is stored in piv[]

  for (j = 1; j < nrow; j += s) // main loop over columns
  {
    mjj = rhs.Array() + j * (j - 1) / 2 + j - 1;
    lambda = 0; // compute lambda = max of A(j+1:n,j)
    pivrow = j + 1;
    ip = rhs.Array() + (j + 1) * j / 2 + j - 1;
    for (i = j + 1; i <= nrow; ip += i++) {
      if (o2::gpu::GPUCommonMath::Abs(*ip) > lambda) {
        lambda = o2::gpu::GPUCommonMath::Abs(*ip);
        pivrow = i;
      }
    }

    if (lambda == 0) {
      if (*mjj == 0) {
        ifail = 1;
        return;
      }
      s = 1;
      *mjj = 1.0f / *mjj;
    } else {
      if (o2::gpu::GPUCommonMath::Abs(*mjj) >= lambda * alpha) {
        s = 1;
        pivrow = j;
      } else {
        sigma = 0; // compute sigma = max A(pivrow, j:pivrow-1)
        ip = rhs.Array() + pivrow * (pivrow - 1) / 2 + j - 1;
        for (k = j; k < pivrow; k++) {
          if (o2::gpu::GPUCommonMath::Abs(*ip) > sigma) {
            sigma = o2::gpu::GPUCommonMath::Abs(*ip);
          }
          ip++;
        }
        // sigma cannot be zero because it is at least lambda which is not zero
        if (o2::gpu::GPUCommonMath::Abs(*mjj) >= alpha * lambda * (lambda / sigma)) {
          s = 1;
          pivrow = j;
        } else if (o2::gpu::GPUCommonMath::Abs(*(rhs.Array() + pivrow * (pivrow - 1) / 2 + pivrow - 1)) >= alpha * sigma) {
          s = 1;
        } else {
          s = 2;
        }
      }
      if (pivrow == j) // no permutation neccessary
      {
        piv[j - 1] = pivrow;
        if (*mjj == 0) {
          ifail = 1;
          return;
        }
        temp2 = *mjj = 1.0f / *mjj; // invert D(j,j)

        // update A(j+1:n, j+1,n)
        for (i = j + 1; i <= nrow; i++) {
          temp1 = *(rhs.Array() + i * (i - 1) / 2 + j - 1) * temp2;
          ip = rhs.Array() + i * (i - 1) / 2 + j;
          for (k = j + 1; k <= i; k++) {
            *ip -= static_cast<T>(temp1 * *(rhs.Array() + k * (k - 1) / 2 + j - 1));
            //                   if (o2::gpu::GPUCommonMath::Abs(*ip) <= epsilon)
            //                      *ip=0;
            ip++;
          }
        }
        // update L
        ip = rhs.Array() + (j + 1) * j / 2 + j - 1;
        for (i = j + 1; i <= nrow; ip += i++) {
          *ip *= static_cast<T>(temp2);
        }
      } else if (s == 1) // 1x1 pivot
      {
        piv[j - 1] = pivrow;

        // interchange rows and columns j and pivrow in
        // submatrix (j:n,j:n)
        ip = rhs.Array() + pivrow * (pivrow - 1) / 2 + j;
        for (i = j + 1; i < pivrow; i++, ip++) {
          temp1 = *(rhs.Array() + i * (i - 1) / 2 + j - 1);
          *(rhs.Array() + i * (i - 1) / 2 + j - 1) = *ip;
          *ip = static_cast<T>(temp1);
        }
        temp1 = *mjj;
        *mjj = *(rhs.Array() + pivrow * (pivrow - 1) / 2 + pivrow - 1);
        *(rhs.Array() + pivrow * (pivrow - 1) / 2 + pivrow - 1) = static_cast<T>(temp1);
        ip = rhs.Array() + (pivrow + 1) * pivrow / 2 + j - 1;
        iq = ip + pivrow - j;
        for (i = pivrow + 1; i <= nrow; ip += i, iq += i++) {
          temp1 = *iq;
          *iq = *ip;
          *ip = static_cast<T>(temp1);
        }

        if (*mjj == 0) {
          ifail = 1;
          return;
        }
        temp2 = *mjj = 1.0f / *mjj; // invert D(j,j)

        // update A(j+1:n, j+1:n)
        for (i = j + 1; i <= nrow; i++) {
          temp1 = *(rhs.Array() + i * (i - 1) / 2 + j - 1) * temp2;
          ip = rhs.Array() + i * (i - 1) / 2 + j;
          for (k = j + 1; k <= i; k++) {
            *ip -= static_cast<T>(temp1 * *(rhs.Array() + k * (k - 1) / 2 + j - 1));
            //                   if (o2::gpu::GPUCommonMath::Abs(*ip) <= epsilon)
            //                      *ip=0;
            ip++;
          }
        }
        // update L
        ip = rhs.Array() + (j + 1) * j / 2 + j - 1;
        for (i = j + 1; i <= nrow; ip += i++) {
          *ip *= static_cast<T>(temp2);
        }
      } else // s=2, ie use a 2x2 pivot
      {
        piv[j - 1] = -pivrow;
        piv[j] = 0; // that means this is the second row of a 2x2 pivot

        if (j + 1 != pivrow) {
          // interchange rows and columns j+1 and pivrow in
          // submatrix (j:n,j:n)
          ip = rhs.Array() + pivrow * (pivrow - 1) / 2 + j + 1;
          for (i = j + 2; i < pivrow; i++, ip++) {
            temp1 = *(rhs.Array() + i * (i - 1) / 2 + j);
            *(rhs.Array() + i * (i - 1) / 2 + j) = *ip;
            *ip = static_cast<T>(temp1);
          }
          temp1 = *(mjj + j + 1);
          *(mjj + j + 1) =
            *(rhs.Array() + pivrow * (pivrow - 1) / 2 + pivrow - 1);
          *(rhs.Array() + pivrow * (pivrow - 1) / 2 + pivrow - 1) = static_cast<T>(temp1);
          temp1 = *(mjj + j);
          *(mjj + j) = *(rhs.Array() + pivrow * (pivrow - 1) / 2 + j - 1);
          *(rhs.Array() + pivrow * (pivrow - 1) / 2 + j - 1) = static_cast<T>(temp1);
          ip = rhs.Array() + (pivrow + 1) * pivrow / 2 + j;
          iq = ip + pivrow - (j + 1);
          for (i = pivrow + 1; i <= nrow; ip += i, iq += i++) {
            temp1 = *iq;
            *iq = *ip;
            *ip = static_cast<T>(temp1);
          }
        }
        // invert D(j:j+1,j:j+1)
        temp2 = *mjj * *(mjj + j + 1) - *(mjj + j) * *(mjj + j);
        if (temp2 == 0) {
          printf("SymMatrix::bunch_invert: error in pivot choice");
        }
        temp2 = 1. / temp2;
        // this quotient is guaranteed to exist by the choice
        // of the pivot
        temp1 = *mjj;
        *mjj = static_cast<T>(*(mjj + j + 1) * temp2);
        *(mjj + j + 1) = static_cast<T>(temp1 * temp2);
        *(mjj + j) = static_cast<T>(-*(mjj + j) * temp2);

        if (j < nrow - 1) // otherwise do nothing
        {
          // update A(j+2:n, j+2:n)
          for (i = j + 2; i <= nrow; i++) {
            ip = rhs.Array() + i * (i - 1) / 2 + j - 1;
            temp1 = *ip * *mjj + *(ip + 1) * *(mjj + j);
            //                   if (o2::gpu::GPUCommonMath::Abs(temp1 ) <= epsilon)
            //                      temp1 = 0;
            temp2 = *ip * *(mjj + j) + *(ip + 1) * *(mjj + j + 1);
            //                   if (o2::gpu::GPUCommonMath::Abs(temp2 ) <= epsilon)
            //                      temp2 = 0;
            for (k = j + 2; k <= i; k++) {
              ip = rhs.Array() + i * (i - 1) / 2 + k - 1;
              iq = rhs.Array() + k * (k - 1) / 2 + j - 1;
              *ip -= static_cast<T>(temp1 * *iq + temp2 * *(iq + 1));
              //                      if (o2::gpu::GPUCommonMath::Abs(*ip) <= epsilon)
              //                         *ip = 0;
            }
          }
          // update L
          for (i = j + 2; i <= nrow; i++) {
            ip = rhs.Array() + i * (i - 1) / 2 + j - 1;
            temp1 = *ip * *mjj + *(ip + 1) * *(mjj + j);
            //                   if (o2::gpu::GPUCommonMath::Abs(temp1) <= epsilon)
            //                      temp1 = 0;
            *(ip + 1) = *ip * *(mjj + j) + *(ip + 1) * *(mjj + j + 1);
            //                   if (o2::gpu::GPUCommonMath::Abs(*(ip+1)) <= epsilon)
            //                      *(ip+1) = 0;
            *ip = static_cast<T>(temp1);
          }
        }
      }
    }
  } // end of main loop over columns

  if (j == nrow) // the the last pivot is 1x1
  {
    mjj = rhs.Array() + j * (j - 1) / 2 + j - 1;
    if (*mjj == 0) {
      ifail = 1;
      return;
    } else {
      *mjj = 1.0f / *mjj;
    }
  } // end of last pivot code

  // computing the inverse from the factorization

  for (j = nrow; j >= 1; j -= s) // loop over columns
  {
    mjj = rhs.Array() + j * (j - 1) / 2 + j - 1;
    if (piv[j - 1] > 0) // 1x1 pivot, compute column j of inverse
    {
      s = 1;
      if (j < nrow) {
        ip = rhs.Array() + (j + 1) * j / 2 + j - 1;
        for (i = 0; i < nrow - j; ip += 1 + j + i++) {
          x[i] = *ip;
        }
        for (i = j + 1; i <= nrow; i++) {
          temp2 = 0;
          ip = rhs.Array() + i * (i - 1) / 2 + j;
          for (k = 0; k <= i - j - 1; k++) {
            temp2 += *ip++ * x[k];
          }
          for (ip += i - 1; k < nrow - j; ip += 1 + j + k++) {
            temp2 += *ip * x[k];
          }
          *(rhs.Array() + i * (i - 1) / 2 + j - 1) = static_cast<T>(-temp2);
        }
        temp2 = 0;
        ip = rhs.Array() + (j + 1) * j / 2 + j - 1;
        for (k = 0; k < nrow - j; ip += 1 + j + k++) {
          temp2 += x[k] * *ip;
        }
        *mjj -= static_cast<T>(temp2);
      }
    } else //2x2 pivot, compute columns j and j-1 of the inverse
    {
      if (piv[j - 1] != 0) {
        printf("error in piv %lf \n", piv[j - 1]);
      }
      s = 2;
      if (j < nrow) {
        ip = rhs.Array() + (j + 1) * j / 2 + j - 1;
        for (i = 0; i < nrow - j; ip += 1 + j + i++) {
          x[i] = *ip;
        }
        for (i = j + 1; i <= nrow; i++) {
          temp2 = 0;
          ip = rhs.Array() + i * (i - 1) / 2 + j;
          for (k = 0; k <= i - j - 1; k++) {
            temp2 += *ip++ * x[k];
          }
          for (ip += i - 1; k < nrow - j; ip += 1 + j + k++) {
            temp2 += *ip * x[k];
          }
          *(rhs.Array() + i * (i - 1) / 2 + j - 1) = static_cast<T>(-temp2);
        }
        temp2 = 0;
        ip = rhs.Array() + (j + 1) * j / 2 + j - 1;
        for (k = 0; k < nrow - j; ip += 1 + j + k++) {
          temp2 += x[k] * *ip;
        }
        *mjj -= static_cast<T>(temp2);
        temp2 = 0;
        ip = rhs.Array() + (j + 1) * j / 2 + j - 2;
        for (i = j + 1; i <= nrow; ip += i++) {
          temp2 += *ip * *(ip + 1);
        }
        *(mjj - 1) -= static_cast<T>(temp2);
        ip = rhs.Array() + (j + 1) * j / 2 + j - 2;
        for (i = 0; i < nrow - j; ip += 1 + j + i++) {
          x[i] = *ip;
        }
        for (i = j + 1; i <= nrow; i++) {
          temp2 = 0;
          ip = rhs.Array() + i * (i - 1) / 2 + j;
          for (k = 0; k <= i - j - 1; k++) {
            temp2 += *ip++ * x[k];
          }
          for (ip += i - 1; k < nrow - j; ip += 1 + j + k++) {
            temp2 += *ip * x[k];
          }
          *(rhs.Array() + i * (i - 1) / 2 + j - 2) = static_cast<T>(-temp2);
        }
        temp2 = 0;
        ip = rhs.Array() + (j + 1) * j / 2 + j - 2;
        for (k = 0; k < nrow - j; ip += 1 + j + k++) {
          temp2 += x[k] * *ip;
        }
        *(mjj - j) -= static_cast<T>(temp2);
      }
    }

    // interchange rows and columns j and piv[j-1]
    // or rows and columns j and -piv[j-2]

    pivrow = (piv[j - 1] == 0) ? -piv[j - 2] : piv[j - 1];
    ip = rhs.Array() + pivrow * (pivrow - 1) / 2 + j;
    for (i = j + 1; i < pivrow; i++, ip++) {
      temp1 = *(rhs.Array() + i * (i - 1) / 2 + j - 1);
      *(rhs.Array() + i * (i - 1) / 2 + j - 1) = *ip;
      *ip = static_cast<T>(temp1);
    }
    temp1 = *mjj;
    *mjj = *(rhs.Array() + pivrow * (pivrow - 1) / 2 + pivrow - 1);
    *(rhs.Array() + pivrow * (pivrow - 1) / 2 + pivrow - 1) = static_cast<T>(temp1);
    if (s == 2) {
      temp1 = *(mjj - 1);
      *(mjj - 1) = *(rhs.Array() + pivrow * (pivrow - 1) / 2 + j - 2);
      *(rhs.Array() + pivrow * (pivrow - 1) / 2 + j - 2) = static_cast<T>(temp1);
    }

    ip = rhs.Array() + (pivrow + 1) * pivrow / 2 + j - 1; // &A(i,j)
    iq = ip + pivrow - j;
    for (i = pivrow + 1; i <= nrow; ip += i, iq += i++) {
      temp1 = *iq;
      *iq = *ip;
      *ip = static_cast<T>(temp1);
    }
  } // end of loop over columns (in computing inverse from factorization)

  return; // inversion successful
}

// LU factorization
template <unsigned int D, unsigned int n>
template <class T>
GPUdi() int Inverter<D, n>::DfactMatrix(MatRepStdGPU<T, D, n>& rhs, T& det, unsigned int* ir)
{
  if (D != n) {
    return -1;
  }

  int ifail, jfail;
  typedef T* mIter;

  typedef T value_type;

  value_type tf;
  value_type g1 = 1.0e-19, g2 = 1.0e19;

  value_type p, q, t;
  value_type s11, s12;

  // LM (04.09) : remove useless check on epsilon and set it to zero
  const value_type epsilon = 0.0;
  // double epsilon = 8*std::numeric_limits<T>::epsilon();
  // could be set to zero (like it was before)
  // but then the algorithm often doesn't detect
  // that a matrix is singular

  int normal = 0, imposs = -1;
  int jrange = 0, jover = 1, junder = -1;
  ifail = normal;
  jfail = jrange;
  int nxch = 0;
  det = 1.0;
  mIter mj = rhs.Array();
  mIter mjj = mj;
  for (unsigned int j = 1; j <= n; j++) {
    unsigned int k = j;
    p = (o2::gpu::GPUCommonMath::Abs(*mjj));
    if (j != n) {
      mIter mij = mj + n + j - 1;
      for (unsigned int i = j + 1; i <= n; i++) {
        q = (o2::gpu::GPUCommonMath::Abs(*(mij)));
        if (q > p) {
          k = i;
          p = q;
        }
        mij += n;
      }
      if (k == j) {
        if (p <= epsilon) {
          det = 0;
          ifail = imposs;
          jfail = jrange;
          return ifail;
        }
        det = -det; // in this case the sign of the determinant
                    // must not change. So I change it twice.
      }
      mIter mjl = mj;
      mIter mkl = rhs.Array() + (k - 1) * n;
      for (unsigned int l = 1; l <= n; l++) {
        tf = *mjl;
        *(mjl++) = *mkl;
        *(mkl++) = static_cast<T>(tf);
      }
      nxch = nxch + 1; // this makes the determinant change its sign
      ir[nxch] = (((j) << 12) + (k));
    } else {
      if (p <= epsilon) {
        det = 0.0;
        ifail = imposs;
        jfail = jrange;
        return ifail;
      }
    }
    det *= *mjj;
    *mjj = 1.0f / *mjj;
    t = (o2::gpu::GPUCommonMath::Abs(det));
    if (t < g1) {
      det = 0.0;
      if (jfail == jrange) {
        jfail = junder;
      }
    } else if (t > g2) {
      det = 1.0;
      if (jfail == jrange) {
        jfail = jover;
      }
    }
    if (j != n) {
      mIter mk = mj + n;
      mIter mkjp = mk + j;
      mIter mjk = mj + j;
      for (k = j + 1; k <= n; k++) {
        s11 = -(*mjk);
        s12 = -(*mkjp);
        if (j != 1) {
          mIter mik = rhs.Array() + k - 1;
          mIter mijp = rhs.Array() + j;
          mIter mki = mk;
          mIter mji = mj;
          for (unsigned int i = 1; i < j; i++) {
            s11 += (*mik) * (*(mji++));
            s12 += (*mijp) * (*(mki++));
            mik += n;
            mijp += n;
          }
        }
        // cast to avoid warnings from double to float conversions
        *(mjk++) = static_cast<T>(-s11 * (*mjj));
        *(mkjp) = static_cast<T>(-(((*(mjj + 1))) * ((*(mkjp - 1))) + (s12)));
        mk += n;
        mkjp += n;
      }
    }
    mj += n;
    mjj += (n + 1);
  }
  if (nxch % 2 == 1) {
    det = -det;
  }
  if (jfail != jrange) {
    det = 0.0;
  }
  ir[n] = nxch;
  return 0;
}

template <unsigned int D, unsigned int n>
template <class T>
GPUdi() int Inverter<D, n>::DfinvMatrix(MatRepStdGPU<T, D, n>& rhs, unsigned int* ir)
{
  typedef T* mIter;
  typedef T value_type;

  if (D != n) {
    return -1;
  }

  value_type s31, s32;
  value_type s33, s34;

  mIter m11 = rhs.Array();
  mIter m12 = m11 + 1;
  mIter m21 = m11 + n;
  mIter m22 = m12 + n;
  *m21 = -(*m22) * (*m11) * (*m21);
  *m12 = -(*m12);
  if (n > 2) {
    mIter mi = rhs.Array() + 2 * n;
    mIter mii = rhs.Array() + 2 * n + 2;
    mIter mimim = rhs.Array() + n + 1;
    for (unsigned int i = 3; i <= n; i++) {
      unsigned int im2 = i - 2;
      mIter mj = rhs.Array();
      mIter mji = mj + i - 1;
      mIter mij = mi;
      for (unsigned int j = 1; j <= im2; j++) {
        s31 = 0.0;
        s32 = *mji;
        mIter mkj = mj + j - 1;
        mIter mik = mi + j - 1;
        mIter mjkp = mj + j;
        mIter mkpi = mj + n + i - 1;
        for (unsigned int k = j; k <= im2; k++) {
          s31 += (*mkj) * (*(mik++));
          s32 += (*(mjkp++)) * (*mkpi);
          mkj += n;
          mkpi += n;
        }
        *mij = static_cast<T>(-(*mii) * (((*(mij - n))) * ((*(mii - 1))) + (s31)));
        *mji = static_cast<T>(-s32);
        mj += n;
        mji += n;
        mij++;
      }
      *(mii - 1) = -(*mii) * (*mimim) * (*(mii - 1));
      *(mimim + 1) = -(*(mimim + 1));
      mi += n;
      mimim += (n + 1);
      mii += (n + 1);
    }
  }
  mIter mi = rhs.Array();
  mIter mii = rhs.Array();
  for (unsigned int i = 1; i < n; i++) {
    unsigned int ni = n - i;
    mIter mij = mi;
    //int j;
    for (unsigned j = 1; j <= i; j++) {
      s33 = *mij;
      mIter mikj = mi + n + j - 1;
      mIter miik = mii + 1;
      mIter min_end = mi + n;
      for (; miik < min_end;) {
        s33 += (*mikj) * (*(miik++));
        mikj += n;
      }
      *(mij++) = static_cast<T>(s33);
    }
    for (unsigned j = 1; j <= ni; j++) {
      s34 = 0.0;
      mIter miik = mii + j;
      mIter mikij = mii + j * n + j;
      for (unsigned int k = j; k <= ni; k++) {
        s34 += *mikij * (*(miik++));
        mikij += n;
      }
      *(mii + j) = s34;
    }
    mi += n;
    mii += (n + 1);
  }
  unsigned int nxch = ir[n];
  if (nxch == 0) {
    return 0;
  }
  for (unsigned int mm = 1; mm <= nxch; mm++) {
    unsigned int k = nxch - mm + 1;
    int ij = ir[k];
    int i = ij >> 12;
    int j = ij % 4096;
    mIter mki = rhs.Array() + i - 1;
    mIter mkj = rhs.Array() + j - 1;
    for (k = 1; k <= n; k++) {
      T ti = *mki;
      *mki = *mkj;
      *mkj = ti;
      mki += n;
      mkj += n;
    }
  }
  return 0;
}

template <class T, unsigned int D1, unsigned int D2, class R>
GPUdi() bool SMatrixGPU<T, D1, D2, R>::Invert()
{
  GPU_STATIC_CHECK(D1 == D2, SMatrixGPU_not_square);
  return Inverter<D1, D2>::Dinv((*this).mRep);
}

template <class T, unsigned int D1, unsigned int D2, class R>
struct TranspPolicyGPU {
  enum {
    N1 = R::kRows,
    N2 = R::kCols
  };
  typedef MatRepStdGPU<T, N2, N1> RepType;
};

template <class T, unsigned int D1, unsigned int D2>
struct TranspPolicyGPU<T, D1, D2, MatRepSymGPU<T, D1>> {
  typedef MatRepSymGPU<T, D1> RepType;
};

template <class Matrix, class T, unsigned int D1, unsigned int D2 = D1>
class TransposeOpGPU
{
 public:
  GPUd() TransposeOpGPU(const Matrix& rhs) : mRhs(rhs) {}

  GPUdDefault() ~TransposeOpGPU() = default;

  GPUdi() T apply(unsigned int i) const
  {
    return mRhs.apply((i % D1) * D2 + i / D1);
  }
  GPUdi() T operator()(unsigned int i, unsigned j) const
  {
    return mRhs(j, i);
  }

  GPUdi() bool IsInUse(const T* p) const
  {
    return mRhs.IsInUse(p);
  }

 protected:
  const Matrix& mRhs;
};

template <class T, unsigned int D1, unsigned int D2, class R>
GPUdi() SVectorGPU<T, D1> operator*(const SMatrixGPU<T, D1, D2, R>& rhs, const SVectorGPU<T, D2>& lhs)
{
  SVectorGPU<T, D1> tmp;
  for (unsigned int i = 0; i < D1; ++i) {
    const unsigned int rpos = i * D2;
    for (unsigned int j = 0; j < D2; ++j) {
      tmp[i] += rhs.apply(rpos + j) * lhs.apply(j);
    }
  }
  return tmp;
}

template <class T, unsigned int D1, unsigned int D2, class R>
GPUdi() Expr<TransposeOpGPU<SMatrixGPU<T, D1, D2, R>, T, D1, D2>, T, D2, D1, typename TranspPolicyGPU<T, D1, D2, R>::RepType> Transpose(const SMatrixGPU<T, D1, D2, R>& rhs)
{
  typedef TransposeOpGPU<SMatrixGPU<T, D1, D2, R>, T, D1, D2> MatTrOp;
  return Expr<MatTrOp, T, D2, D1, typename TranspPolicyGPU<T, D1, D2, R>::RepType>(MatTrOp(rhs));
}

template <class T, unsigned int D1, unsigned int D2, class R>
GPUdi() SMatrixGPU<T, D1, D1, MatRepSymGPU<T, D1>> Similarity(const SMatrixGPU<T, D1, D2, R>& lhs, const SMatrixGPU<T, D2, D2, MatRepSymGPU<T, D2>>& rhs)
{
  SMatrixGPU<T, D1, D2, MatRepStdGPU<T, D1, D2>> tmp = lhs * rhs;
  typedef SMatrixGPU<T, D1, D1, MatRepSymGPU<T, D1>> SMatrixSym;
  SMatrixSym mret;
  AssignSym::Evaluate(mret, tmp * Transpose(lhs));
  return mret;
}
}; // namespace o2::math_utils
#endif

#undef  _BACKWARD_BACKWARD_WARNING_H

In file included from G__O2DetectorsCommonDataFormats dictionary payload:696:
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/CommonUtils/NameConf.h:27:25: error: implicit instantiation of undefined template 'o2::conf::ConfigurableParamHelper<o2::base::NameConf>'
class NameConf : public o2::conf::ConfigurableParamHelper<NameConf>
                        ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/DetectorsRaw/HBFUtils.h:146:3: note: template is declared here
  O2ParamDef(HBFUtils, "HBFUtils");
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/CommonUtils/ConfigurableParam.h:331:26: note: expanded from macro 'O2ParamDef'
  friend class o2::conf::ConfigurableParamHelper;
                         ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:288:7: error: constructor for 'std::_Vector_base<int, std::allocator<int> >' must explicitly initialize the member '_M_impl' which does not have a default constructor
      _Vector_base() = default;
      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:487:7: note: in implicit default constructor for 'std::_Vector_base<int, std::allocator<int> >' first required here
      vector() = default;
      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:91:29: note: in implicit default constructor for 'std::vector<int, std::allocator<int> >' first required here
  std::vector<symbol_t> mLut{};
                            ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:340:20: note: member is declared here
      _Vector_impl _M_impl;
                   ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:128:14: note: 'std::_Vector_base<int, std::allocator<int> >::_Vector_impl' declared here
      struct _Vector_impl
             ^
In file included from G__O2MathUtils dictionary payload:1139:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/Framework/Logger.h:14:
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:300:18: error: use of overloaded operator '<<' is ambiguous (with operand types 'std::ostringstream' (aka 'basic_ostringstream<char>') and 'const double')
        fContent << t;
        ~~~~~~~~ ^  ~
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/FrequencyTable.h:273:55: note: in instantiation of function template specialization 'fair::Logger::operator<<<double>' requested here
  LOG(debug1) << __func__ << " inclusive time (ms): " << t.getDurationMS();
                                                      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/FrequencyTable.h:291:3: note: in instantiation of function template specialization 'o2::rans::FrequencyTable::addFrequencies<const unsigned int *, true>' requested here
  addFrequencies(other.cbegin(), other.cend(), other.getMinSymbol(), true);
  ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:517:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:511:5: note: candidate function [with _CharT = char, _Traits = std::char_traits<char>]
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:523:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:528:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TString.h:470:16: note: candidate function
std::ostream  &operator<<(std::ostream &str, const TString &s);
               ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TTimeStamp.h:59:15: note: candidate function
std::ostream &operator<<(std::ostream &os,  const TTimeStamp &ts);
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBits.h:184:22: note: candidate function
inline std::ostream &operator<<(std::ostream& os, const TBits& rhs)
                     ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TGeoVector3.h:194:15: note: candidate function
std::ostream &operator<<(std::ostream &os, ROOT::Geom::Vertex_t const &vec);
              ^
In file included from G__O2MathUtils dictionary payload:1139:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/Framework/Logger.h:14:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:27:
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1855:71: error: no member named 'value' in 'fmt::v8::detail::type_constant<const unsigned long &, char>'
            detail::mapped_type_constant<remove_cvref_t<T>, Context>::value>(
                                                                      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1872:10: note: in instantiation of function template specialization 'fmt::v8::format_arg_store<fmt::v8::basic_format_context<fmt::v8::appender, char>, unsigned long>::format_arg_store<unsigned long &>' requested here
  return {std::forward<Args>(args)...};
         ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3119:28: note: in instantiation of function template specialization 'fmt::v8::make_format_args<fmt::v8::basic_format_context<fmt::v8::appender, char>, unsigned long &>' requested here
  return vformat(fmt, fmt::make_format_args(args...));
                           ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/RenormedFrequencyTable.h:41:37: note: in instantiation of function template specialization 'fmt::v8::format<unsigned long>' requested here
      throw std::runtime_error{fmt::format("FrequencyTable needs to be renormed to {} Bits.", this->getRenormingBits())};
                                    ^
In file included from G__O2MathUtils dictionary payload:1139:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/Framework/Logger.h:14:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:27:
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1688:68: error: no member named 'value' in 'fmt::v8::detail::type_constant<const unsigned long &, char>'
  return static_cast<unsigned>(mapped_type_constant<Arg, Context>::value) |
                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1840:28: note: in instantiation of function template specialization 'fmt::v8::detail::encode_types<fmt::v8::basic_format_context<fmt::v8::appender, char>, unsigned long>' requested here
      (is_packed ? detail::encode_types<Context, Args...>()
                           ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1953:63: note: in instantiation of static data member 'fmt::v8::format_arg_store<fmt::v8::basic_format_context<fmt::v8::appender, char>, unsigned long>::desc' requested here
      : basic_format_args(format_arg_store<Context, Args...>::desc,
                                                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3119:23: note: in instantiation of function template specialization 'fmt::v8::basic_format_args<fmt::v8::basic_format_context<fmt::v8::appender, char> >::basic_format_args<unsigned long>' requested here
  return vformat(fmt, fmt::make_format_args(args...));
                      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/RenormedFrequencyTable.h:41:37: note: in instantiation of function template specialization 'fmt::v8::format<unsigned long>' requested here
      throw std::runtime_error{fmt::format("FrequencyTable needs to be renormed to {} Bits.", this->getRenormingBits())};
                                    ^
In file included from G__O2MathUtils dictionary payload:1139:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/Framework/Logger.h:14:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:27:
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1840:20: error: constexpr variable 'desc' must be initialized by a constant expression
      (is_packed ? detail::encode_types<Context, Args...>()
      ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1953:63: note: in instantiation of static data member 'fmt::v8::format_arg_store<fmt::v8::basic_format_context<fmt::v8::appender, char>, unsigned long>::desc' requested here
      : basic_format_args(format_arg_store<Context, Args...>::desc,
                                                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3119:23: note: in instantiation of function template specialization 'fmt::v8::basic_format_args<fmt::v8::basic_format_context<fmt::v8::appender, char> >::basic_format_args<unsigned long>' requested here
  return vformat(fmt, fmt::make_format_args(args...));
                      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/RenormedFrequencyTable.h:41:37: note: in instantiation of function template specialization 'fmt::v8::format<unsigned long>' requested here
      throw std::runtime_error{fmt::format("FrequencyTable needs to be renormed to {} Bits.", this->getRenormingBits())};
                                    ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:335:24: error: no member named '_M_start' in 'std::_Vector_base<int, std::allocator<int> >::_Vector_impl'
        _M_deallocate(_M_impl._M_start,
                      ~~~~~~~ ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:487:7: note: in instantiation of member function 'std::_Vector_base<int, std::allocator<int> >::~_Vector_base' requested here
      vector() = default;
      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:680:30: error: no member named '_M_start' in 'std::_Vector_base<int, std::allocator<int> >::_Vector_impl'
        std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
                      ~~~~~~~~~~~~~ ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:41:3: note: in instantiation of member function 'std::vector<int, std::allocator<int> >::~vector' requested here
  ReverseSymbolLookupTable() noexcept {}; // NOLINT
  ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:942:34: error: no member named '_M_start' in 'std::_Vector_base<int, std::allocator<int> >::_Vector_impl'
          _M_erase_at_end(this->_M_impl._M_start + __new_size);
                          ~~~~~~~~~~~~~ ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:47:10: note: in instantiation of member function 'std::vector<int, std::allocator<int> >::resize' requested here
    mLut.resize(frequencyTable.getNumSamples());
         ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/vector.tcc:617:49: error: no member named '_M_end_of_storage' in 'std::_Vector_base<int, std::allocator<int> >::_Vector_impl'
          size_type __navail = size_type(this->_M_impl._M_end_of_storage
                                         ~~~~~~~~~~~~~ ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:940:4: note: in instantiation of member function 'std::vector<int, std::allocator<int> >::_M_default_append' requested here
          _M_default_append(__new_size - size());
          ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:47:10: note: in instantiation of member function 'std::vector<int, std::allocator<int> >::resize' requested here
    mLut.resize(frequencyTable.getNumSamples());
         ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:1794:36: error: no member named '_M_finish' in 'std::_Vector_base<int, std::allocator<int> >::_Vector_impl'
        if (size_type __n = this->_M_impl._M_finish - __pos)
                            ~~~~~~~~~~~~~ ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:942:4: note: in instantiation of member function 'std::vector<int, std::allocator<int> >::_M_erase_at_end' requested here
          _M_erase_at_end(this->_M_impl._M_start + __new_size);
          ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:47:10: note: in instantiation of member function 'std::vector<int, std::allocator<int> >::resize' requested here
    mLut.resize(frequencyTable.getNumSamples());
         ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:1046:25: error: no member named '_M_start' in 'std::_Vector_base<int, std::allocator<int> >::_Vector_impl'
        return *(this->_M_impl._M_start + __n);
                 ~~~~~~~~~~~~~ ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:54:13: note: in instantiation of member function 'std::vector<int, std::allocator<int> >::operator[]' requested here
        mLut[cumulative] = symbol;
            ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:919:40: error: no member named '_M_finish' in 'std::_Vector_base<int, std::allocator<int> >::_Vector_impl'
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
                         ~~~~~~~~~~~~~ ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:69:41: note: in instantiation of member function 'std::vector<int, std::allocator<int> >::size' requested here
                << "elements: " << mLut.size() << ", "
                                        ^
In file included from G__O2MathUtils dictionary payload:1139:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/Framework/Logger.h:14:
/home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:300:18: error: use of overloaded operator '<<' is ambiguous (with operand types 'std::ostringstream' (aka 'basic_ostringstream<char>') and 'const unsigned long')
        fContent << t;
        ~~~~~~~~ ^  ~
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:69:33: note: in instantiation of function template specialization 'fair::Logger::operator<<<unsigned long>' requested here
                << "elements: " << mLut.size() << ", "
                                ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:517:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:511:5: note: candidate function [with _CharT = char, _Traits = std::char_traits<char>]
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:523:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/ostream:528:5: note: candidate function [with _Traits = std::char_traits<char>]
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TString.h:470:16: note: candidate function
std::ostream  &operator<<(std::ostream &str, const TString &s);
               ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TTimeStamp.h:59:15: note: candidate function
std::ostream &operator<<(std::ostream &os,  const TTimeStamp &ts);
              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TBits.h:184:22: note: candidate function
inline std::ostream &operator<<(std::ostream& os, const TBits& rhs)
                     ^
/home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/include/TGeoVector3.h:194:15: note: candidate function
std::ostream &operator<<(std::ostream &os, ROOT::Geom::Vertex_t const &vec);
              ^
In file included from G__O2MathUtils dictionary payload:1139:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/Framework/Logger.h:14:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:27:
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1855:71: error: no member named 'value' in 'fmt::v8::detail::type_constant<unsigned int, char>'
            detail::mapped_type_constant<remove_cvref_t<T>, Context>::value>(
                                                                      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1872:10: note: in instantiation of function template specialization 'fmt::v8::format_arg_store<fmt::v8::basic_format_context<fmt::v8::appender, char>, unsigned int, unsigned long>::format_arg_store<unsigned int &, unsigned long &>' requested here
  return {std::forward<Args>(args)...};
         ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3119:28: note: in instantiation of function template specialization 'fmt::v8::make_format_args<fmt::v8::basic_format_context<fmt::v8::appender, char>, unsigned int &, unsigned long &>' requested here
  return vformat(fmt, fmt::make_format_args(args...));
                           ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:83:44: note: in instantiation of function template specialization 'fmt::v8::format<unsigned int &, unsigned long>' requested here
    LOG_IF(fatal, cumul >= size()) << fmt::format("[iLUT]: {} exceeds max {}", cumul, size());
                                           ^
In file included from G__O2MathUtils dictionary payload:1139:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/Framework/Logger.h:14:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:27:
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1688:68: error: no member named 'value' in 'fmt::v8::detail::type_constant<unsigned int, char>'
  return static_cast<unsigned>(mapped_type_constant<Arg, Context>::value) |
                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1840:28: note: in instantiation of function template specialization 'fmt::v8::detail::encode_types<fmt::v8::basic_format_context<fmt::v8::appender, char>, unsigned int, unsigned long>' requested here
      (is_packed ? detail::encode_types<Context, Args...>()
                           ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1953:63: note: in instantiation of static data member 'fmt::v8::format_arg_store<fmt::v8::basic_format_context<fmt::v8::appender, char>, unsigned int, unsigned long>::desc' requested here
      : basic_format_args(format_arg_store<Context, Args...>::desc,
                                                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3119:23: note: in instantiation of function template specialization 'fmt::v8::basic_format_args<fmt::v8::basic_format_context<fmt::v8::appender, char> >::basic_format_args<unsigned int, unsigned long>' requested here
  return vformat(fmt, fmt::make_format_args(args...));
                      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:83:44: note: in instantiation of function template specialization 'fmt::v8::format<unsigned int &, unsigned long>' requested here
    LOG_IF(fatal, cumul >= size()) << fmt::format("[iLUT]: {} exceeds max {}", cumul, size());
                                           ^
In file included from G__O2MathUtils dictionary payload:1139:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/Framework/Logger.h:14:
In file included from /home/abigot/alice/sw/ubuntu2004_x86-64/FairLogger/v1.11.1-1/include/fairlogger/Logger.h:27:
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1840:20: error: constexpr variable 'desc' must be initialized by a constant expression
      (is_packed ? detail::encode_types<Context, Args...>()
      ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:1953:63: note: in instantiation of static data member 'fmt::v8::format_arg_store<fmt::v8::basic_format_context<fmt::v8::appender, char>, unsigned int, unsigned long>::desc' requested here
      : basic_format_args(format_arg_store<Context, Args...>::desc,
                                                              ^
/home/abigot/alice/sw/ubuntu2004_x86-64/fmt/8.1.1-3/include/fmt/core.h:3119:23: note: in instantiation of function template specialization 'fmt::v8::basic_format_args<fmt::v8::basic_format_context<fmt::v8::appender, char> >::basic_format_args<unsigned int, unsigned long>' requested here
  return vformat(fmt, fmt::make_format_args(args...));
                      ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:83:44: note: in instantiation of function template specialization 'fmt::v8::format<unsigned int &, unsigned long>' requested here
    LOG_IF(fatal, cumul >= size()) << fmt::format("[iLUT]: {} exceeds max {}", cumul, size());
                                           ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:1064:25: error: no member named '_M_start' in 'std::_Vector_base<int, std::allocator<int> >::_Vector_impl'
        return *(this->_M_impl._M_start + __n);
                 ~~~~~~~~~~~~~ ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:85:16: note: in instantiation of member function 'std::vector<int, std::allocator<int> >::operator[]' requested here
    return mLut[cumul];
               ^
In module 'std' imported from input_line_1:1:
/home/abigot/alice/sw/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/bin/../lib/gcc/x86_64-unknown-linux-gnu/10.2.0/../../../../include/c++/10.2.0/bits/stl_vector.h:1173:42: error: no member named '_M_start' in 'std::_Vector_base<int, std::allocator<int> >::_Vector_impl'
      { return _M_data_ptr(this->_M_impl._M_start); }
                           ~~~~~~~~~~~~~ ^
/home/abigot/alice/sw/ubuntu2004_x86-64/O2/Test-local1/include/rANS/internal/ReverseSymbolLookupTable.h:87:58: note: in instantiation of member function 'std::vector<int, std::allocator<int> >::data' requested here
  inline iterator_t begin() const noexcept { return mLut.data(); };
                                                         ^

 *** Break *** segmentation violation



===========================================================
There was a crash.
This is the entire stack trace of all threads:
===========================================================
#0  0x00007fa265563c3a in wait4 () from /lib/x86_64-linux-gnu/libc.so.6
#1  0x00007fa2654d2f67 in ?? () from /lib/x86_64-linux-gnu/libc.so.6
#2  0x00007fa265cd818c in TUnixSystem::Exec (shellcmd=<optimised out>, this=0x583800) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/unix/src/TUnixSystem.cxx:2108
#3  TUnixSystem::StackTrace (this=0x583800) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/unix/src/TUnixSystem.cxx:2399
#4  0x00007fa265cd58f5 in TUnixSystem::DispatchSignals (this=0x583800, sig=kSigSegmentationViolation) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/unix/src/TUnixSystem.cxx:3619
#5  <signal handler called>
#6  0x00007fa263bc3a1c in clang::CXXRecordDecl::getLambdaCallOperator() const () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#7  0x00007fa261632b68 in clang::RecursiveASTVisitor<cling::(anonymous namespace)::StaticVarCollector>::TraverseLambdaExpr(clang::LambdaExpr*, llvm::SmallVectorImpl<llvm::PointerIntPair<clang::Stmt*, 1u, bool, llvm::PointerLikeTypeTraits<clang::Stmt*>, llvm::PointerIntPairInfo<clang::Stmt*, 1u, llvm::PointerLikeTypeTraits<clang::Stmt*> > > >*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#8  0x00007fa26162eea5 in clang::RecursiveASTVisitor<cling::(anonymous namespace)::StaticVarCollector>::TraverseStmt(clang::Stmt*, llvm::SmallVectorImpl<llvm::PointerIntPair<clang::Stmt*, 1u, bool, llvm::PointerLikeTypeTraits<clang::Stmt*>, llvm::PointerIntPairInfo<clang::Stmt*, 1u, llvm::PointerLikeTypeTraits<clang::Stmt*> > > >*) [clone .constprop.0] () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#9  0x00007fa26162b01d in clang::RecursiveASTVisitor<cling::(anonymous namespace)::StaticVarCollector>::TraverseDecl(clang::Decl*) [clone .part.0] () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#10 0x00007fa26162b94e in clang::RecursiveASTVisitor<cling::(anonymous namespace)::StaticVarCollector>::TraverseDeclStmt(clang::DeclStmt*, llvm::SmallVectorImpl<llvm::PointerIntPair<clang::Stmt*, 1u, bool, llvm::PointerLikeTypeTraits<clang::Stmt*>, llvm::PointerIntPairInfo<clang::Stmt*, 1u, llvm::PointerLikeTypeTraits<clang::Stmt*> > > >*) [clone .constprop.0] () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#11 0x00007fa26162eea5 in clang::RecursiveASTVisitor<cling::(anonymous namespace)::StaticVarCollector>::TraverseStmt(clang::Stmt*, llvm::SmallVectorImpl<llvm::PointerIntPair<clang::Stmt*, 1u, bool, llvm::PointerLikeTypeTraits<clang::Stmt*>, llvm::PointerIntPairInfo<clang::Stmt*, 1u, llvm::PointerLikeTypeTraits<clang::Stmt*> > > >*) [clone .constprop.0] () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#12 0x00007fa26162f19b in cling::DeclUnloader::VisitFunctionDecl(clang::FunctionDecl*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#13 0x00007fa2615ff7e4 in cling::TransactionUnloader::unloadDeserializedDeclarations(cling::Transaction*, cling::DeclUnloader&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#14 0x00007fa2615ffcee in cling::TransactionUnloader::RevertTransaction(cling::Transaction*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#15 0x00007fa2615e49b8 in cling::Interpreter::unload(cling::Transaction&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#16 0x00007fa26166aecf in cling::IncrementalParser::commitTransaction(llvm::PointerIntPair<cling::Transaction*, 2u, cling::IncrementalParser::EParseResult, llvm::PointerLikeTypeTraits<cling::Transaction*>, llvm::PointerIntPairInfo<cling::Transaction*, 2u, llvm::PointerLikeTypeTraits<cling::Transaction*> > >&, bool) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#17 0x00007fa26166c6a9 in cling::IncrementalParser::Compile(llvm::StringRef, cling::CompilationOptions const&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#18 0x00007fa2615e1bab in cling::Interpreter::parseForModule(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#19 0x00007fa261524a74 in ExecAutoParse (what=0x7ffce1987610 "\020'b", header=<optimised out>, interpreter=0x5f6600) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/metacling/src/TCling.cxx:6269
#20 0x00007fa261529df8 in TCling::AutoParseImplRecurse (this=0x5f5080, cls=<optimised out>, topLevel=<optimised out>) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/include/c++/10.2.0/bits/unique_ptr.h:173
#21 0x00007fa261532267 in TCling::AutoParse (this=0x5f5080, cls=0xc7f0f00 "o2::detectors::MatrixCache") at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/metacling/src/TCling.cxx:6459
#22 0x00007fa26156e7ff in TClingCallbacks::tryAutoParseInternal (this=0x1d0ab30, Name=..., R=..., S=0x7ffce1988590, FE=0x0) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/include/c++/10.2.0/bits/basic_string.h:186
#23 0x00007fa2615702cd in TClingCallbacks::LookupObject (this=0x1d0ab30, DC=0x1f891b0, Name=...) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/include/c++/10.2.0/bits/basic_string.h:907
#24 0x00007fa2615eafa3 in cling::MultiplexInterpreterCallbacks::LookupObject(clang::DeclContext const*, clang::DeclarationName) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#25 0x00007fa261f0dc48 in clang::MultiplexExternalSemaSource::FindExternalVisibleDeclsByName(clang::DeclContext const*, clang::DeclarationName) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#26 0x00007fa263bc111a in clang::DeclContext::lookup(clang::DeclarationName) const () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#27 0x00007fa261dae428 in clang::ASTReader::CompleteRedeclChain(clang::Decl const*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#28 0x00007fa261f0da20 in clang::MultiplexExternalSemaSource::CompleteRedeclChain(clang::Decl const*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#29 0x00007fa263bf78e1 in clang::RedeclarableTemplateDecl::loadLazySpecializationsImpl(bool) const [clone .constprop.1] () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#30 0x00007fa263bf7999 in clang::ClassTemplateDecl::getSpecializations() const () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#31 0x00007fa26162fab1 in cling::DeclUnloader::VisitClassTemplateDecl(clang::ClassTemplateDecl*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#32 0x00007fa26163048b in cling::DeclUnloader::VisitDeclContext(clang::DeclContext*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#33 0x00007fa2616305c9 in cling::DeclUnloader::VisitNamespaceDecl(clang::NamespaceDecl*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#34 0x00007fa26163049b in cling::DeclUnloader::VisitDeclContext(clang::DeclContext*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#35 0x00007fa2616305c9 in cling::DeclUnloader::VisitNamespaceDecl(clang::NamespaceDecl*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#36 0x00007fa2615ff7e4 in cling::TransactionUnloader::unloadDeserializedDeclarations(cling::Transaction*, cling::DeclUnloader&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#37 0x00007fa2615ffcee in cling::TransactionUnloader::RevertTransaction(cling::Transaction*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#38 0x00007fa2615e49b8 in cling::Interpreter::unload(cling::Transaction&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#39 0x00007fa2615ff901 in cling::TransactionUnloader::unloadDeclarations(cling::Transaction*, cling::DeclUnloader&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#40 0x00007fa2615ffbec in cling::TransactionUnloader::RevertTransaction(cling::Transaction*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#41 0x00007fa2615e49b8 in cling::Interpreter::unload(cling::Transaction&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#42 0x00007fa26166aecf in cling::IncrementalParser::commitTransaction(llvm::PointerIntPair<cling::Transaction*, 2u, cling::IncrementalParser::EParseResult, llvm::PointerLikeTypeTraits<cling::Transaction*>, llvm::PointerIntPairInfo<cling::Transaction*, 2u, llvm::PointerLikeTypeTraits<cling::Transaction*> > >&, bool) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#43 0x00007fa26166c6a9 in cling::IncrementalParser::Compile(llvm::StringRef, cling::CompilationOptions const&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#44 0x00007fa2615e4797 in cling::Interpreter::loadHeader(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, cling::Transaction**) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#45 0x00007fa2616ad393 in cling::MetaSema::actOnLCommand(llvm::StringRef, cling::Transaction**) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#46 0x00007fa2616ad52f in cling::MetaSema::actOnxCommand(llvm::StringRef, llvm::StringRef, cling::Value*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#47 0x00007fa2616bbcc9 in cling::MetaParser::isXCommand(cling::MetaSema::ActionResult&, cling::Value*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#48 0x00007fa2616bd5a4 in cling::MetaParser::isCommand(cling::MetaSema::ActionResult&, cling::Value*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#49 0x00007fa2616a6a40 in cling::MetaProcessor::process(llvm::StringRef, cling::Interpreter::CompilationResult&, cling::Value*, bool) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#50 0x00007fa26151976c in HandleInterpreterException (metaProcessor=0x10a6af0, input_line=0x1da5af0 ".X  /home/abigot/alice/O2/Detectors/ITSMFT/common/data/alpideResponseData/./alpideResponse.C", compRes=
0x7ffce1989814: cling::Interpreter::kSuccess, result=0x7ffce1989940) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/metacling/src/TCling.cxx:2441
#51 0x00007fa261526e76 in TCling::ProcessLine (this=0x5f5080, line=<optimised out>, error=0x7ffce198a82c) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/include/c++/10.2.0/bits/unique_ptr.h:173
#52 0x00007fa261527152 in TCling::ProcessLineSynch (this=0x5f5080, line=0x12a4ca0 ".X  /home/abigot/alice/O2/Detectors/ITSMFT/common/data/alpideResponseData/./alpideResponse.C", error=0x7ffce198a82c) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/metacling/src/TCling.cxx:3521
#53 0x00007fa265b9e9f3 in TApplication::ExecuteFile (file=<optimised out>, error=0x7ffce198a82c, keep=<optimised out>) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/base/src/TApplication.cxx:1593
#54 0x00007fa265f4ab82 in TRint::ProcessLineNr (this=0x5dcdd0, filestem=<optimised out>, line=0x7ffce198a840 ".x alpideResponse.C", error=0x7ffce198a82c) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/rint/src/TRint.cxx:811
#55 0x00007fa265f4c77e in TRint::Run (this=this
entry=0x5dcdd0, retrn=retrn
entry=false) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/rint/src/TRint.cxx:462
#56 0x00000000004011ad in main (argc=<optimised out>, argv=0x7ffce198c9c8) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/main/src/rmain.cxx:84
===========================================================


The lines below might hint at the cause of the crash.
You may get help by asking at the ROOT forum https://root.cern/forum
Only if you are really convinced it is a bug in ROOT then please submit a
report at https://root.cern/bugs Please post the ENTIRE stack trace
from above as an attachment in addition to anything else
that might help us fixing this issue.
===========================================================
#6  0x00007fa263bc3a1c in clang::CXXRecordDecl::getLambdaCallOperator() const () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#7  0x00007fa261632b68 in clang::RecursiveASTVisitor<cling::(anonymous namespace)::StaticVarCollector>::TraverseLambdaExpr(clang::LambdaExpr*, llvm::SmallVectorImpl<llvm::PointerIntPair<clang::Stmt*, 1u, bool, llvm::PointerLikeTypeTraits<clang::Stmt*>, llvm::PointerIntPairInfo<clang::Stmt*, 1u, llvm::PointerLikeTypeTraits<clang::Stmt*> > > >*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#8  0x00007fa26162eea5 in clang::RecursiveASTVisitor<cling::(anonymous namespace)::StaticVarCollector>::TraverseStmt(clang::Stmt*, llvm::SmallVectorImpl<llvm::PointerIntPair<clang::Stmt*, 1u, bool, llvm::PointerLikeTypeTraits<clang::Stmt*>, llvm::PointerIntPairInfo<clang::Stmt*, 1u, llvm::PointerLikeTypeTraits<clang::Stmt*> > > >*) [clone .constprop.0] () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#9  0x00007fa26162b01d in clang::RecursiveASTVisitor<cling::(anonymous namespace)::StaticVarCollector>::TraverseDecl(clang::Decl*) [clone .part.0] () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#10 0x00007fa26162b94e in clang::RecursiveASTVisitor<cling::(anonymous namespace)::StaticVarCollector>::TraverseDeclStmt(clang::DeclStmt*, llvm::SmallVectorImpl<llvm::PointerIntPair<clang::Stmt*, 1u, bool, llvm::PointerLikeTypeTraits<clang::Stmt*>, llvm::PointerIntPairInfo<clang::Stmt*, 1u, llvm::PointerLikeTypeTraits<clang::Stmt*> > > >*) [clone .constprop.0] () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#11 0x00007fa26162eea5 in clang::RecursiveASTVisitor<cling::(anonymous namespace)::StaticVarCollector>::TraverseStmt(clang::Stmt*, llvm::SmallVectorImpl<llvm::PointerIntPair<clang::Stmt*, 1u, bool, llvm::PointerLikeTypeTraits<clang::Stmt*>, llvm::PointerIntPairInfo<clang::Stmt*, 1u, llvm::PointerLikeTypeTraits<clang::Stmt*> > > >*) [clone .constprop.0] () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#12 0x00007fa26162f19b in cling::DeclUnloader::VisitFunctionDecl(clang::FunctionDecl*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#13 0x00007fa2615ff7e4 in cling::TransactionUnloader::unloadDeserializedDeclarations(cling::Transaction*, cling::DeclUnloader&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#14 0x00007fa2615ffcee in cling::TransactionUnloader::RevertTransaction(cling::Transaction*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#15 0x00007fa2615e49b8 in cling::Interpreter::unload(cling::Transaction&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#16 0x00007fa26166aecf in cling::IncrementalParser::commitTransaction(llvm::PointerIntPair<cling::Transaction*, 2u, cling::IncrementalParser::EParseResult, llvm::PointerLikeTypeTraits<cling::Transaction*>, llvm::PointerIntPairInfo<cling::Transaction*, 2u, llvm::PointerLikeTypeTraits<cling::Transaction*> > >&, bool) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#17 0x00007fa26166c6a9 in cling::IncrementalParser::Compile(llvm::StringRef, cling::CompilationOptions const&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#18 0x00007fa2615e1bab in cling::Interpreter::parseForModule(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#19 0x00007fa261524a74 in ExecAutoParse (what=0x7ffce1987610 "020'b", header=<optimised out>, interpreter=0x5f6600) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/metacling/src/TCling.cxx:6269
#20 0x00007fa261529df8 in TCling::AutoParseImplRecurse (this=0x5f5080, cls=<optimised out>, topLevel=<optimised out>) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/include/c++/10.2.0/bits/unique_ptr.h:173
#21 0x00007fa261532267 in TCling::AutoParse (this=0x5f5080, cls=0xc7f0f00 "o2::detectors::MatrixCache") at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/metacling/src/TCling.cxx:6459
#22 0x00007fa26156e7ff in TClingCallbacks::tryAutoParseInternal (this=0x1d0ab30, Name=..., R=..., S=0x7ffce1988590, FE=0x0) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/include/c++/10.2.0/bits/basic_string.h:186
#23 0x00007fa2615702cd in TClingCallbacks::LookupObject (this=0x1d0ab30, DC=0x1f891b0, Name=...) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/ubuntu2004_x86-64/GCC-Toolchain/v10.2.0-alice2-2/include/c++/10.2.0/bits/basic_string.h:907
#24 0x00007fa2615eafa3 in cling::MultiplexInterpreterCallbacks::LookupObject(clang::DeclContext const*, clang::DeclarationName) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#25 0x00007fa261f0dc48 in clang::MultiplexExternalSemaSource::FindExternalVisibleDeclsByName(clang::DeclContext const*, clang::DeclarationName) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#26 0x00007fa263bc111a in clang::DeclContext::lookup(clang::DeclarationName) const () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#27 0x00007fa261dae428 in clang::ASTReader::CompleteRedeclChain(clang::Decl const*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#28 0x00007fa261f0da20 in clang::MultiplexExternalSemaSource::CompleteRedeclChain(clang::Decl const*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#29 0x00007fa263bf78e1 in clang::RedeclarableTemplateDecl::loadLazySpecializationsImpl(bool) const [clone .constprop.1] () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#30 0x00007fa263bf7999 in clang::ClassTemplateDecl::getSpecializations() const () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#31 0x00007fa26162fab1 in cling::DeclUnloader::VisitClassTemplateDecl(clang::ClassTemplateDecl*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#32 0x00007fa26163048b in cling::DeclUnloader::VisitDeclContext(clang::DeclContext*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#33 0x00007fa2616305c9 in cling::DeclUnloader::VisitNamespaceDecl(clang::NamespaceDecl*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#34 0x00007fa26163049b in cling::DeclUnloader::VisitDeclContext(clang::DeclContext*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#35 0x00007fa2616305c9 in cling::DeclUnloader::VisitNamespaceDecl(clang::NamespaceDecl*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#36 0x00007fa2615ff7e4 in cling::TransactionUnloader::unloadDeserializedDeclarations(cling::Transaction*, cling::DeclUnloader&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#37 0x00007fa2615ffcee in cling::TransactionUnloader::RevertTransaction(cling::Transaction*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#38 0x00007fa2615e49b8 in cling::Interpreter::unload(cling::Transaction&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#39 0x00007fa2615ff901 in cling::TransactionUnloader::unloadDeclarations(cling::Transaction*, cling::DeclUnloader&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#40 0x00007fa2615ffbec in cling::TransactionUnloader::RevertTransaction(cling::Transaction*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#41 0x00007fa2615e49b8 in cling::Interpreter::unload(cling::Transaction&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#42 0x00007fa26166aecf in cling::IncrementalParser::commitTransaction(llvm::PointerIntPair<cling::Transaction*, 2u, cling::IncrementalParser::EParseResult, llvm::PointerLikeTypeTraits<cling::Transaction*>, llvm::PointerIntPairInfo<cling::Transaction*, 2u, llvm::PointerLikeTypeTraits<cling::Transaction*> > >&, bool) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#43 0x00007fa26166c6a9 in cling::IncrementalParser::Compile(llvm::StringRef, cling::CompilationOptions const&) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#44 0x00007fa2615e4797 in cling::Interpreter::loadHeader(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, cling::Transaction**) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#45 0x00007fa2616ad393 in cling::MetaSema::actOnLCommand(llvm::StringRef, cling::Transaction**) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#46 0x00007fa2616ad52f in cling::MetaSema::actOnxCommand(llvm::StringRef, llvm::StringRef, cling::Value*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#47 0x00007fa2616bbcc9 in cling::MetaParser::isXCommand(cling::MetaSema::ActionResult&, cling::Value*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#48 0x00007fa2616bd5a4 in cling::MetaParser::isCommand(cling::MetaSema::ActionResult&, cling::Value*) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#49 0x00007fa2616a6a40 in cling::MetaProcessor::process(llvm::StringRef, cling::Interpreter::CompilationResult&, cling::Value*, bool) () from /home/abigot/alice/sw/ubuntu2004_x86-64/ROOT/v6-26-04-patches-alice1-6/lib/libCling.so
#50 0x00007fa26151976c in HandleInterpreterException (metaProcessor=0x10a6af0, input_line=0x1da5af0 ".X  /home/abigot/alice/O2/Detectors/ITSMFT/common/data/alpideResponseData/./alpideResponse.C", compRes=
0x7ffce1989814: cling::Interpreter::kSuccess, result=0x7ffce1989940) at /mnt/mesos/sandbox/sandbox/jenkins/workspace/DailyBuilds/DailyO2-ubuntu2004/daily-tags.aqAYE4xRnC/SOURCES/ROOT/v6-26-04-patches-alice1/v6-26-04-patches-alice1/core/metacling/src/TCling.cxx:2441
===========================================================


